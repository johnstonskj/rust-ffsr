;;; SRFI 1
;;; List-processing library
;;; 
;;; R5RS Scheme has an impoverished set of list-processing utilities, which is a problem
;;; for authors of portable code. This SRFI proposes a coherent and comprehensive set of
;;; list-processing procedures.
;;;
;;; This implementation is incomplete. It leaves out all functionality using mutable pairs,
;;; since mutable lists are not supported by LispKit.
;;;
;;; Portions of this code: SRFI 1 reference implementation
;;;   Copyright © 1998, 1999 by Olin Shivers.
;;;   You may do as you please with this code as long as you do not remove this copyright
;;;   notice or hold me liable for its use. Please send bug reports to shivers@ai.mit.edu.
;;;
;;; Portions of this code: SRFI 1 library provided by Picrin
;;;   Copyright © 2013-2014 Yuichi Nishiwaki and other picrin contributors.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 1)

  (import (lispkit base))

  ;; # Constructors
  ;; cons list
  ;; xcons cons* make-list list-tabulate
  ;; list-copy iota

  (begin
    (define (xcons d a) (cons a d))

    ; (define (cons* first . rest)
    ;   (let recur ((x first) (rest rest))
    ;      (if (pair? rest)
    ;          (cons x (recur (car rest) (cdr rest)))
    ;          x)))

    (define (list-tabulate len proc)
      (do ((i (- len 1) (- i 1))
           (ans '() (cons (proc i) ans)))
          ((< i 0) ans)))

    ; (define (iota count . lst)
    ;   (let ((start (if (pair? lst) (car lst) 0))
    ;         (step (if (and (pair? lst)
    ;                   (pair? (cdr lst)))
    ;                   (cadr lst) 1)))
    ;     (let rec ((count (- count 1))
    ;               (acc '()))
    ;       (if (zero? count)
    ;           (cons start acc)
    ;           (rec (- count 1) (cons (+ start (* count step)) acc))))))
  )

  (export cons list xcons cons* make-list list-tabulate iota)

  ;; # Predicates
  ;; pair? null?
  ;; proper-list? dotted-list?
  ;; not-pair? null-list?
  ;; list=

  (begin
    (define (not-pair? x) (not (pair? x)))

    (define proper-list? list?)

    (define (dotted-list? x)
      (and (pair? x) (not (proper-list? x))))

    (define (null-list? x)
      (cond ((pair? x) #f)
            ((null? x) #t)
            (else (error "null-list?: argument out of domain" x))))

    (define (list= elt= . lists)
      (or (null? lists)
          (let rec1 ((list1 (car lists)) (others (cdr lists)))
            (or (null? others)
                (let ((list2 (car others))
                      (others (cdr others)))
                  (if (eq? list1 list2)
                      (rec1 list2 others)
                      (let rec2 ((l1 list1) (l2 list2))
                        (if (null-list? l1)
                            (and (null-list? l2)
                                 (rec1 list2 others))
                            (and (not (null-list? l2))
                                 (elt= (car l1) (car l2))
                                 (rec2 (cdr l1) (cdr l2))))))))))))

  (export pair? null? not-pair? proper-list? dotted-list? null-list? list=)

  ;; # Selectors
  ;; car cdr ... cddadr cddddr list-ref
  ;; first second third fourth fifth sixth seventh eighth ninth tenth
  ;; car+cdr
  ;; take drop
  ;; take-right drop-right
  ;; split-at
  ;; last last-pair

  (begin
    (define (take x i)
      (if (zero? i)
          '()
          (cons (car x) (take (cdr x) (- i 1)))))

    (define (drop x i)
      (if (zero? i) x (drop (cdr x) (- i 1))))

    (define (take-right lis k)
      (let lp ((lag lis)
               (lead (drop lis k)))
        (if (pair? lead)
            (lp (cdr lag) (cdr lead))
            lag)))

    (define (drop-right lis k)
      (let recur ((lag lis) (lead (drop lis k)))
        (if (pair? lead)
            (cons (car lag) (recur (cdr lag) (cdr lead)))
            '())))

    (define (split-at x i)
      (values (take x i) (drop x i)))

    (define (last pair)
      (car (take-right pair 1)))

    (define (last-pair pair)
      (take-right pair 1))

    (define first car)

    (define second cadr)

    (define third caddr)

    (define fourth cadddr)

    (define (fifth x) (car    (cddddr x)))

    (define (sixth x) (cadr   (cddddr x)))

    (define (seventh x) (caddr  (cddddr x)))

    (define (eighth x) (cadddr (cddddr x)))

    (define (ninth x) (car  (cddddr (cddddr x))))

    (define (tenth x) (cadr (cddddr (cddddr x))))

    (define (car+cdr pair) (values (car pair) (cdr pair))))

  (export car cdr car+cdr list-ref
          caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr
          caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr
          cdadar cdaddr cddaar cddadr cdddar cddddr
          first second third fourth fifth sixth seventh eighth ninth tenth
          take drop take-right drop-right
          split-at last last-pair)

  ;; # Miscellaneous
  ;; length
  ;; append concatenate reverse
  ;; append-reverse
  ;; zip unzip1 unzip2 unzip3 unzip4 unzip5
  ;; count

  (begin
    ; (define (concatenate lists)
    ;   (apply append lists))

    (define (append-reverse rev-head tail)
      (if (null? rev-head)
          tail
          (append-reverse (cdr rev-head) (cons (car rev-head) tail))))

    (define (zip . lists)
      (apply map list lists))

    (define (unzip1 list)
      (map first list))

    (define (unzip2 list)
      (values (map first list)
              (map second list)))

    (define (unzip3 list)
      (values (map first list)
              (map second list)
              (map third list)))

    (define (unzip4 list)
      (values (map first list)
              (map second list)
              (map third list)
              (map fourth list)))

    (define (unzip5 list)
      (values (map first list)
              (map second list)
              (map third list)
              (map fourth list)
              (map fifth list)))

    (define (count pred . clists)
      (let rec ((tflst (apply map pred clists)) (n 0))
        (if (null? tflst)
            n
            (rec (cdr tflst) (if (car tflst) (+ n 1) n))))))

  (export length
          append concatenate
          reverse append-reverse
          zip unzip1 unzip2 unzip3 unzip4 unzip5
          count)

  ;; # Fold, unfold & map
  ;; map for-each
  ;; fold unfold pair-fold reduce
  ;; fold-right unfold-right pair-fold right reduce-right
  ;; append-map
  ;; pair-for-each filter-map map-in-order

  (begin
    (define (fold kons knil clist . clists)
      (if (null? clists)
          (let rec ((acc knil) (clist clist))
            (if (null? clist)
                acc
                (rec (kons (car clist) acc) (cdr clist))))
          (let rec ((acc knil) (clists (cons clist clists)))
            (if (every pair? clists)
                (rec (apply kons (append (map car clists) (list acc)))
                     (map cdr clists))
                acc))))

    ; (define (fold-right kons knil clist . clists)
    ;      (if (null? clists)
    ;          (let rec ((clist clist) (cont values))
    ;            (if (null? clist)
    ;                (cont knil)
    ;                (rec (cdr clist) (lambda (x) (cont (kons (car clist) x))))))
    ;          (let rec ((clists (cons clist clists)) (cont values))
    ;            (if (every pair? clists)
    ;                (rec (map cdr clists)
    ;                     (lambda (x)
    ;                       (cont (apply kons (append (map car clists) (list x))))))
    ;                (cont knil)))))

    (define (pair-fold kons knil clist . clists)
      (if (null? clists)
          (let rec ((acc knil) (clist clist))
            (if (null? clist)
                acc
                (let ((tail (cdr clist)))
                  (rec (kons clist acc) tail))))
          (let rec ((acc knil) (clists (cons clist clists)))
            (if (every pair? clists)
                (let ((tail (map cdr clists)))
                  (rec (apply kons (append clists (list acc)))
                       tail))
                acc))))

    (define (pair-fold-right kons knil clist . clists)
      (if (null? clists)
          (let rec ((clist clist) (cont values))
            (if (null? clist)
                (cont knil)
                  (rec (cdr clist) (lambda (x) (cont (kons clist x))))))
          (let rec ((clists (cons clist clists)) (cont values))
            (if (every pair? clists)
                (let ((tail (map cdr clists)))
                  (rec tail
                       (lambda (x)
                         (cont (apply kons (append clists (list x)))))))
                (cont knil)))))

    (define (reduce f ridentity list)
      (if (null? list)
          ridentity
          (fold f (car list) (cdr list))))

    (define (reduce-right f ridentity list)
      (fold-right f ridentity list))

    (define (unfold p f g seed . tail-gen)
      (let ((tail-gen (if (null? tail-gen)
                          (lambda (x) '())
                          (car tail-gen))))
        (let rec ((seed seed) (cont values))
          (if (p seed)
              (cont (tail-gen seed))
              (rec (g seed) (lambda (x) (cont (cons (f seed) x))))))))

    (define (unfold-right p f g seed . tail)
      (let rec ((seed seed) (lst tail))
        (if (p seed)
            lst
            (rec (g seed) (cons (f seed) lst)))))

    ; (define (append-map f . clists)
    ;   (apply append (apply map f clists)))

    (define (pair-for-each f clist . clists)
      (if (null? clist)
          (let rec ((clist clist))
            (if (pair? clist)
                (begin (f clist) (rec (cdr clist)))))
          (let rec ((clists (cons clist clists)))
            (if (every pair? clists)
                (begin (apply f clists) (rec (map cdr clists)))))))

    (define (map-in-order f clist . clists)
      (if (null? clists)
          (let rec ((clist clist)
                    (acc '()))
            (if (null? clist)
                (reverse acc)
                (rec (cdr clist) (cons (f (car clist)) acc))))
          (let rec ((clists (cons clist clists))
                    (acc '()))
            (if (every pair? clists)
                (rec (map cdr clists)
                     (cons* (apply f (map car clists)) acc))
                (reverse acc)))))

    ; (define (filter-map f clist . clists)
    ;   (let recur ((l (apply map f clist clists)))
    ;     (cond ((null? l) '())
    ;           ((car l)   (cons (car l) (recur (cdr l))))
    ;           (else      (recur (cdr l))))))
  )

  (export map for-each
          fold unfold pair-fold reduce
          fold-right unfold-right pair-fold-right reduce-right
          append-map
          pair-for-each filter-map map-in-order)

  ;; # Filtering & partitioning
  ;; filter partition remove

  (begin
    ; (define (filter pred list)
    ;   (let ((pcons (lambda (v acc) (if (pred v) (cons v acc) acc))))
    ;     (reverse (fold pcons '() list))))

    ; (define (remove pred list)
    ;   (filter (lambda (x) (not (pred x))) list))

    ; (define (partition pred list)
    ;   (values (filter pred list)
    ;           (remove pred list)))
  )

  (export filter partition remove)

  ;; # Searching
  ;; member memq memv
  ;; find find-tail
  ;; any every
  ;; list-index
  ;; take-while drop-while
  ;; span break

  (begin
    (define (find-tail pred list)
      (if (null? list)
          #f
          (if (pred (car list))
              list
              (find-tail pred (cdr list)))))

    (define (find pred list)
      (let ((tail (find-tail pred list)))
        (if tail
            (car tail)
            #f)))

    (define (take-while pred clist)
      (let rec ((clist clist) (cont values))
        (if (null? clist)
            (cont '())
            (if (pred (car clist))
                (rec (cdr clist)
                     (lambda (x) (cont (cons (car clist) x))))
                (cont '())))))

    (define (drop-while pred clist)
      (let rec ((clist clist))
        (if (null? clist)
            '()
            (if (pred (car clist))
                (rec (cdr clist))
                clist))))

    (define (span pred clist)
      (values (take-while pred clist)
              (drop-while pred clist)))

    (define (break pred clist)
      (values (take-while (lambda (x) (not (pred x))) clist)
              (drop-while (lambda (x) (not (pred x))) clist)))

    (define (any pred ls . lists)
      (if (null? lists)
          (let lp ((ls ls))
            (cond ((null? ls)        #f)
                  ((null? (cdr ls))  (pred (car ls)))
                  (else              (or (pred (car ls)) (lp (cdr ls))))))
          (let lp ((lists (cons ls lists)))
            (cond ((any1 null? lists)           #f)
                  ((any1 null? (map cdr lists)) (apply pred (map car lists)))
                  (else                         (or (apply pred (map car lists))
                                                    (lp (map cdr lists))))))))

    (define (every pred ls . lists)
      (if (null? lists)
          (let lp ((ls ls))
            (cond ((null? ls)       #t)
                  ((null? (cdr ls)) (pred (car ls)))
                  (else             (and (pred (car ls)) (lp (cdr ls))))))
          (let lp ((lists (cons ls lists)))
            (cond ((any1 null? lists)     #t)
            ((any1 null? (map cdr lists)) (apply pred (map car lists)))
            (else                         (and (apply pred (map car lists))
                                               (lp (map cdr lists))))))))

    (define (list-index pred clist . clists)
      (if (null? clists)
          (let rec ((clist clist) (n 0))
            (if (pair? clist)
                (if (pred (car clist))
                    n
                    (rec (cdr clist) (+ n 1)))))
          (let rec ((clists (cons clist clists)) (n 0))
            (if (every pair? clists)
                (if (apply pred (map car clists))
                    n
                    (rec (map cdr clists) (+ n 1))))))))

  (export member memq memv
          find find-tail
          any every
          list-index
          take-while drop-while
          span break)

  ;; # Deleting
  ;; delete delete-duplicates

  (begin
    ; (define (delete x list . =)
    ;   (let ((= (if (null? =) equal? (car =))))
    ;     (remove (lambda (a) (= x a)) list)))

    (define (delete-duplicates list . =)
      (let ((= (if (null? =) equal? (car =))))
        (let rec ((list list) (cont values))
          (if (null? list)
              (cont '())
              (let* ((x (car list))
                     (rest (cdr list))
                     (deleted (delete x rest =)))
                (rec deleted (lambda (y) (cont (cons x y))))))))))

  (export delete delete-duplicates)

  ;; # Association lists
  ;; assoc assq assv
  ;; alist-cons alist-copy
  ;; alist-delete

  (begin
    (define (alist-cons key datum alist)
      (cons (cons key datum) alist))

    (define (alist-copy alist)
      (map (lambda (elt) (cons (car elt) (cdr elt))) alist))

    ; (define (alist-delete key alist . =)
    ;   (let ((= (if (null? =) equal? (car =))))
    ;     (remove (lambda (x) (= key (car x))) alist)))
  )

  (export assoc assq assv
          alist-cons alist-copy
          alist-delete)

  ;; # Set operations on lists
  ;; lset<= lset= lset-adjoin
  ;; lset-union
  ;; lset-intersection
  ;; lset-difference
  ;; lset-xor
  ;; lset-diff+intersenction

  (begin
    (define (lset<= = . lists)
      (or (null? lists)
          (let rec ((head (car lists)) (rest (cdr lists)))
            (or (null? rest)
                (let ((next (car rest)) (rest (cdr rest)))
                  (and (or (eq? head next)
                           (every (lambda (x) (member x next =)) head))
                       (rec next rest)))))))

    (define (lset= = . lists)
      (or (null? lists)
          (let rec ((head (car lists)) (rest (cdr lists)))
            (or (null? rest)
                (let ((next (car rest)) (rest (cdr rest)))
                  (and (or (eq? head next)
                           (and (every (lambda (x) (member x next =)) head)
                                (every (lambda (x) (member x head =)) next))
                           (rec next rest))))))))

    (define (lset-adjoin = list . elts)
      (let rec ((list list) (elts elts))
        (if (null? elts)
            list
            (if (member (car elts) list)
                (rec list (cdr elts))
                (rec (cons (car elts) list) (cdr elts))))))

    (define (lset-union = . lists)
      (if (null? lists)
          lists
          (let rec ((head (car lists)) (rest (cdr lists)))
            (if (null? rest)
                head
                (let ((next (car rest)) (rest (cdr rest)))
                  (if (eq? head next)
                      (rec head rest)
                      (rec (apply lset-adjoin = head next) rest)))))))

    (define (lset-intersection = . lists)
      (if (null? lists)
          lists
          (let rec ((head (car lists)) (rest (cdr lists)))
            (if (null? rest)
                head
                (let ((next (car rest)) (rest (cdr rest)))
                  (if (eq? head next)
                      (rec head rest)
                      (rec (filter (lambda (x) (member x next =)) head)
                           rest)))))))

    (define (lset-difference = list . lists)
      (let rec ((head list) (rest lists))
        (if (null? rest)
            head
            (let ((next (car rest)) (rest (cdr rest)))
              (if (eq? head next)
                  '()
                  (rec (remove (lambda (x) (member x next =)) head)
                       rest))))))

    (define (lset-xor = . lists)
      (if (null? lists)
          lists
          (let rec ((head (car lists)) (rest (cdr lists)))
            (if (null? rest)
                head
                (let ((next (car rest)) (rest (cdr rest)))
                  (if (eq? head next)
                      '()
                      (rec (append (remove (lambda (x) (member x next =)) head)
                                   (remove (lambda (x) (member x head =)) next))
                           rest)))))))

    (define (lset-diff+intersection = list . lists)
      (values (apply lset-difference = list lists)
              (lset-intersection = list (apply lset-union lists)))))

  (export lset<=
          lset=
          lset-adjoin
          lset-union
          lset-intersection
          lset-difference
          lset-xor
          lset-diff+intersection)
)
;;; SRFI 101
;;; Purely Functional Random-Access Pairs and Lists
;;;
;;; Random-access lists are a purely functional data structure for representing
;;; lists of values. A random-access list may act as a drop in replacement for the
;;; usual linear-access pair and list data structures (pair?, cons, car, cdr), which
;;; additionally supports fast index-based addressing and updating (list-ref, list-set).
;;; The impact is a whole class of purely-functional algorithms expressed in terms of
;;; index-based list addressing become feasible compared with their linear-access list
;;; counterparts.
;;;
;;; This library implements an API for purely functional random-access lists consistent
;;; with the R6RS base library and list utility standard library.
;;;
;;; Copyright © 2009 David Van Horn. All rights reserved.
;;; Adapted for R7RS by Alex Shinn, 2018.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2019 Matthias Zenger. All rights reserved.

(define-library (srfi 101)

  (export (rename ra:quote quote)
          (rename ra:pair? pair?)
          (rename ra:cons cons)
          (rename ra:car car)
          (rename ra:cdr cdr)
          (rename ra:caar caar)
          (rename ra:cadr cadr)
          (rename ra:cddr cddr)
          (rename ra:cdar cdar)
          (rename ra:caaar caaar)
          (rename ra:caadr caadr)
          (rename ra:caddr caddr)
          (rename ra:cadar cadar)
          (rename ra:cdaar cdaar)
          (rename ra:cdadr cdadr)
          (rename ra:cdddr cdddr)
          (rename ra:cddar cddar)
          (rename ra:caaaar caaaar)
          (rename ra:caaadr caaadr)
          (rename ra:caaddr caaddr)
          (rename ra:caadar caadar)
          (rename ra:cadaar cadaar)
          (rename ra:cadadr cadadr)
          (rename ra:cadddr cadddr)
          (rename ra:caddar caddar)
          (rename ra:cdaaar cdaaar)
          (rename ra:cdaadr cdaadr)
          (rename ra:cdaddr cdaddr)
          (rename ra:cdadar cdadar)
          (rename ra:cddaar cddaar)
          (rename ra:cddadr cddadr)
          (rename ra:cddddr cddddr)
          (rename ra:cdddar cdddar)
          (rename ra:null? null?)
          (rename ra:list? list?)
          (rename ra:list list)
          (rename ra:make-list make-list)
          (rename ra:length length)
          (rename ra:append append)
          (rename ra:reverse reverse)
          (rename ra:list-tail list-tail)
          (rename ra:list-ref list-ref)
          (rename ra:list-set list-set)
          (rename ra:list-ref/update list-ref/update)
          (rename ra:map map)
          (rename ra:for-each for-each)
          (rename ra:random-access-list->linear-access-list random-access-list->linear-access-list)
          (rename ra:linear-access-list->random-access-list linear-access-list->random-access-list))

  (import (lispkit base)
          (srfi 1)
          (except (srfi 125) string-hash string-ci-hash)
          (except (srfi 151) copy-bit bit-set?))

  (begin

    (define-record-type kons
      (make-kons size tree rest)
      kons?
      (size kons-size)
      (tree kons-tree)
      (rest kons-rest))

    (define-record-type node
      (make-node val left right)
      node?
      (val node-val)
      (left node-left)
      (right node-right))
    
    ;; Nat -> Nat
    (define (sub1 n) (- n 1))
    (define (add1 n) (+ n 1))

    ;; [Tree X] -> X
    (define (tree-val t)
      (if (node? t)
          (node-val t)
          t))

    ;; [X -> Y] [Tree X] -> [Tree Y]
    (define (tree-map f t)
      (if (node? t)
          (make-node (f (node-val t))
                     (tree-map f (node-left t))
                     (tree-map f (node-right t)))
          (f t)))

    ;; [X -> Y] [Tree X] -> unspecified
    (define (tree-for-each f t)
      (if (node? t)
          (begin (f (node-val t))
                 (tree-for-each f (node-left t))
                 (tree-for-each f (node-right t)))
          (f t)))

    ;; [X Y Z ... -> R] [List [Tree X] [Tree Y] [Tree Z] ...] -> [Tree R]
    (define (tree-map/n f ts)
      (let recr ((ts ts))
        (if (and (pair? ts)
                 (node? (car ts)))
            (make-node (apply f (map node-val ts))
                       (recr (map node-left ts))
                       (recr (map node-right ts)))
            (apply f ts))))

    ;; [X Y Z ... -> R] [List [Tree X] [Tree Y] [Tree Z] ...] -> unspecified
    (define (tree-for-each/n f ts)
      (let recr ((ts ts))
        (if (and (pair? ts)
                 (node? (car ts)))
            (begin (apply f (map node-val ts))
                   (recr (map node-left ts))
                   (recr (map node-right ts)))
            (apply f ts))))

    ;; Nat [Nat -> X] -> [Tree X]
    ;; like build-list, but for complete binary trees
    (define (build-tree i f) ;; i = 2^j-1
      (let rec ((i i) (o 0))
        (if (= 1 i)
            (f o)
            (let ((i/2 (half i)))
              (make-node (f o)
                         (rec i/2 (add1 o))
                         (rec i/2 (+ 1 o i/2)))))))

    ;; Consumes n = 2^i-1 and produces 2^(i-1)-1.
    ;; Nat -> Nat
    (define (half n)
      (arithmetic-shift n -1))

    ;; Nat X -> [Tree X]
    (define (tr:make-tree i x) ;; i = 2^j-1
      (let recr ((i i))
        (if (= 1 i)
            x
            (let ((n (recr (half i))))
              (make-node x n n)))))

    ;; Nat [Tree X] Nat [X -> X] -> X [Tree X]
    (define (tree-ref/update mid t i f)
      (cond ((zero? i)
             (if (node? t)
                 (values (node-val t)
                         (make-node (f (node-val t))
                                    (node-left t)
                                    (node-right t)))
                 (values t (f t))))
            ((<= i mid)
             (let-values (((v* t*) (tree-ref/update (half (sub1 mid))
                                                    (node-left t)
                                                    (sub1 i)
                                                    f)))
               (values v* (make-node (node-val t) t* (node-right t)))))
            (else
             (let-values (((v* t*) (tree-ref/update (half (sub1 mid))
                                                    (node-right t)
                                                    (sub1 (- i mid))
                                                    f)))
               (values v* (make-node (node-val t) (node-left t) t*))))))

    ;; Special-cased above to avoid logarathmic amount of cons'ing
    ;; and any multi-values overhead.  Operates in constant space.
    ;; [Tree X] Nat Nat -> X
    ;; invariant: (= mid (half (sub1 (tree-count t))))
    (define (tree-ref/a t i mid)
      (cond ((zero? i) (tree-val t))
            ((<= i mid)
             (tree-ref/a (node-left t)
                         (sub1 i)
                         (half (sub1 mid))))
            (else
             (tree-ref/a (node-right t)
                         (sub1 (- i mid))
                         (half (sub1 mid))))))

    ;; Nat [Tree X] Nat -> X
    ;; invariant: (= size (tree-count t))
    (define (tree-ref size t i)
      (if (zero? i)
          (tree-val t)
          (tree-ref/a t i (half (sub1 size)))))

    ;; Nat [Tree X] Nat [X -> X] -> [Tree X]
    (define (tree-update size t i f)
      (let recr ((mid (half (sub1 size))) (t t) (i i))
        (cond ((zero? i)
               (if (node? t)
                   (make-node (f (node-val t))
                              (node-left t)
                              (node-right t))
                   (f t)))
              ((<= i mid)
               (make-node (node-val t)
                          (recr (half (sub1 mid))
                                (node-left t)
                                (sub1 i))
                          (node-right t)))
              (else
               (make-node (node-val t)
                          (node-left t)
                          (recr (half (sub1 mid))
                                (node-right t)
                                (sub1 (- i mid))))))))

    ;; Random access lists

    ;; [RaListof X]
    (define ra:null (quote ()))

    ;; [Any -> Boolean]
    (define ra:pair? kons?)

    ;; [Any -> Boolean]
    (define ra:null? null?)

    ;; X [RaListof X] -> [RaListof X]  /\
    ;; X Y -> [RaPair X Y]
    (define (ra:cons x ls)
      (if (kons? ls)
          (let ((s (kons-size ls)))
            (if (and (kons? (kons-rest ls))
                     (= (kons-size (kons-rest ls))
                        s))
                (make-kons (+ 1 s s)
                           (make-node x
                                      (kons-tree ls)
                                      (kons-tree (kons-rest ls)))
                           (kons-rest (kons-rest ls)))
                (make-kons 1 x ls)))
          (make-kons 1 x ls)))


    ;; [RaPair X Y] -> X Y
    (define ra:car+cdr
      (lambda (p)
        (assert (kons? p))
        (if (node? (kons-tree p))
            (let ((s* (half (kons-size p))))
              (values (tree-val (kons-tree p))
                      (make-kons s*
                                 (node-left (kons-tree p))
                                 (make-kons s*
                                            (node-right (kons-tree p))
                                            (kons-rest p)))))
            (values (kons-tree p) (kons-rest p)))))

    ;; [RaPair X Y] -> X
    (define (ra:car p)
      (call-with-values (lambda () (ra:car+cdr p))
                        (lambda (car cdr) car)))

    ;; [RaPair X Y] -> Y
    (define (ra:cdr p)
      (call-with-values (lambda () (ra:car+cdr p))
                        (lambda (car cdr) cdr)))

    ;; [RaListof X] Nat [X -> X] -> X [RaListof X]
    (define (ra:list-ref/update ls i f)
      ;(assert (< i (ra:length ls)))
      (let recr ((xs ls) (j i))
        (if (< j (kons-size xs))
            (let-values (((v* t*)
                          (tree-ref/update (half (sub1 (kons-size xs)))
                                           (kons-tree xs) j f)))
              (values v* (make-kons (kons-size xs)
                                    t*
                                    (kons-rest xs))))
            (let-values (((v* r*)
                          (recr (kons-rest xs)
                                (- j (kons-size xs)))))
              (values v* (make-kons (kons-size xs)
                                    (kons-tree xs)
                                    r*))))))

    ;; [RaListof X] Nat [X -> X] -> [RaListof X]
    (define (ra:list-update ls i f)
      ;(assert (< i (ra:length ls)))
      (let recr ((xs ls) (j i))
        (let ((s (kons-size xs)))
          (if (< j s)
              (make-kons s (tree-update s (kons-tree xs) j f) (kons-rest xs))
              (make-kons s (kons-tree xs) (recr (kons-rest xs) (- j s)))))))

    ;; [RaListof X] Nat X -> (values X [RaListof X])
    (define (ra:list-ref/set ls i v)
      (ra:list-ref/update ls i (lambda (_) v)))

    ;; X ... -> [RaListof X]
    (define (ra:list . xs)
      (fold-right ra:cons ra:null xs))

    ;; Nat X -> [RaListof X]
    (define ra:make-list
      (case-lambda
       ((k) (ra:make-list k 0))
       ((k obj)
        (let loop ((n k) (a ra:null))
          (cond ((zero? n) a)
                (else
                 (let ((t (largest-skew-binary n)))
                   (loop (- n t)
                         (make-kons t (tr:make-tree t obj) a)))))))))

    ;; A Skew is a Nat 2^k-1 with k > 0.

    ;; Skew -> Skew
    (define (skew-succ t) (add1 (arithmetic-shift t 1)))

    ;; Computes the largest skew binary term t <= n.
    ;; Nat -> Skew
    (define (largest-skew-binary n)
      (if (= 1 n)
          1
          (let* ((t (largest-skew-binary (half n)))
                 (s (skew-succ t)))
            (if (> s n) t s))))

    ;; [Any -> Boolean]
    ;; Is x a PROPER list?
    (define (ra:list? x)
      (or (ra:null? x)
          (and (kons? x)
               (ra:list? (kons-rest x)))))

    (define ra:caar (lambda (ls) (ra:car (ra:car ls))))
    (define ra:cadr (lambda (ls) (ra:car (ra:cdr ls))))
    (define ra:cddr (lambda (ls) (ra:cdr (ra:cdr ls))))
    (define ra:cdar (lambda (ls) (ra:cdr (ra:car ls))))

    (define ra:caaar (lambda (ls) (ra:car (ra:car (ra:car ls)))))
    (define ra:caadr (lambda (ls) (ra:car (ra:car (ra:cdr ls)))))
    (define ra:caddr (lambda (ls) (ra:car (ra:cdr (ra:cdr ls)))))
    (define ra:cadar (lambda (ls) (ra:car (ra:cdr (ra:car ls)))))
    (define ra:cdaar (lambda (ls) (ra:cdr (ra:car (ra:car ls)))))
    (define ra:cdadr (lambda (ls) (ra:cdr (ra:car (ra:cdr ls)))))
    (define ra:cdddr (lambda (ls) (ra:cdr (ra:cdr (ra:cdr ls)))))
    (define ra:cddar (lambda (ls) (ra:cdr (ra:cdr (ra:car ls)))))

    (define ra:caaaar (lambda (ls) (ra:car (ra:car (ra:car (ra:car ls))))))
    (define ra:caaadr (lambda (ls) (ra:car (ra:car (ra:car (ra:cdr ls))))))
    (define ra:caaddr (lambda (ls) (ra:car (ra:car (ra:cdr (ra:cdr ls))))))
    (define ra:caadar (lambda (ls) (ra:car (ra:car (ra:cdr (ra:car ls))))))
    (define ra:cadaar (lambda (ls) (ra:car (ra:cdr (ra:car (ra:car ls))))))
    (define ra:cadadr (lambda (ls) (ra:car (ra:cdr (ra:car (ra:cdr ls))))))
    (define ra:cadddr (lambda (ls) (ra:car (ra:cdr (ra:cdr (ra:cdr ls))))))
    (define ra:caddar (lambda (ls) (ra:car (ra:cdr (ra:cdr (ra:car ls))))))
    (define ra:cdaaar (lambda (ls) (ra:cdr (ra:car (ra:car (ra:car ls))))))
    (define ra:cdaadr (lambda (ls) (ra:cdr (ra:car (ra:car (ra:cdr ls))))))
    (define ra:cdaddr (lambda (ls) (ra:cdr (ra:car (ra:cdr (ra:cdr ls))))))
    (define ra:cdadar (lambda (ls) (ra:cdr (ra:car (ra:cdr (ra:car ls))))))
    (define ra:cddaar (lambda (ls) (ra:cdr (ra:cdr (ra:car (ra:car ls))))))
    (define ra:cddadr (lambda (ls) (ra:cdr (ra:cdr (ra:car (ra:cdr ls))))))
    (define ra:cddddr (lambda (ls) (ra:cdr (ra:cdr (ra:cdr (ra:cdr ls))))))
    (define ra:cdddar (lambda (ls) (ra:cdr (ra:cdr (ra:cdr (ra:car ls))))))

    ;; [RaList X] -> Nat
    (define (ra:length ls)
      (assert (ra:list? ls))
      (let recr ((ls ls))
        (if (kons? ls)
            (+ (kons-size ls) (recr (kons-rest ls)))
            0)))

    (define (make-foldl empty? first rest)
      (letrec ((f (lambda (cons empty ls)
                    (if (empty? ls)
                        empty
                        (f cons
                           (cons (first ls) empty)
                           (rest ls))))))
        f))

    (define (make-foldr empty? first rest)
      (letrec ((f (lambda (cons empty ls)
                    (if (empty? ls)
                        empty
                        (cons (first ls)
                              (f cons empty (rest ls)))))))
        f))

    ;; [X Y -> Y] Y [RaListof X] -> Y
    (define ra:foldl/1 (make-foldl ra:null? ra:car ra:cdr))
    (define ra:foldr/1 (make-foldr ra:null? ra:car ra:cdr))

    ;; [RaListof X] ... -> [RaListof X]
    (define (ra:append . lss)
      (cond ((null? lss) ra:null)
            (else (let recr ((lss lss))
                    (cond ((null? (cdr lss)) (car lss))
                          (else (ra:foldr/1 ra:cons
                                            (recr (cdr lss))
                                            (car lss))))))))

    ;; [RaListof X] -> [RaListof X]
    (define (ra:reverse ls)
      (ra:foldl/1 ra:cons ra:null ls))

    ;; [RaListof X] Nat -> [RaListof X]
    (define (ra:list-tail ls i)
      (let loop ((xs ls) (j i))
        (cond ((zero? j) xs)
              (else (loop (ra:cdr xs) (sub1 j))))))

    ;; [RaListof X] Nat -> X
    ;; Special-cased above to avoid logarathmic amount of cons'ing
    ;; and any multi-values overhead.  Operates in constant space.
    (define (ra:list-ref ls i)
      ;(assert (< i (ra:length ls)))
      (let loop ((xs ls) (j i))
        (if (< j (kons-size xs))
            (tree-ref (kons-size xs) (kons-tree xs) j)
            (loop (kons-rest xs) (- j (kons-size xs))))))

    ;; [RaListof X] Nat X -> [RaListof X]
    (define (ra:list-set ls i v)
      (let-values (((_ l*) (ra:list-ref/set ls i v))) l*))

    ;; [X ... -> y] [RaListof X] ... -> [RaListof Y]
    ;; Takes advantage of the fact that map produces a list of equal size.
    (define ra:map
      (case-lambda
        ((f ls)
         (let recr ((ls ls))
           (if (kons? ls)
               (make-kons (kons-size ls)
                          (tree-map f (kons-tree ls))
                          (recr (kons-rest ls)))
               ra:null)))
        ((f . lss)
         ;(check-nary-loop-args 'ra:map (lambda (x) x) f lss)
         (let recr ((lss lss))
           (cond ((ra:null? (car lss)) ra:null)
                 (else
                  ;; IMPROVE ME: make one pass over lss.
                  (make-kons (kons-size (car lss))
                             (tree-map/n f (map kons-tree lss))
                             (recr (map kons-rest lss)))))))))


    ;; [X ... -> Y] [RaListof X] ... -> unspecified
    (define ra:for-each
      (case-lambda
        ((f ls)
         (when (kons? ls)
           (tree-for-each f (kons-tree ls))
           (ra:for-each f (kons-rest ls))))
        ((f . lss)
         ;(check-nary-loop-args 'ra:map (lambda (x) x) f lss)
         (let recr ((lss lss))
           (when (ra:pair? (car lss))
             (tree-map/n f (map kons-tree lss))
             (recr (map kons-rest lss)))))))

    ;; [RaListof X] -> [Listof X]
    (define (ra:random-access-list->linear-access-list x)
      (ra:foldr/1 cons '() x))

    ;; [Listof X] -> [RaListof X]
    (define (ra:linear-access-list->random-access-list x)
      (fold-right ra:cons '() x))

    ;; This code based on code written by Abdulaziz Ghuloum
    ;; http://ikarus-scheme.org/pipermail/ikarus-users/2009-September/000595.html
    (define get-cached
      (let ((h (make-hash-table eq?)))
        (lambda (x)
          (define (f x)
            (cond
             ((pair? x) (ra:cons (f (car x)) (f (cdr x))))
             ((vector? x) (vector-map f x))
             (else x)))
          (cond
           ((not (or (pair? x) (vector? x))) x)
           ((hash-table-ref/default h x #f))
           (else
            (let ((v (f x)))
              (hash-table-set! h x v)
              v))))))

    (define-syntax ra:quote
      (syntax-rules ()
        ((ra:quote datum) (get-cached 'datum))))
  )
)
;;; SRFI 102
;;; Procedure Arity Inspection
;;;
;;; This SRFI identifies a common, core set of operations that make it possible to
;;; inspect the arity of procedures and determine if a given procedure accepts a
;;; given number of arguments.
;;;
;;; Author of spec: David Van Horn
;;;
;;; Copyright © 2021 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 102)

  (export procedure-arity
          arity-at-least?
          arity-at-least-value
          procedure-arity-includes?)

  (import (lispkit core))
)
;;; SRFI 11
;;; Syntax for receiving multiple values
;;;
;;; The SRFI introduces syntactic forms `let-values` and `let*-values` that bind the values
;;; of expressions that return multiple values.
;;;
;;; Author of spec: Lars T Hansen
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 11)

  (export let-values
          let*-values)

  (import (lispkit control))

  ;; Both forms are implemented natively in library `(lispkit control)`
)
;;; SRFI 111
;;; Boxes
;;;
;;; Boxes are objects with a single mutable state. Several Schemes have them, sometimes
;;; called cells. A constructor, predicate, accessor, and mutator are provided.
;;;
;;; Copyright © 2013 John Cowan. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 111)
  (export box?
          box
          unbox
          set-box!)
  (import (lispkit base))
)
;;; SRFI 112
;;; Environment Inquiry
;;;
;;; This is a library supporting environment inquiry, providing human-readable information
;;; at run time about the hardware and software configuration on which a Scheme program is
;;; being executed. They are mostly based on Common Lisp, with additions from the Posix
;;; `uname()` system call.
;;;
;;; Copyright © 2013 John Cowan. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 112)
  (export implementation-name
          implementation-version
          cpu-architecture
          machine-name
          os-type
          os-version)
  (import (lispkit base))
)
;;; SRFI 113
;;; Sets and bags
;;;
;;; Sets and bags (also known as multisets) are unordered collections that can contain
;;; any Scheme object. Sets enforce the constraint that no two elements can be the same
;;; in the sense of the set's associated equality predicate; bags do not.
;;;
;;; Copyright © 2013 John Cowan. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 113)
 
  (export set
          set-unfold
          set?
          set-contains?
          set-empty?
          set-disjoint?
          set-member
          set-element-comparator
          set-adjoin
          set-adjoin!
          set-replace
          set-replace!
          set-delete
          set-delete!
          set-delete-all
          set-delete-all!
          set-search!
          set-size
          set-find
          set-count
          set-any?
          set-every?
          set-map
          set-for-each
          set-fold
          set-filter
          set-remove
          set-remove
          set-partition
          set-filter!
          set-remove!
          set-partition!
          set-copy
          set->list
          list->set
          list->set!
          set=?
          set<?
          set>?
          set<=?
          set>=?
          set-union
          set-intersection
          set-difference
          set-xor
          set-union!
          set-intersection!
          set-difference!
          set-xor!
          set-comparator)
 
  (export bag
          bag-unfold
          bag?
          bag-contains?
          bag-empty?
          bag-disjoint?
          bag-member
          bag-element-comparator
          bag-adjoin
          bag-adjoin!
          bag-replace
          bag-replace!
          bag-delete
          bag-delete!
          bag-delete-all
          bag-delete-all!
          bag-search!
          bag-size
          bag-find
          bag-count
          bag-any?
          bag-every?
          bag-map
          bag-for-each
          bag-fold
          bag-filter
          bag-remove
          bag-partition
          bag-filter!
          bag-remove!
          bag-partition!
          bag-copy
          bag->list
          list->bag
          list->bag!
          bag=?
          bag<?
          bag>?
          bag<=?
          bag>=?
          bag-union
          bag-intersection
          bag-difference
          bag-xor
          bag-union!
          bag-intersection!
          bag-difference!
          bag-xor!
          bag-comparator
          bag-sum
          bag-sum!
          bag-product
          bag-product!
          bag-unique-size
          bag-element-count
          bag-for-each-unique
          bag-fold-unique
          bag-increment!
          bag-decrement!
          bag->set
          set->bag
          set->bag!
          bag->alist
          alist->bag)

  (import (lispkit base)
          (except (srfi 69) string-hash string-ci-hash symbol-hash)
          (srfi 128))
 
  ;;; Implementation of general sets and bags for SRFI 113
  ;;;
  ;;; A "sob" object is the representation of both sets and bags.
  ;;; This allows each set-* and bag-* procedure to be implemented
  ;;; using the same code, without having to deal in ugly indirections
  ;;; over the field accessors.  There are three fields, "sob-multi?",
  ;;; "sob-hash-table", and "sob-comparator."
  ;;;
  ;;; The value of "sob-multi?" is #t for bags and #f for sets.
  ;;; "Sob-hash-table" maps the elements of the sob to the number of times
  ;;; the element appears, which is always 1 for a set, any positive value
  ;;; for a bag.  "Sob-comparator" is the comparator for the elements of
  ;;; the set.
  ;;;
  ;;; Note that sob-* procedures do not do type checking or (typically) the
  ;;; copying required for supporting pure functional update.  These things
  ;;; are done by the set-* and bag-* procedures, which are externally
  ;;; exposed (but trivial and mostly uncommented below).
 
  (begin
 
    ;;; Shim to convert from SRFI 69 to the future "intermediate hash tables"
    ;;; SRFI.  Unfortunately, hash-table-fold is incompatible between the two
    ;;; and so is not usable.
 
    ;; This will be just "make-hash-table" in future.
 
    (define (make-hash-table/comparator comparator)
      (make-hash-table (comparator-equality-predicate comparator)
                       (modulizer (comparator-hash-function comparator))))
 
    ;; These two procedures adjust for the mismatch between the hash functions
    ;; of SRFI 114, which return a potentially unbounded non-negative integer,
    ;; and the hash functions of SRFI 69, which expect to be able to pass
    ;; a second argument which is an upper bound.
 
    (define (modulizer hash-function)
      (case-lambda
        ((obj) (hash-function obj))
        ((obj limit) (modulo (hash-function obj) limit))))
 
    ;; Simple renaming.  Chicken's implementation of SRFI 69 provides
    ;; hash-table-for-each as a non-standard extension, with the opposite
    ;; order, so in the Chicken module we suppress importing it to muffle
    ;; the conflict warning.
 
    (define hash-table-contains? hash-table-exists?)
 
    (define (hash-table-for-each proc hash-table)
      (hash-table-walk hash-table proc))
 
    ;;; Record definition and core typing/checking procedures
 
    (define-record-type sob
      (raw-make-sob hash-table comparator multi?)
      sob?
      (hash-table sob-hash-table)
      (comparator sob-comparator)
      (multi? sob-multi?))
 
    (define (set? obj)
      (and (sob? obj) (not (sob-multi? obj))))
 
    (define (bag? obj)
      (and (sob? obj) (sob-multi? obj)))
 
    (define (check-set obj)
      (if (not (set? obj)) (error "not a set" obj)))
 
    (define (check-bag obj)
      (if (not (bag? obj)) (error "not a bag" obj)))
 
    ;; These procedures verify that not only are their arguments all sets
    ;; or all bags as the case may be, but also share the same comparator.
 
    (define (check-all-sets list)
      (for-each (lambda (obj) (check-set obj)) list)
      (sob-check-comparators list))
 
    (define (check-all-bags list)
      (for-each (lambda (obj) (check-bag obj)) list)
      (sob-check-comparators list))
 
    (define (sob-check-comparators list)
      (if (not (null? list))
          (for-each
            (lambda (sob)
              (check-same-comparator (car list) sob))
            (cdr list))))
 
    ;; This procedure is used directly when there are exactly two arguments.
 
    (define (check-same-comparator a b)
      (if (not (eq? (sob-comparator a) (sob-comparator b)))
        (error "different comparators" a b)))
 
    ;; This procedure defends against inserting an element
    ;; into a sob that violates its constructor, since
    ;; typical hash-table implementations don't check for us.
 
    (define (check-element sob element)
      (comparator-check-type (sob-comparator sob) element))
 
    ;;; Constructors
 
    ;; Construct an arbitrary empty sob out of nothing.
 
    (define (make-sob comparator multi?)
      (raw-make-sob (make-hash-table/comparator comparator) comparator multi?))
 
    ;; Copy a sob, sharing the constructor.
 
    (define (sob-copy sob)
      (raw-make-sob (hash-table-copy (sob-hash-table sob))
                (sob-comparator sob)
                (sob-multi? sob)))
 
    (define (set-copy set)
      (check-set set)
      (sob-copy set))
 
    (define (bag-copy bag)
      (check-bag bag)
      (sob-copy bag))
 
    ;; Construct an empty sob that shares the constructor of an existing sob.
 
    (define (sob-empty-copy sob)
      (make-sob (sob-comparator sob) (sob-multi? sob)))
 
    ;; Construct a set or a bag and insert elements into it.  These are the
    ;; simplest external constructors.
 
    (define (set comparator . elements)
      (let ((result (make-sob comparator #f)))
        (for-each (lambda (x) (sob-increment! result x 1)) elements)
        result))
 
    (define (bag comparator . elements)
      (let ((result (make-sob comparator #t)))
        (for-each (lambda (x) (sob-increment! result x 1)) elements)
        result))
 
    ;; The fundamental (as opposed to simplest) constructor: unfold the
    ;; results of iterating a function as a set.  In line with SRFI 1,
    ;; we provide an opportunity to map the sequence of seeds through a
    ;; mapper function.
 
    (define (sob-unfold stop? mapper successor seed comparator multi?)
      (let ((result (make-sob comparator multi?)))
        (let loop ((seed seed))
          (if (stop? seed)
              result
              (begin
                (sob-increment! result (mapper seed) 1)
                (loop (successor seed)))))))
 
    (define (set-unfold continue? mapper successor seed comparator)
      (sob-unfold continue? mapper successor seed comparator #f))
 
    (define (bag-unfold continue? mapper successor seed comparator)
      (sob-unfold continue? mapper successor seed comparator #t))
 
    ;;; Predicates
 
    ;; Just a wrapper of hash-table-contains?.
 
    (define (sob-contains? sob member)
      (hash-table-contains? (sob-hash-table sob) member))
 
    (define (set-contains? set member)
      (check-set set)
      (sob-contains? set member))
 
    (define (bag-contains? bag member)
      (check-bag bag)
      (sob-contains? bag member))
 
    ;; A sob is empty if its size is 0.
 
    (define (sob-empty? sob)
      (= 0 (hash-table-size (sob-hash-table sob))))
 
    (define (set-empty? set)
      (check-set set)
      (sob-empty? set))
 
    (define (bag-empty? bag)
      (check-bag bag)
      (sob-empty? bag))
 
    ;; Two sobs are disjoint if, when looping through one, we can't find
    ;; any of its elements in the other.  We have to try both ways:
    ;; sob-half-disjoint checks just one direction for simplicity.
 
    (define (sob-half-disjoint? a b)
      (let ((ha (sob-hash-table a))
            (hb (sob-hash-table b)))
        (call/cc
          (lambda (return)
            (hash-table-for-each
              (lambda (key val) (if (hash-table-contains? hb key) (return #f)))
              ha)
          #t))))
 
    (define (set-disjoint? a b)
      (check-set a)
      (check-set b)
      (check-same-comparator a b)
      (and (sob-half-disjoint? a b) (sob-half-disjoint? b a)))
 
    (define (bag-disjoint? a b)
      (check-bag a)
      (check-bag b)
      (check-same-comparator a b)
      (and (sob-half-disjoint? a b) (sob-half-disjoint? b a)))
 
    ;; Accessors
 
    ;; If two objects are indistinguishable by the comparator's
    ;; equality procedure, only one of them will be represented in the sob.
    ;; This procedure lets us find out which one it is; it will return
    ;; the value stored in the sob that is equal to the element.
    ;; Note that we have to search the whole hash table item by item.
    ;; The default is returned if there is no such element.
 
    (define (sob-member sob element default)
      (define (same? a b) (=? (sob-comparator sob) a b))
      (call/cc
        (lambda (return)
          (hash-table-for-each
            (lambda (key val) (if (same? key element) (return key)))
            (sob-hash-table sob))
          default)))
 
    (define (set-member set element default)
      (check-set set)
      (sob-member set element default))
 
    (define (bag-member bag element default)
      (check-bag bag)
      (sob-member bag element default))
 
    ;; Retrieve the comparator.
 
    (define (set-element-comparator set)
      (check-set set)
      (sob-comparator set))
 
    (define (bag-element-comparator bag)
      (check-bag bag)
      (sob-comparator bag))
 
 
    ;; Updaters (pure functional and linear update)
 
    ;; The primitive operation for adding an element to a sob.
    ;; There are a few cases where we bypass this for efficiency.
 
    (define (sob-increment! sob element count)
      (check-element sob element)
      (hash-table-update!/default
        (sob-hash-table sob)
        element
        (if (sob-multi? sob)
          (lambda (value) (+ value count))
          (lambda (value) 1))
        0))
 
    ;; The primitive operation for removing an element from a sob.  Note this
    ;; procedure is incomplete: it allows the count of an element to drop below 1.
    ;; Therefore, whenever it is used it is necessary to call sob-cleanup!
    ;; to fix things up.  This is done because it is unsafe to remove an
    ;; object from a hash table while iterating through it.
 
    (define (sob-decrement! sob element count)
      (hash-table-update!/default
        (sob-hash-table sob)
        element
        (lambda (value) (- value count))
        0))
 
    ;; This is the cleanup procedure, which happens in two passes: it
    ;; iterates through the sob, deciding which elements to remove (those
    ;; with non-positive counts), and collecting them in a list.  When the
    ;; iteration is done, it is safe to remove the elements using the list,
    ;; because we are no longer iterating over the hash table.  It returns
    ;; its argument, because it is often tail-called at the end of some
    ;; procedure that wants to return the clean sob.
 
    (define (sob-cleanup! sob)
      (let ((ht (sob-hash-table sob)))
        (for-each (lambda (key) (hash-table-delete! ht key))
                  (nonpositive-keys ht))
        sob))
 
    (define (nonpositive-keys ht)
      (let ((result '()))
        (hash-table-for-each
          (lambda (key value)
            (when (<= value 0)
              (set! result (cons key result))))
          ht)
        result))
 
    ;; We expose these for bags but not sets.
 
    (define (bag-increment! bag element count)
      (check-bag bag)
      (sob-increment! bag element count)
      bag)
 
    (define (bag-decrement! bag element count)
      (check-bag bag)
      (sob-decrement! bag element count)
      (sob-cleanup! bag)
      bag)
 
    ;; The primitive operation to add elements from a list.  We expose
    ;; this two ways: with a list argument and with multiple arguments.
 
    (define (sob-adjoin-all! sob elements)
      (for-each
        (lambda (elem)
          (sob-increment! sob elem 1))
        elements))
 
    (define (set-adjoin! set . elements)
      (check-set set)
      (sob-adjoin-all! set elements)
      set)
 
    (define (bag-adjoin! bag . elements)
      (check-bag bag)
      (sob-adjoin-all! bag elements)
      bag)
 
 
    ;; These versions copy the set or bag before adjoining.
 
    (define (set-adjoin set . elements)
      (check-set set)
      (let ((result (sob-copy set)))
        (sob-adjoin-all! result elements)
        result))
 
    (define (bag-adjoin bag . elements)
      (check-bag bag)
      (let ((result (sob-copy bag)))
        (sob-adjoin-all! result elements)
        result))
 
    ;; Given an element which resides in a set, this makes sure that the
    ;; specified element is represented by the form given.  Thus if a
    ;; sob contains 2 and the equality predicate is =, then calling
    ;; (sob-replace! sob 2.0) will replace the 2 with 2.0.  Does nothing
    ;; if there is no such element in the sob.
 
    (define (sob-replace! sob element)
      (let* ((comparator (sob-comparator sob))
             (= (comparator-equality-predicate comparator))
             (ht (sob-hash-table sob)))
        (comparator-check-type comparator element)
        (call/cc
          (lambda (return)
            (hash-table-for-each
              (lambda (key value)
                (when (= key element)
                  (hash-table-delete! ht key)
                  (hash-table-set! ht element value)
                  (return sob)))
              ht)
            sob))))
 
    (define (set-replace! set element)
      (check-set set)
      (sob-replace! set element)
      set)
 
    (define (bag-replace! bag element)
      (check-bag bag)
      (sob-replace! bag element)
      bag)
 
    ;; Non-destructive versions that copy the set first.  Yes, a little
    ;; bit inefficient because it copies the element to be replaced before
    ;; actually replacing it.
 
    (define (set-replace set element)
      (check-set set)
      (let ((result (sob-copy set)))
        (sob-replace! result element)
        result))
 
    (define (bag-replace bag element)
      (check-bag bag)
      (let ((result (sob-copy bag)))
        (sob-replace! result element)
        result))
 
    ;; The primitive operation to delete elemnets from a list.
    ;; Like sob-adjoin-all!, this is exposed two ways.  It calls
    ;; sob-cleanup! itself, so its callers don't need to (though it is safe
    ;; to do so.)
 
    (define (sob-delete-all! sob elements)
      (for-each (lambda (element) (sob-decrement! sob element 1)) elements)
      (sob-cleanup! sob)
      sob)
 
    (define (set-delete! set . elements)
      (check-set set)
      (sob-delete-all! set elements))
 
    (define (bag-delete! bag . elements)
      (check-bag bag)
      (sob-delete-all! bag elements))
 
    (define (set-delete-all! set elements)
      (check-set set)
      (sob-delete-all! set elements))
 
    (define (bag-delete-all! bag elements)
      (check-bag bag)
      (sob-delete-all! bag elements))
 
    ;; Non-destructive version copy first; this is inefficient.
 
    (define (set-delete set . elements)
      (check-set set)
      (sob-delete-all! (sob-copy set) elements))
 
    (define (bag-delete bag . elements)
      (check-bag bag)
      (sob-delete-all! (sob-copy bag) elements))
 
    (define (set-delete-all set elements)
      (check-set set)
      (sob-delete-all! (sob-copy set) elements))
 
    (define (bag-delete-all bag elements)
      (check-bag bag)
      (sob-delete-all! (sob-copy bag) elements))
 
    ;; Flag used by sob-search! to represent a missing object.
 
    (define missing (string-copy "missing"))
 
    ;; Searches and then dispatches to user-defined procedures on failure
    ;; and success, which in turn should reinvoke a procedure to take some
    ;; action on the set (insert, ignore, replace, or remove).
 
    (define (sob-search! sob element failure success)
      (define (insert obj)
        (sob-increment! sob element 1)
        (values sob obj))
      (define (ignore obj)
        (values sob obj))
      (define (update new-elem obj)
        (sob-decrement! sob element 1)
        (sob-increment! sob new-elem 1)
        (values (sob-cleanup! sob) obj))
      (define (remove obj)
        (sob-decrement! sob element 1)
        (values (sob-cleanup! sob) obj))
      (let ((true-element (sob-member sob element missing)))
        (if (eq? true-element missing)
          (failure insert ignore)
          (success true-element update remove))))
 
    (define (set-search! set element failure success)
      (check-set set)
      (sob-search! set element failure success))
 
    (define (bag-search! bag element failure success)
      (check-bag bag)
      (sob-search! bag element failure success))
 
    ;; Return the size of a sob.  If it's a set, we can just use the
    ;; number of associations in the hash table, but if it's a bag, we
    ;; have to add up the counts.
 
    (define (sob-size sob)
      (if (sob-multi? sob)
        (let ((result 0))
          (hash-table-for-each
            (lambda (elem count) (set! result (+ count result)))
            (sob-hash-table sob))
          result)
        (hash-table-size (sob-hash-table sob))))
 
    (define (set-size set)
      (check-set set)
      (sob-size set))
 
    (define (bag-size bag)
      (check-bag bag)
      (sob-size bag))
 
    ;; Search a sob to find something that matches a predicate.  You don't
    ;; know which element you will get, so this is not as useful as finding
    ;; an element in a list or other ordered container.  If it's not there,
    ;; call the failure thunk.
 
    (define (sob-find pred sob failure)
      (call/cc
        (lambda (return)
          (hash-table-for-each
            (lambda (key value)
              (if (pred key) (return key)))
            (sob-hash-table sob))
        (failure))))
 
    (define (set-find pred set failure)
      (check-set set)
      (sob-find pred set failure))
 
    (define (bag-find pred bag failure)
      (check-bag bag)
      (sob-find pred bag failure))
 
    ;; Count the number of elements in the sob that satisfy the predicate.
    ;; This is a special case of folding.
 
    (define (sob-count pred sob)
      (sob-fold
        (lambda (elem total) (if (pred elem) (+ total 1) total))
        0
        sob))
 
    (define (set-count pred set)
      (check-set set)
      (sob-count pred set))
 
    (define (bag-count pred bag)
      (check-bag bag)
      (sob-count pred bag))
 
    ;; Check if any of the elements in a sob satisfy a predicate.  Breaks out
    ;; early (with call/cc) if a success is found.
 
    (define (sob-any? pred sob)
      (call/cc
        (lambda (return)
          (hash-table-for-each
            (lambda (elem value) (if (pred elem) (return #t)))
            (sob-hash-table sob))
          #f)))
 
    (define (set-any? pred set)
      (check-set set)
      (sob-any? pred set))
 
    (define (bag-any? pred bag)
      (check-bag bag)
      (sob-any? pred bag))
 
    ;; Analogous to set-any?.  Breaks out early if a failure is found.
 
    (define (sob-every? pred sob)
      (call/cc
        (lambda (return)
          (hash-table-for-each
            (lambda (elem value) (if (not (pred elem)) (return #f)))
            (sob-hash-table sob))
          #t)))
 
    (define (set-every? pred set)
      (check-set set)
      (sob-every? pred set))
 
    (define (bag-every? pred bag)
      (check-bag bag)
      (sob-every? pred bag))
 
 
    ;;; Mapping and folding
 
    ;; A utility for iterating a command n times.  This is used by sob-for-each
    ;; to execute a procedure over the repeated elements in a bag.  Because
    ;; of the representation of sets, it works for them too.
 
    (define (do-n-times cmd n)
      (let loop ((n n))
        (when (> n 0)
          (cmd)
          (loop (- n 1)))))
 
    ;; Basic iterator over a sob.
 
    (define (sob-for-each proc sob)
      (hash-table-for-each
        (lambda (key value) (do-n-times (lambda () (proc key)) value))
        (sob-hash-table sob)))
 
    (define (set-for-each proc set)
      (check-set set)
      (sob-for-each proc set))
 
    (define (bag-for-each proc bag)
      (check-bag bag)
      (sob-for-each proc bag))
 
    ;; Fundamental mapping operator.  We map over the associations directly,
    ;; because each instance of an element in a bag will be treated identically
    ;; anyway; we insert them all at once with sob-increment!.
 
    (define (sob-map comparator proc sob)
      (let ((result (make-sob comparator (sob-multi? sob))))
        (hash-table-for-each
          (lambda (key value) (sob-increment! result (proc key) value))
          (sob-hash-table sob))
        result))
 
    (define (set-map comparator proc set)
      (check-set set)
      (sob-map comparator proc set))
 
    (define (bag-map comparator proc bag)
      (check-bag bag)
      (sob-map comparator proc bag))
 
    ;; The fundamental deconstructor.  Note that there are no left vs. right
    ;; folds because there is no order.  Each element in a bag is fed into
    ;; the fold separately.
 
    (define (sob-fold proc nil sob)
      (let ((result nil))
        (sob-for-each
          (lambda (elem) (set! result (proc elem result)))
          sob)
        result))
 
    (define (set-fold proc nil set)
      (check-set set)
      (sob-fold proc nil set))
 
    (define (bag-fold proc nil bag)
      (check-bag bag)
      (sob-fold proc nil bag))
 
    ;; Process every element and copy the ones that satisfy the predicate.
    ;; Identical elements are processed all at once.  This is used for both
    ;; filter and remove.
 
    (define (sob-filter pred sob)
      (let ((result (sob-empty-copy sob)))
        (hash-table-for-each
          (lambda (key value)
            (if (pred key) (sob-increment! result key value)))
          (sob-hash-table sob))
        result))
 
    (define (set-filter pred set)
      (check-set set)
      (sob-filter pred set))
 
    (define (bag-filter pred bag)
      (check-bag bag)
      (sob-filter pred bag))
 
    (define (set-remove pred set)
      (check-set set)
      (sob-filter (lambda (x) (not (pred x))) set))
 
    (define (bag-remove pred bag)
      (check-bag bag)
      (sob-filter (lambda (x) (not (pred x))) bag))
 
    ;; Process each element and remove those that don't satisfy the filter.
    ;; This does its own cleanup, and is used for both filter! and remove!.
 
    (define (sob-filter! pred sob)
      (hash-table-for-each
        (lambda (key value)
          (if (not (pred key)) (sob-decrement! sob key value)))
        (sob-hash-table sob))
      (sob-cleanup! sob))
 
    (define (set-filter! pred set)
      (check-set set)
      (sob-filter! pred set))
 
    (define (bag-filter! pred bag)
      (check-bag bag)
      (sob-filter! pred bag))
 
    (define (set-remove! pred set)
      (check-set set)
      (sob-filter! (lambda (x) (not (pred x))) set))
 
    (define (bag-remove! pred bag)
      (check-bag bag)
      (sob-filter! (lambda (x) (not (pred x))) bag))
 
    ;; Create two sobs and copy the elements that satisfy the predicate into
    ;; one of them, all others into the other.  This is more efficient than
    ;; filtering and removing separately.
 
    (define (sob-partition pred sob)
      (let ((res1 (sob-empty-copy sob))
            (res2 (sob-empty-copy sob)))
        (hash-table-for-each
          (lambda (key value)
            (if (pred key)
              (sob-increment! res1 key value)
              (sob-increment! res2 key value)))
          (sob-hash-table sob))
        (values res1 res2)))
 
    (define (set-partition pred set)
      (check-set set)
      (sob-partition pred set))
 
    (define (bag-partition pred bag)
      (check-bag bag)
      (sob-partition pred bag))
 
    ;; Create a sob and iterate through the given sob.  Anything that satisfies
    ;; the predicate is left alone; anything that doesn't is removed from the
    ;; given sob and added to the new sob.
 
    (define (sob-partition! pred sob)
      (let ((result (sob-empty-copy sob)))
        (hash-table-for-each
          (lambda (key value)
            (if (not (pred key))
              (begin
                (sob-decrement! sob key value)
                (sob-increment! result key value))))
          (sob-hash-table sob))
        (values (sob-cleanup! sob) result)))
 
    (define (set-partition! pred set)
      (check-set set)
      (sob-partition! pred set))
 
    (define (bag-partition! pred bag)
      (check-bag bag)
      (sob-partition! pred bag))
 
 
    ;;; Copying and conversion
 
    ;;; Convert a sob to a list; a special case of sob-fold.
 
    (define (sob->list sob)
      (sob-fold (lambda (elem list) (cons elem list)) '() sob))
 
    (define (set->list set)
      (check-set set)
      (sob->list set))
 
    (define (bag->list bag)
      (check-bag bag)
      (sob->list bag))
 
    ;; Convert a list to a sob.  Probably could be done using unfold, but
    ;; since sobs are mutable anyway, it's just as easy to add the elements
    ;; by side effect.
 
    (define (list->sob! sob list)
      (for-each (lambda (elem) (sob-increment! sob elem 1)) list)
      sob)
 
    (define (list->set comparator list)
      (list->sob! (make-sob comparator #f) list))
 
    (define (list->bag comparator list)
      (list->sob! (make-sob comparator #t) list))
 
    (define (list->set! set list)
      (check-set set)
      (list->sob! set list))
 
    (define (list->bag! bag list)
      (check-bag bag)
      (list->sob! bag list))
 
 
    ;;; Subsets
 
    ;; All of these procedures follow the same pattern.  The
    ;; sob<op>? procedures are case-lambdas that reduce the multi-argument
    ;; case to the two-argument case.  As usual, the set<op>? and
    ;; bag<op>? procedures are trivial layers over the sob<op>? procedure.
    ;; The dyadic-sob<op>? procedures are where it gets interesting, so see
    ;; the comments on them.
 
    (define sob=?
      (case-lambda
        ((sob) #t)
        ((sob1 sob2) (dyadic-sob=? sob1 sob2))
        ((sob1 sob2 . sobs)
         (and (dyadic-sob=? sob1 sob2)
              (apply sob=? sob2 sobs)))))
 
    (define (set=? . sets)
      (check-all-sets sets)
      (apply sob=? sets))
 
    (define (bag=? . bags)
      (check-all-bags bags)
      (apply sob=? bags))
 
    ;; First we check that there are the same number of entries in the
    ;; hashtables of the two sobs; if that's not true, they can't be equal.
    ;; Then we check that for each key, the values are the same (where
    ;; being absent counts as a value of 0).  If any values aren't equal,
    ;; again they can't be equal.
 
    (define (dyadic-sob=? sob1 sob2)
      (call/cc
        (lambda (return)
          (let ((ht1 (sob-hash-table sob1))
                (ht2 (sob-hash-table sob2)))
            (if (not (= (hash-table-size ht1) (hash-table-size ht2)))
              (return #f))
            (hash-table-for-each
              (lambda (key value)
                (if (not (= value (hash-table-ref/default ht2 key 0)))
                  (return #f)))
              ht1))
         #t)))
 
    (define sob<=?
      (case-lambda
        ((sob) #t)
        ((sob1 sob2) (dyadic-sob<=? sob1 sob2))
        ((sob1 sob2 . sobs)
         (and (dyadic-sob<=? sob1 sob2)
              (apply sob<=? sob2 sobs)))))
 
    (define (set<=? . sets)
      (check-all-sets sets)
      (apply sob<=? sets))
 
    (define (bag<=? . bags)
      (check-all-bags bags)
      (apply sob<=? bags))
 
    ;; This is analogous to dyadic-sob=?, except that we have to check
    ;; both sobs to make sure each value is <= in order to be sure
    ;; that we've traversed all the elements in either sob.
 
    (define (dyadic-sob<=? sob1 sob2)
      (call/cc
        (lambda (return)
          (let ((ht1 (sob-hash-table sob1))
                (ht2 (sob-hash-table sob2)))
            (if (not (<= (hash-table-size ht1) (hash-table-size ht2)))
              (return #f))
            (hash-table-for-each
              (lambda (key value)
                (if (not (<= value (hash-table-ref/default ht2 key 0)))
                  (return #f)))
              ht1))
          #t)))
 
    (define sob>?
      (case-lambda
        ((sob) #t)
        ((sob1 sob2) (dyadic-sob>? sob1 sob2))
        ((sob1 sob2 . sobs)
         (and (dyadic-sob>? sob1 sob2)
              (apply sob>? sob2 sobs)))))
 
    (define (set>? . sets)
      (check-all-sets sets)
      (apply sob>? sets))
 
    (define (bag>? . bags)
      (check-all-bags bags)
      (apply sob>? bags))
 
    ;; > is the negation of <=.  Note that this is only true at the dyadic
    ;; level; we can't just replace sob>? with a negation of sob<=?.
 
    (define (dyadic-sob>? sob1 sob2)
      (not (dyadic-sob<=? sob1 sob2)))
 
    (define sob<?
      (case-lambda
        ((sob) #t)
        ((sob1 sob2) (dyadic-sob<? sob1 sob2))
        ((sob1 sob2 . sobs)
         (and (dyadic-sob<? sob1 sob2)
              (apply sob<? sob2 sobs)))))
 
    (define (set<? . sets)
      (check-all-sets sets)
      (apply sob<? sets))
 
    (define (bag<? . bags)
      (check-all-bags bags)
      (apply sob<? bags))
 
    ;; < is the inverse of >.  Again, this is only true dyadically.
 
    (define (dyadic-sob<? sob1 sob2)
      (dyadic-sob>? sob2 sob1))
 
    (define sob>=?
      (case-lambda
        ((sob) #t)
        ((sob1 sob2) (dyadic-sob>=? sob1 sob2))
        ((sob1 sob2 . sobs)
         (and (dyadic-sob>=? sob1 sob2)
              (apply sob>=? sob2 sobs)))))
 
    (define (set>=? . sets)
      (check-all-sets sets)
      (apply sob>=? sets))
 
    (define (bag>=? . bags)
      (check-all-bags bags)
      (apply sob>=? bags))
 
    ;; Finally, >= is the negation of <.  Good thing we have tail recursion.
 
    (define (dyadic-sob>=? sob1 sob2)
      (not (dyadic-sob<? sob1 sob2)))
 
 
    ;;; Set theory operations
 
    ;; A trivial helper function which upper-bounds n by one if multi? is false.
 
    (define (max-one n multi?)
        (if multi? n (if (> n 1) 1 n)))
 
    ;; The logic of union, intersection, difference, and sum is the same: the
    ;; sob-* and sob-*! procedures do the reduction to the dyadic-sob-*!
    ;; procedures.  The difference is that the sob-* procedures allocate
    ;; an empty copy of the first sob to accumulate the results in, whereas
    ;; the sob-*!  procedures work directly in the first sob.
 
    ;; Note that there is no set-sum, as it is the same as set-union.
 
    (define (sob-union sob1 . sobs)
      (if (null? sobs)
        sob1
        (let ((result (sob-empty-copy sob1)))
          (dyadic-sob-union! result sob1 (car sobs))
          (for-each
           (lambda (sob) (dyadic-sob-union! result result sob))
           (cdr sobs))
          result)))
 
    ;; For union, we take the max of the counts of each element found
    ;; in either sob and put that in the result.  On the pass through
    ;; sob2, we know that the intersection is already accounted for,
    ;; so we just copy over things that aren't in sob1.
 
    (define (dyadic-sob-union! result sob1 sob2)
      (let ((sob1-ht (sob-hash-table sob1))
            (sob2-ht (sob-hash-table sob2))
            (result-ht (sob-hash-table result)))
        (hash-table-for-each
          (lambda (key value1)
            (let ((value2 (hash-table-ref/default sob2-ht key 0)))
              (hash-table-set! result-ht key (max value1 value2))))
          sob1-ht)
        (hash-table-for-each
          (lambda (key value2)
            (let ((value1 (hash-table-ref/default sob1-ht key 0)))
              (if (= value1 0)
                  (hash-table-set! result-ht key value2))))
          sob2-ht)))
 
    (define (set-union . sets)
      (check-all-sets sets)
      (apply sob-union sets))
 
    (define (bag-union . bags)
      (check-all-bags bags)
      (apply sob-union bags))
 
    (define (sob-union! sob1 . sobs)
      (for-each
       (lambda (sob) (dyadic-sob-union! sob1 sob1 sob))
       sobs)
      sob1)
 
    (define (set-union! . sets)
      (check-all-sets sets)
      (apply sob-union! sets))
 
    (define (bag-union! . bags)
      (check-all-bags bags)
      (apply sob-union! bags))
 
    (define (sob-intersection sob1 . sobs)
      (if (null? sobs)
        sob1
        (let ((result (sob-empty-copy sob1)))
          (dyadic-sob-intersection! result sob1 (car sobs))
          (for-each
           (lambda (sob) (dyadic-sob-intersection! result result sob))
           (cdr sobs))
          (sob-cleanup! result))))
 
    ;; For intersection, we compute the min of the counts of each element.
    ;; We only have to scan sob1.  We clean up the result when we are
    ;; done, in case it is the same as sob1.
 
    (define (dyadic-sob-intersection! result sob1 sob2)
      (let ((sob1-ht (sob-hash-table sob1))
            (sob2-ht (sob-hash-table sob2))
            (result-ht (sob-hash-table result)))
        (hash-table-for-each
          (lambda (key value1)
            (let ((value2 (hash-table-ref/default sob2-ht key 0)))
              (hash-table-set! result-ht key (min value1 value2))))
          sob1-ht)))
 
    (define (set-intersection . sets)
      (check-all-sets sets)
      (apply sob-intersection sets))
 
    (define (bag-intersection . bags)
      (check-all-bags bags)
      (apply sob-intersection bags))
 
    (define (sob-intersection! sob1 . sobs)
      (for-each
       (lambda (sob) (dyadic-sob-intersection! sob1 sob1 sob))
       sobs)
      (sob-cleanup! sob1))
 
    (define (set-intersection! . sets)
      (check-all-sets sets)
      (apply sob-intersection! sets))
 
    (define (bag-intersection! . bags)
      (check-all-bags bags)
      (apply sob-intersection! bags))
 
    (define (sob-difference sob1 . sobs)
      (if (null? sobs)
        sob1
        (let ((result (sob-empty-copy sob1)))
          (dyadic-sob-difference! result sob1 (car sobs))
          (for-each
           (lambda (sob) (dyadic-sob-difference! result result sob))
           (cdr sobs))
          (sob-cleanup! result))))
 
    ;; For difference, we use (big surprise) the numeric difference, bounded
    ;; by zero.  We only need to scan sob1, but we clean up the result in
    ;; case it is the same as sob1.
 
    (define (dyadic-sob-difference! result sob1 sob2)
      (let ((sob1-ht (sob-hash-table sob1))
            (sob2-ht (sob-hash-table sob2))
            (result-ht (sob-hash-table result)))
        (hash-table-for-each
          (lambda (key value1)
            (let ((value2 (hash-table-ref/default sob2-ht key 0)))
              (hash-table-set! result-ht key (- value1 value2))))
          sob1-ht)))
 
    (define (set-difference . sets)
      (check-all-sets sets)
      (apply sob-difference sets))
 
    (define (bag-difference . bags)
      (check-all-bags bags)
      (apply sob-difference bags))
 
    (define (sob-difference! sob1 . sobs)
      (for-each
       (lambda (sob) (dyadic-sob-difference! sob1 sob1 sob))
       sobs)
      (sob-cleanup! sob1))
 
    (define (set-difference! . sets)
      (check-all-sets sets)
      (apply sob-difference! sets))
 
    (define (bag-difference! . bags)
      (check-all-bags bags)
      (apply sob-difference! bags))
 
    (define (sob-sum sob1 . sobs)
      (if (null? sobs)
        sob1
        (let ((result (sob-empty-copy sob1)))
          (dyadic-sob-sum! result sob1 (car sobs))
          (for-each
           (lambda (sob) (dyadic-sob-sum! result result sob))
           (cdr sobs))
          result)))
 
    ;; Sum is just like union, except that we take the sum rather than the max.
 
    (define (dyadic-sob-sum! result sob1 sob2)
      (let ((sob1-ht (sob-hash-table sob1))
            (sob2-ht (sob-hash-table sob2))
            (result-ht (sob-hash-table result)))
        (hash-table-for-each
          (lambda (key value1)
            (let ((value2 (hash-table-ref/default sob2-ht key 0)))
              (hash-table-set! result-ht key (+ value1 value2))))
          sob1-ht)
        (hash-table-for-each
          (lambda (key value2)
            (let ((value1 (hash-table-ref/default sob1-ht key 0)))
              (if (= value1 0)
                  (hash-table-set! result-ht key value2))))
          sob2-ht)))
 
 
    ;; Sum is defined for bags only; for sets, it is the same as union.
 
    (define (bag-sum . bags)
      (check-all-bags bags)
      (apply sob-sum bags))
 
    (define (sob-sum! sob1 . sobs)
      (for-each
       (lambda (sob) (dyadic-sob-sum! sob1 sob1 sob))
       sobs)
      sob1)
 
    (define (bag-sum! . bags)
      (check-all-bags bags)
      (apply sob-sum! bags))
 
    ;; For xor exactly two arguments are required, so the above structures are
    ;; not necessary.  This version accepts a result sob and computes the
    ;; absolute difference between the counts in the first sob and the
    ;; corresponding counts in the second.
 
    ;; We start by copying the entries in the second sob but not the first
    ;; into the first.  Then we scan the first sob, computing the absolute
    ;; difference of the values and writing them back into the first sob.
    ;; It's essential to scan the second sob first, as we are not going to
    ;; damage it in the process.  (Hat tip: Sam Tobin-Hochstadt.)
 
    (define (sob-xor! result sob1 sob2)
      (let ((sob1-ht (sob-hash-table sob1))
            (sob2-ht (sob-hash-table sob2))
            (result-ht (sob-hash-table result)))
        (hash-table-for-each
          (lambda (key value2)
            (let ((value1 (hash-table-ref/default sob1-ht key 0)))
              (if (= value1 0)
                  (hash-table-set! result-ht key value2))))
          sob2-ht)
        (hash-table-for-each
          (lambda (key value1)
            (let ((value2 (hash-table-ref/default sob2-ht key 0)))
              (hash-table-set! result-ht key (abs (- value1 value2)))))
          sob1-ht)
        (sob-cleanup! result)))
 
    (define (set-xor set1 set2)
      (check-set set1)
      (check-set set2)
      (check-same-comparator set1 set2)
      (sob-xor! (sob-empty-copy set1) set1 set2))
 
    (define (bag-xor bag1 bag2)
      (check-bag bag1)
      (check-bag bag2)
      (check-same-comparator bag1 bag2)
      (sob-xor! (sob-empty-copy bag1) bag1 bag2))
 
    (define (set-xor! set1 set2)
      (check-set set1)
      (check-set set2)
      (check-same-comparator set1 set2)
      (sob-xor! set1 set1 set2))
 
    (define (bag-xor! bag1 bag2)
      (check-bag bag1)
      (check-bag bag2)
      (check-same-comparator bag1 bag2)
      (sob-xor! bag1 bag1 bag2))
 
 
    ;;; A few bag-specific procedures
 
    (define (sob-product! n result sob)
      (let ((rht (sob-hash-table result)))
        (hash-table-for-each
          (lambda (elem count) (hash-table-set! rht elem (* count n)))
          (sob-hash-table sob))
        result))
 
    (define (valid-n n)
       (and (integer? n) (exact? n) (positive? n)))
 
    (define (bag-product n bag)
      (check-bag bag)
      (valid-n n)
      (sob-product! n (sob-empty-copy bag) bag))
 
    (define (bag-product! n bag)
      (check-bag bag)
      (valid-n n)
      (sob-product! n bag bag))
 
    (define (bag-unique-size bag)
      (check-bag bag)
      (hash-table-size (sob-hash-table bag)))
 
    (define (bag-element-count bag elem)
      (check-bag bag)
      (hash-table-ref/default (sob-hash-table bag) elem 0))
 
    (define (bag-for-each-unique proc bag)
      (check-bag bag)
      (hash-table-for-each
        (lambda (key value) (proc key value))
        (sob-hash-table bag)))
 
    (define (bag-fold-unique proc nil bag)
      (check-bag bag)
      (let ((result nil))
        (hash-table-for-each
          (lambda (elem count) (set! result (proc elem count result)))
          (sob-hash-table bag))
        result))
 
    (define (bag->set bag)
      (check-bag bag)
      (let ((result (make-sob (sob-comparator bag) #f)))
        (hash-table-for-each
          (lambda (key value) (sob-increment! result key value))
          (sob-hash-table bag))
        result))
 
    (define (set->bag set)
      (check-set set)
      (let ((result (make-sob (sob-comparator set) #t)))
        (hash-table-for-each
          (lambda (key value) (sob-increment! result key value))
          (sob-hash-table set))
        result))
 
    (define (set->bag! bag set)
      (check-bag bag)
      (check-set set)
      (check-same-comparator set bag)
      (hash-table-for-each
        (lambda (key value) (sob-increment! bag key value))
        (sob-hash-table set))
      bag)
 
    (define (bag->alist bag)
      (check-bag bag)
      (bag-fold-unique
        (lambda (elem count list) (cons (cons elem count) list))
        '()
        bag))
 
    (define (alist->bag comparator alist)
      (let* ((result (bag comparator))
             (ht (sob-hash-table result)))
        (for-each
          (lambda (assoc)
            (let ((element (car assoc)))
              (if (not (hash-table-contains? ht element))
                  (sob-increment! result element (cdr assoc)))))
          alist)
        result))
 
    ;;; Comparators
 
    ;; Hash over sobs
    (define (sob-hash sob)
      (let* ((hash (comparator-hash-function (sob-comparator sob))))
        (sob-fold
          (lambda (element result) (fx+ (integer->fixnum (hash element)) result))
          5381
          sob)))
 
    ;; Set and bag comparator
 
    (define set-comparator (make-comparator set? set=? #f sob-hash))
 
    (define bag-comparator (make-comparator bag? bag=? #f sob-hash))
 
    ;;; Register above comparators for use by default-comparator
    (comparator-register-default! set-comparator)
    (comparator-register-default! bag-comparator)
 
    ;;; Set/bag printer (for debugging)
 
    (define (sob-print sob port)
      (display (if (sob-multi? sob) "&bag[" "&set[") port)
      (sob-for-each
        (lambda (elem) (display " " port) (write elem port))
        sob)
      (display " ]" port))
  )
)
;;; SRFI 118
;;; Simple adjustable-size strings
;;;
;;; Scheme specifies mutable fixed-length strings. We add two procedures
;;; `string-append!` and `string-replace!` which allow the size of the string
;;; to change. We also require that the standard Scheme procedures `make-string`
;;; and `string-copy` return variable-size strings.
;;;
;;; Specification:
;;;   Copyright © 2015 Per Bothner. All rights reserved.
;;; 
;;; Implementation:
;;;   Copyright © 2022 Matthias Zenger. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.

(define-library (srfi 118)
  
  (export string-append!
          string-replace!)
  
  (import (except (lispkit base) string-replace!))
  
  (begin
    (define (string-replace! dst dst-start dst-end src . args)
      (let-optionals args ((start 0)
                           (end (string-length src)))
        (string-insert! dst (substring src start end) dst-start dst-end)))
  )
)
;;; SRFI 121
;;; Generators
;;;
;;; This SRFI defines utility procedures that create, transform, and consume generators.
;;; A generator is simply a procedure with no arguments that works as a source of a series
;;; of values. Every time it is called, it yields a value. Generators may be finite or
;;; infinite; a finite generator returns an end-of-file object to indicate that it is
;;; exhausted. For example, read-char, read-line, and read are generators that generate
;;; characters, lines, and objects from the current input port. Generators provide
;;; lightweight laziness.
;;;
;;; Copyright © 2015 Shiro Kawai, John Cowan, Thomas Gilray. All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 121)

  (export generator
          make-iota-generator
          make-range-generator
          make-coroutine-generator
          list->generator
          vector->generator
          reverse-vector->generator
          string->generator
          bytevector->generator
          make-for-each-generator
          make-unfold-generator
          gcons*
          gappend
          gcombine
          gfilter
          gremove
          gtake
          gdrop
          gtake-while
          gdrop-while
          gdelete
          gdelete-neighbor-dups
          gindex
          gselect
          generator->list
          generator->reverse-list
          generator->vector
          generator->vector!
          generator->string
          generator-fold
          generator-for-each
          generator-find
          generator-count
          generator-any
          generator-every
          generator-unfold)

  (import (lispkit base))

  (begin

    ;; generator
    (define (generator . args)
      (lambda () (if (null? args)
                     (eof-object)
                     (let ((next (car args))) (set! args (cdr args)) next))))

    ;; make-iota-generator
    (define make-iota-generator
      (case-lambda ((count) (make-iota-generator count 0 1))
                   ((count start) (make-iota-generator count start 1))
                   ((count start step) (make-iota count start step))))

    ;; make-iota
    (define (make-iota count start step)
      (lambda () (if (<= count 0)
                     (eof-object)
                     (let ((result start))
                       (set! count (- count 1))
                       (set! start (+ start step))
                       result))))

    ;; make-range-generator
    (define make-range-generator
      (case-lambda ((start end)      (make-range-generator start end 1))
                   ((start)          (make-infinite-range-generator start))
                   ((start end step) (set! start (- (+ start step) step))
                                     (lambda () (if (< start end)
                                                    (let ((v start))
                                                      (set! start (+ start step))
                                                      v)
                                                    (eof-object))))))

    (define (make-infinite-range-generator start)
      (lambda () (let ((result start)) (set! start (+ start 1)) result)))

    ;; make-coroutine-generator
    (define (make-coroutine-generator proc)
      (let* ((return #f)
             (resume #f)
             (yield  (lambda (v) (call/cc (lambda (r) (set! resume r) (return v))))))
        (lambda () (call/cc (lambda (cc) (set! return cc)
                              (if resume
                                (resume (void))  ; void? or yield again?
                                (begin (proc yield)
                                       (set! resume (lambda (v) (return (eof-object))))
                                       (return (eof-object)))))))))

    ;; list->generator
    (define (list->generator lst)
      (lambda () (if (null? lst)
                   (eof-object)
                   (let ((next (car lst))) (set! lst (cdr lst)) next))))

    ;; vector->generator
    (define vector->generator
      (case-lambda ((vec)           (vector->generator vec 0 (vector-length vec)))
                   ((vec start)     (vector->generator vec start (vector-length vec)))
                   ((vec start end) (lambda () (if (>= start end)
                                                   (eof-object)
                                                   (let ((next (vector-ref vec start)))
                                                     (set! start (+ start 1))
                                                     next))))))

    ;; reverse-vector->generator
    (define reverse-vector->generator
      (case-lambda ((vec)           (reverse-vector->generator vec 0 (vector-length vec)))
                   ((vec start)     (reverse-vector->generator vec start (vector-length vec)))
                   ((vec start end) (lambda () (if (>= start end)
                                                   (eof-object)
                                                   (let ((next (vector-ref vec (- end 1))))
                                                     (set! end (- end 1))
                                                     next))))))

    ;; string->generator
    (define string->generator
      (case-lambda ((str)           (string->generator str 0 (string-length str)))
                   ((str start)     (string->generator str start (string-length str)))
                   ((str start end) (lambda () (if (>= start end)
                                                   (eof-object)
                                                   (let ((next (string-ref str start)))
                                                     (set! start (+ start 1))
                                                     next))))))

    ;; bytevector->generator
    (define bytevector->generator
      (case-lambda ((str)           (bytevector->generator str 0 (bytevector-length str)))
                   ((str start)     (bytevector->generator str start (bytevector-length str)))
                   ((str start end) (lambda () (if (>= start end)
                                                   (eof-object)
                                                   (let ((next (bytevector-u8-ref str start)))
                                                     (set! start (+ start 1))
                                                     next))))))

    ;; make-for-each-generator
    ;FIXME: seems to fail test
    (define (make-for-each-generator for-each obj)
      (make-coroutine-generator (lambda (yield) (for-each yield obj))))

    ;; make-unfold-generator
    (define (make-unfold-generator stop? mapper successor seed)
      (make-coroutine-generator (lambda (yield) (let loop ((s seed))
                                                  (if (stop? s)
                                                      (void)
                                                      (begin (yield (mapper s))
                                                             (loop (successor s))))))))

    ;; gcons*
    (define (gcons* . args)
      (lambda () (if (null? args)
                     (eof-object)
                     (if (= (length args) 1)
                         ((car args))
                         (let ((v (car args))) (set! args (cdr args)) v)))))

    ;; gappend
    (define (gappend . args)
      (lambda () (if (null? args)
                     (eof-object)
                     (let loop ((v ((car args))))
                      (if (eof-object? v)
                        (begin (set! args (cdr args))
                               (if (null? args)
                                 (eof-object)
                                 (loop ((car args)))))
                        v)))))

    ;; gcombine
    (define (gcombine proc seed . gens)
      (lambda ()
        (let ((items (map (lambda (x) (x)) gens)))
          (if (any? eof-object? items)
              (eof-object)
              (let-values (((value newseed) (apply proc (append items (list seed)))))
                (set! seed newseed)
                value)))))

    ;; gfilter
    (define (gfilter pred gen)
      (lambda () (let loop ()
                   (let ((next (gen)))
                   (if (or (eof-object? next) (pred next)) next (loop))))))

    ;; gremove
    (define (gremove pred gen)
      (gfilter (lambda (v) (not (pred v))) gen))

    ;; gtake
    (define gtake
      (case-lambda ((gen k)
                     (gtake gen k (eof-object)))
                   ((gen k padding)
                     (make-coroutine-generator
                       (lambda (yield) (if (> k 0)
                                           (let loop ((i 0) (v (gen)))
                                             (begin (if (eof-object? v) (yield padding) (yield v))
                                                    (if (< (+ 1 i) k)
                                                        (loop (+ 1 i) (gen))
                                                        (eof-object))))
                                           (eof-object)))))))

    ;; gdrop
    (define (gdrop gen k)
      (lambda () (do () ((<= k 0)) (set! k (- k 1)) (gen)) (gen)))

    ;; gdrop-while
    (define (gdrop-while pred gen)
      (let ((found #f))
        (lambda () (let loop ()
                      (let ((val (gen)))
                        (cond (found val)
                              ((and (not (eof-object? val)) (pred val)) (loop))
                              (else (set! found #t) val)))))))

    ;; gtake-while
    (define (gtake-while pred gen)
      (lambda () (let ((next (gen)))
                   (if (eof-object? next)
                       next
                       (if (pred next) next (begin (set! gen (generator)) (gen)))))))

    ;; gdelete
    (define gdelete
      (case-lambda ((item gen)    (gdelete item gen equal?))
                   ((item gen ==) (lambda ()
                                    (let loop ((v (gen)))
                                      (cond ((eof-object? v) (eof-object))
                                            ((== item v)     (loop (gen)))
                                            (else            v)))))))

    ;; gdelete-neighbor-dups
    (define gdelete-neighbor-dups
      (case-lambda ((gen)
                     (gdelete-neighbor-dups gen equal?))
                   ((gen ==)
                     (let ((firsttime #t) (prev #f))
                       (lambda () (if firsttime
                                      (begin (set! firsttime #f)
                                             (set! prev (gen))
                                             prev)
                                      (let loop ((v (gen)))
                                        (cond ((eof-object? v) v)
                                              ((== prev v)     (loop (gen)))
                                              (else            (set! prev v) v)))))))))

    ;; gindex
    (define (gindex value-gen index-gen)
      (let ((done? #f) (count 0))
        (lambda ()
          (if done?
              (eof-object)
              (let loop ((value (value-gen)) (index (index-gen)))
                (cond ((or (eof-object? value) (eof-object? index))
                         (set! done? #t)
                         (eof-object))
                      ((= index count)
                         (set! count (+ count 1))
                         value)
                      (else
                         (set! count (+ count 1))
                         (loop (value-gen) index))))))))

    ;; gselect
    (define (gselect value-gen truth-gen)
      (let ((done? #f))
        (lambda ()
          (if done?
              (eof-object)
              (let loop ((value (value-gen)) (truth (truth-gen)))
                (cond ((or (eof-object? value) (eof-object? truth))
                         (set! done? #t)
                         (eof-object))
                      (truth
                         value)
                      (else
                         (loop (value-gen) (truth-gen)))))))))

    ;; generator->list
    (define generator->list
      (case-lambda ((gen n) (generator->list (gtake gen n)))
                   ((gen)   (reverse (generator->reverse-list gen)))))

    ;; generator->reverse-list
    (define generator->reverse-list
      (case-lambda ((gen n) (generator->reverse-list (gtake gen n)))
                   ((gen)   (generator-fold cons '() gen))))

    ;; generator->vector
    (define generator->vector
      (case-lambda ((gen)   (list->vector (generator->list gen)))
                   ((gen n) (list->vector (generator->list gen n)))))

    ;; generator->vector!
    (define (generator->vector! vector at gen)
      (let loop ((value (gen)) (count 0) (at at))
        (cond ((eof-object? value)            count)
              ((>= at (vector-length vector)) count)
              (else
                 (vector-set! vector at value)
                 (loop (gen) (+ count 1) (+ at 1))))))

    ;; generator->string
    (define generator->string
      (case-lambda ((gen)   (list->string (generator->list gen)))
                   ((gen n) (list->string (generator->list gen n)))))

    ;; generator-fold
    (define (generator-fold f seed . gs)
      (define (inner-fold seed)
        (let ((vs (map (lambda (g) (g)) gs)))
          (if (any? eof-object? vs)
              seed
              (inner-fold (apply f (append vs (list seed)))))))
      (inner-fold seed))

    ;; generator-for-each
    (define (generator-for-each f . gs)
      (let loop ()
        (let ((vs (map (lambda (g) (g)) gs)))
          (if (any? eof-object? vs)
              (void)
              (begin (apply f vs) (loop))))))

    ;; generator-find
    (define (generator-find pred g)
      (let loop ((v (g)))
        ; A literal interpretation might say it only terminates on #eof if (pred #eof)
        ; but I think this makes more sense...
        (if (or (pred v) (eof-object? v)) v (loop (g)))))

    ;; generator-count
    (define (generator-count pred g)
      (generator-fold (lambda (v n) (if (pred v) (+ 1 n) n)) 0 g))

    ;; generator-any
    (define (generator-any pred g)
      (let loop ((v (g)))
        (if (eof-object? v)
            #f
            (if (pred v) #t (loop (g))))))

    ;; generator-every
    (define (generator-every pred g)
      (let loop ((v (g)))
        (if (eof-object? v)
            #t
            (if (pred v)
                (loop (g))
                #f)))) ; the spec would have me return #f, but I think it must simply be wrong...

    ;; generator-unfold
    (define (generator-unfold g unfold . args)
      (apply unfold eof-object? (lambda (x) x) (lambda (x) (g)) (g) args))))
;;; SRFI 125
;;; Intermediate hash tables
;;;
;;; This SRFI defines an interface to hash tables, which are widely recognized as a
;;; fundamental data structure for a wide variety of applications. A hash table is a
;;; data structure that:
;;;
;;;   - Is disjoint from all other types.
;;;   - Provides a mapping from objects known as keys to corresponding objects known
;;;     as values.
;;;   - Keys may be any Scheme objects in some kinds of hash tables, but are restricted
;;;     in other kinds.
;;;   - Values may be any Scheme objects.
;;;   - Has no intrinsic order for the key-value associations it contains.
;;;   - Provides an equality predicate which defines when a proposed key is the same as
;;;     an existing key. No table may contain more than one value for a given key.
;;;   - Provides a hash function which maps a candidate key into a non-negative exact
;;;     integer.
;;;   - Supports mutation as the primary means of setting the contents of a table.
;;;   - Provides key lookup and destructive update in (expected) amortized constant time,
;;;     provided a satisfactory hash function is available.
;;;   - Does not guarantee that whole-table operations work in the presence of concurrent
;;;     mutation of the whole hash table (values may be safely mutated).
;;;
;;; This SRFI aims to accomplish these goals:
;;;
;;;   1. to provide a consistent, generic and widely applicable API for hash tables
;;;   2. to improve code portability by providing a standard hash table facility
;;;      with guaranteed behaviour
;;;   3. to help the programmer by defining utility routines that account for the
;;;      most common situations of using hash tables.
;;;
;;; Specification:
;;;   Copyright © 2016 John Cowan, Will Clinger. All rights reserved.
;;;
;;; Implementation:
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 125)

  (export make-hash-table
          hash-table
          hash-table-unfold
          alist->hash-table
          hash-table?
          hash-table-contains?
          hash-table-exists?
          hash-table-empty?
          hash-table=?
          hash-table-mutable?
          hash-table-ref
          hash-table-ref/default
          hash-table-set!
          hash-table-delete!
          hash-table-intern!
          hash-table-update!
          hash-table-update!/default
          hash-table-pop!
          hash-table-clear!
          hash-table-size
          hash-table-keys
          hash-table-values
          hash-table-entries
          hash-table-find
          hash-table-count
          hash-table-map
          hash-table-for-each
          hash-table-walk
          hash-table-map!
          hash-table-map->list
          hash-table-fold
          hash-table-prune!
          hash-table-copy
          hash-table-empty-copy
          hash-table->alist
          hash-table-union!
          hash-table-merge!
          hash-table-intersection!
          hash-table-difference!
          hash-table-xor!
          hash
          string-hash
          string-ci-hash
          hash-by-identity
          hash-table-equivalence-function
          hash-table-hash-function)

  (import (lispkit core)
          (lispkit control)
          (lispkit dynamic)
          (lispkit list)
          (lispkit math)
          (lispkit string)
          (except (lispkit hashtable) string-hash string-ci-hash symbol-hash equal-hash eq-hash)
          (except (srfi 128) string-hash string-ci-hash symbol-hash)
          (srfi 69 internal)
          (rename (except (srfi 69) string-hash string-ci-hash symbol-hash)
                  (make-hash-table        %make-hash-table)
                  (hash-table-ref         %hash-table-ref)
                  (hash-table-ref/default %hash-table-ref/default)
                  (hash-table-set!        %hash-table-set!)
                  (hash-table-delete!     %hash-table-delete!)
                  (hash-table-fold        %hash-table-fold)
                  (hash-table-copy        %hash-table-copy)
                  (alist->hash-table      %alist->hash-table)))

  (begin

    (define (make-hash-table comparison . args)
      (if (comparator? comparison)
          (let-optionals args ((size default-table-size))
            (%make-hash-table (comparator-equality-predicate comparison)
                              (comparator-hash-function comparison)
                              size))
          (let*-optionals args ((hash (appropriate-hash-function-for comparison))
                                (size default-table-size))
            (%make-hash-table comparison hash size))))

    (define (hash-table comparator . args)
      (let ((ht (make-hash-table comparator)))
        (do ((ls args (cddr ls)))
            ((null? ls) ht)
          (hash-table-set! ht (car ls) (cadr ls)))))

    (define (hash-table-unfold stop? mapper successor seed comparator . args)
      (let-optionals args ((size default-table-size))
        (let ((ht (make-hash-table comparator size)))
          (let lp ((acc seed))
            (if (stop? acc)
                ht
                (call-with-values (lambda () (mapper acc))
                                  (lambda (key value)
                                    (hash-table-set! ht key value)
                                    (lp (successor acc)))))))))

    (define (alist->hash-table alist comparison . args)
      (if (comparator? comparison)
          (let-optionals args ((size default-table-size))
            (%alist->hash-table alist
                                (comparator-equality-predicate comparison)
                                (comparator-hash-function comparison)
                                size))
          (let*-optionals args ((hash (appropriate-hash-function-for comparison))
                                (size default-table-size))
            (%alist->hash-table alist comparison hash size))))

    ;; (hash-table? obj) from (srfi 69)

    (define hash-table-contains? hash-table-exists?)

    (define (hash-table-empty? ht) (zero? (hash-table-size ht)))

    (define (hash-table=? value-cmp ht1 ht2)
      (and (= (hash-table-size ht1) (hash-table-size ht2))
           (let lp ((ls (hash-table-keys ht1)))
             (or (null? ls)
                 (let ((v1 (hash-table-ref/default ht1 (car ls) missing-key))
                       (v2 (hash-table-ref/default ht2 (car ls) missing-key)))
                   (and (not (eq? missing-key v1))
                        (not (eq? missing-key v2))
                        ((comparator-equality-predicate value-cmp) v1 v2)
                        (lp (cdr ls))))))))

    (define (hash-table-mutable? ht)
      (hashtable-mutable? (get-hashtable ht)))

    (define (hash-table-ref ht key . args)
      (let-optionals args ((failure #f)
                           (success #f))
        (let ((value (hashtable-ref (get-hashtable ht) key missing-key)))
          (cond ((eq? value missing-key)
                  (if (procedure? failure)
                      (failure)
                      (error "hash-table-ref: no value associated with" key)))
                (success
                  (success value))
                (else
                  value)))))

    (define (hash-table-ref/default ht key default)
      (hashtable-ref (get-hashtable ht) key default))

    (define (hash-table-set! ht . args)
      (do ((ls args (cddr ls)))
          ((null? ls))
        (%hash-table-set! ht (car ls) (cadr ls))))

    (define (hash-table-delete! ht . keys)
      (for-each (lambda (key) (%hash-table-delete! ht key)) keys))

    (define (hash-table-intern! ht key failure)
      (hash-table-ref ht key (lambda ()
                               (let ((res (failure)))
                                 (hash-table-set! ht key res)
                                 res))))

    ;; (hash-table-update! hash-table key updater [failure [success]]) from (srfi 69)
    ;; (hash-table-update!/default hash-table key updater default) from (srfi 69)

    (define (hash-table-pop! ht)
      (let* ((key (car (hash-table-keys ht)))
             (value (hash-table-ref ht key)))
        (hash-table-delete! ht key)
        (values key value)))

    (define (hash-table-clear! ht)
      (for-each (lambda (key) (hash-table-delete! ht key))
                (hash-table-keys ht)))

    ;; (hash-table-size hash-table) from (srfi 69)
    ;; (hash-table-keys hash-table) from (srfi 69)
    ;; (hash-table-values hash-table) from (srfi 69)

    (define (hash-table-entries ht)
      (values (hash-table-keys ht) (hash-table-values ht)))

    (define (hash-table-find proc ht failure)
      (call-with-current-continuation
        (lambda (return)
          (hash-table-for-each
            (lambda (key value)
              (let ((res (proc key value)))
                (if res (return res))))
            ht)
          (failure))))

    (define (hash-table-count proc ht)
      (let ((count 0))
        (hash-table-for-each
          (lambda (key value)
            (if (proc key value) (set! count (+ count 1))))
          ht)
        count))

    (define (hash-table-map proc cmp ht)
      (let ((ht2 (make-hash-table cmp)))
        (hash-table-for-each (lambda (key value) (hash-table-set! ht2 key (proc value))) ht)
        ht2))

    (define (hash-table-for-each proc ht)
      (hashtable-for-each proc (get-hashtable ht)))

    (define (hash-table-map! proc ht)
      (for-each (lambda (key value) (hash-table-set! ht key (proc key value)))
                (hash-table-keys ht)
                (hash-table-values ht)))

    (define (hash-table-map->list proc ht)
      (map (lambda (cell) (proc (car cell) (cdr cell))) (hash-table->alist ht)))

    (define (hash-table-fold a b c)
      (if (hash-table? a)
          (%hash-table-fold a b c)
          (%hash-table-fold c a b)))

    (define (hash-table-prune! proc ht)
      (for-each (lambda (key value) (if (proc key value) (hash-table-delete! ht key)))
                (hash-table-keys ht)
                (hash-table-values ht)))

    (define (hash-table-copy ht . args)
      (let-optionals args ((mutable #f))
        (new-hash-table (hashtable-copy (get-hashtable ht) mutable))))

    (define (hash-table-empty-copy ht)
      (make-hash-table (hash-table-equivalence-function ht)
                       (hash-table-hash-function ht)))

    ;; (hash-table->alist hash-table) from (srfi 69)

    (define hash-table-union! hash-table-merge!)

    (define (hash-table-intersection! ht1 ht2)
      (for-each (lambda (key)
                  (if (not (hash-table-contains? ht2 key))
                      (hash-table-delete! ht1 key)))
                (hash-table-keys ht1))
      ht1)

    (define (hash-table-difference! ht1 ht2)
      (for-each (lambda (key)
                  (if (hash-table-contains? ht2 key)
                      (hash-table-delete! ht1 key)))
                (hash-table-keys ht1))
      ht1)

    (define (hash-table-xor! ht1 ht2)
      (let ((ht (get-hashtable ht1)))
        (hash-table-for-each
          (lambda (key2 val2)
            (if (hashtable-contains? ht key2)
                (hashtable-delete! ht key2)
                (hashtable-set! ht key2 val2)))
          ht2)
        ht1))
  )
)
;;; SRFI 128
;;; Comparators
;;;
;;; This SRFI provides comparators, which bundle a type test predicate, an equality predicate,
;;; an ordering predicate, and a hash function (the last two are optional) into a single
;;; Scheme object. By packaging these procedures together, they can be treated as a single
;;; item for use in the implementation of data structures.
;;;
;;; Copyright © 2015 John Cowan. All Rights Reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 128)

  ;; SRFI 128 exports
  (export comparator?
          comparator-ordered?
          comparator-hashable?
          make-comparator
          make-pair-comparator
          make-list-comparator
          make-vector-comparator
          make-eq-comparator
          make-eqv-comparator
          make-equal-comparator
          boolean-hash
          char-hash
          char-ci-hash
          string-hash
          string-ci-hash
          symbol-hash
          number-hash
          make-default-comparator
          default-hash
          comparator-register-default!
          comparator-type-test-predicate
          comparator-equality-predicate
          comparator-ordering-predicate
          comparator-hash-function
          comparator-test-type
          comparator-check-type
          comparator-hash
          hash-bound
          hash-salt
          =?
          <?
          >?
          <=?
          >=?
          comparator-if<=>)

  ;; SRFI 162 exports
  (export comparator-max
          comparator-min
          comparator-max-in-list
          comparator-min-in-list
          default-comparator
          boolean-comparator
          real-comparator
          char-comparator
          char-ci-comparator
          string-comparator
          string-ci-comparator
          list-comparator
          vector-comparator
          eq-comparator
          eqv-comparator
          equal-comparator)

  (import (lispkit base)
          (only (lispkit comparator) make-comparator
                                     comparator?
                                     comparator-type-test-predicate
                                     comparator-equality-predicate
                                     comparator-ordering-predicate
                                     comparator-hash-function
                                     comparator-ordered?
                                     comparator-hashable?
                                     =?
                                     <?
                                     >?
                                     <=?
                                     >=?
                                     comparator-if<=>))

  ;;; Main part of the SRFI 114 reference implementation
  ;;;
  ;;; "There are two ways of constructing a software design: One way is to
  ;;; make it so simple that there are obviously no deficiencies, and the
  ;;; other way is to make it so complicated that there are no *obvious*
  ;;; deficiencies." --Tony Hoare

  (begin

    ;; Upper bound of hash functions is 2^25-1
    (define-syntax hash-bound
      (syntax-rules ()
        ((hash-bound) 33554432)))

    (define %salt% (make-parameter 16064047))

    (define-syntax hash-salt
       (syntax-rules ()
         ((hash-salt) (%salt%))))

    (define-syntax with-hash-salt
      (syntax-rules ()
        ((with-hash-salt new-salt hash-func obj)
          (parameterize ((%salt% new-salt)) (hash-func obj)))))

    ;; Invokers

    ;; Invoke the test type
    (define (comparator-test-type comparator obj)
      ((comparator-type-test-predicate comparator) obj))

    ;; Invoke the test type and throw an error if it fails
    (define (comparator-check-type comparator obj)
      (if (comparator-test-type comparator obj)
        #t
        (error "comparator type check failed" comparator obj)))

    ;; Invoke the hash function
    (define (comparator-hash comparator obj)
      ((comparator-hash-function comparator) obj))

    ;; Simple ordering and hash functions
    
    (define (boolean<? a b)
      ;; #f < #t but not otherwise
      (and (not a) b))

    ;; Lexicographic ordering of complex numbers
    (define (complex<? a b)
      (if (= (real-part a) (real-part b))
          (< (imag-part a) (imag-part b))
          (< (real-part a) (real-part b))))

    (define (symbol<? a b)
      (string<? (symbol->string a) (symbol->string b)))

    ;; Wrapped equality predicates
    ;; These comparators don't have ordering functions.

    (define (make-eq-comparator)
      (make-comparator #t eq? #f default-hash))

    (define (make-eqv-comparator)
      (make-comparator #t eqv? #f default-hash))

    (define (make-equal-comparator)
      (make-comparator #t equal? #f default-hash))

    ;; Sequence ordering and hash functions
    ;; The hash functions are based on djb2, but
    ;; modulo 2^25 instead of 2^32 in hopes of sticking to fixnums.

    (define (make-hasher)
      (let ((result (%salt%)))
        (case-lambda
         (() result)
         ((n) (set! result (+ (modulo (* result 33) (hash-bound)) n))
              result))))

    ;; Pair comparator

    (define (make-pair-comparator car-comparator cdr-comparator)
       (make-comparator (make-pair-type-test car-comparator cdr-comparator)
                        (make-pair=? car-comparator cdr-comparator)
                        (make-pair<? car-comparator cdr-comparator)
                        (make-pair-hash car-comparator cdr-comparator)))

    (define (make-pair-type-test car-comparator cdr-comparator)
      (lambda (obj)
        (and (pair? obj)
             (comparator-test-type car-comparator (car obj))
             (comparator-test-type cdr-comparator (cdr obj)))))

    (define (make-pair=? car-comparator cdr-comparator)
       (lambda (a b)
         (and ((comparator-equality-predicate car-comparator) (car a) (car b))
              ((comparator-equality-predicate cdr-comparator) (cdr a) (cdr b)))))

    (define (make-pair<? car-comparator cdr-comparator)
       (lambda (a b)
          (if (=? car-comparator (car a) (car b))
              (<? cdr-comparator (cdr a) (cdr b))
              (<? car-comparator (car a) (car b)))))

    (define (make-pair-hash car-comparator cdr-comparator)
       (lambda (obj)
         (let ((acc (make-hasher)))
           (acc (comparator-hash car-comparator (car obj)))
           (acc (comparator-hash cdr-comparator (cdr obj)))
           (acc))))

    ;; List comparator

    (define (make-list-comparator element-comparator type-test empty? head tail)
       (make-comparator (make-list-type-test element-comparator type-test empty? head tail)
                        (make-list=? element-comparator type-test empty? head tail)
                        (make-list<? element-comparator type-test empty? head tail)
                        (make-list-hash element-comparator type-test empty? head tail)))

    (define (make-list-type-test element-comparator type-test empty? head tail)
      (lambda (obj)
        (and
          (type-test obj)
          (let ((elem-type-test (comparator-type-test-predicate element-comparator)))
            (let loop ((obj obj))
              (cond ((empty? obj)                      #t)
                    ((not (elem-type-test (head obj))) #f)
                    (else                              (loop (tail obj)))))))))

    (define (make-list=? element-comparator type-test empty? head tail)
      (lambda (a b)
        (let ((elem=? (comparator-equality-predicate element-comparator)))
          (let loop ((a a) (b b))
            (cond ((and (empty? a) (empty? b) #t))
                  ((empty? a)                 #f)
                  ((empty? b)                 #f)
                  ((elem=? (head a) (head b)) (loop (tail a) (tail b)))
                  (else                       #f))))))

    (define (make-list<? element-comparator type-test empty? head tail)
      (lambda (a b)
        (let ((elem=? (comparator-equality-predicate element-comparator))
              (elem<? (comparator-ordering-predicate element-comparator)))
          (let loop ((a a) (b b))
            (cond ((and (empty? a) (empty? b)) #f)
                  ((empty? a)                  #t)
                  ((empty? b)                  #f)
                  ((elem=? (head a) (head b))  (loop (tail a) (tail b)))
                  ((elem<? (head a) (head b))  #t)
                  (else                        #f))))))

    (define (make-list-hash element-comparator type-test empty? head tail)
      (lambda (obj)
        (let ((elem-hash (comparator-hash-function element-comparator))
              (acc (make-hasher)))
          (let loop ((obj obj))
            (cond ((empty? obj) (acc))
                  (else         (acc (elem-hash (head obj)))
                                (loop (tail obj))))))))

    ;; Vector comparator

    (define (make-vector-comparator element-comparator type-test length ref)
         (make-comparator
           (make-vector-type-test element-comparator type-test length ref)
           (make-vector=? element-comparator type-test length ref)
           (make-vector<? element-comparator type-test length ref)
           (make-vector-hash element-comparator type-test length ref)))

    (define (make-vector-type-test element-comparator type-test length ref)
      (lambda (obj)
        (and
          (type-test obj)
          (let ((elem-type-test (comparator-type-test-predicate element-comparator))
                (len (length obj)))
            (let loop ((n 0))
              (cond
                ((= n len)                          #t)
                ((not (elem-type-test (ref obj n))) #f)
                (else                               (loop (+ n 1)))))))))

    (define (make-vector=? element-comparator type-test length ref)
       (lambda (a b)
         (and
           (= (length a) (length b))
           (let ((elem=? (comparator-equality-predicate element-comparator))
                 (len (length b)))
             (let loop ((n 0))
               (cond ((= n len)                    #t)
                     ((elem=? (ref a n) (ref b n)) (loop (+ n 1)))
                     (else                         #f)))))))

    (define (make-vector<? element-comparator type-test length ref)
       (lambda (a b)
         (cond
           ((< (length a) (length b)) #t)
           ((> (length a) (length b)) #f)
            (else
             (let ((elem=? (comparator-equality-predicate element-comparator))
                   (elem<? (comparator-ordering-predicate element-comparator))
                   (len    (length a)))
             (let loop ((n 0))
               (cond ((= n len)                    #f)
                     ((elem=? (ref a n) (ref b n)) (loop (+ n 1)))
                     ((elem<? (ref a n) (ref b n)) #t)
                     (else                         #f))))))))

    (define (make-vector-hash element-comparator type-test length ref)
      (lambda (obj)
        (let ((elem-hash (comparator-hash-function element-comparator))
              (acc (make-hasher))
              (len (length obj)))
          (let loop ((n 0))
            (cond ((= n len) (acc))
                  (else      (acc (elem-hash (ref obj n)))
                             (loop (+ n 1))))))))
  )

  ;;; The default comparator

  (begin
    ;; Standard comparators and their functions

    ;; The unknown-object comparator, used as a fallback to everything else
    ;; Everything compares exactly the same and hashes to 0
    (define unknown-object-comparator
      (make-comparator (lambda (obj) #t)
                       (lambda (a b) #t)
                       (lambda (a b) #f)
                       (lambda (obj) 0)))

    ;; Next index for added comparator

    (define first-comparator-index 9)
    (define *next-comparator-index* 9)
    (define *registered-comparators* (list unknown-object-comparator))

    ;; Register a new comparator for use by the default comparator.
    (define (comparator-register-default! comparator)
      (set! *registered-comparators* (cons comparator *registered-comparators*))
      (set! *next-comparator-index* (+ *next-comparator-index* 1)))

    ;; Return ordinal for object types: null sorts before pairs, which sort
    ;; before booleans, etc.  Implementations can extend this.
    ;; People who call comparator-register-default! effectively do extend it.
    (define (object-type obj)
      (cond ((null? obj) 0)
            ((pair? obj) 1)
            ((boolean? obj) 2)
            ((char? obj) 3)
            ((string? obj) 4)
            ((symbol? obj) 5)
            ((number? obj) 6)
            ((vector? obj) 7)
            ((bytevector? obj) 8)
            ; Add more here if you want: be sure to update comparator-index variables
            (else (registered-index obj))))

    ;; Return the index for the registered type of obj.
    (define (registered-index obj)
      (let loop ((i 0) (registry *registered-comparators*))
        (cond ((null? registry)                          (+ first-comparator-index i))
              ((comparator-test-type (car registry) obj) (+ first-comparator-index i))
              (else                                      (loop (+ i 1) (cdr registry))))))

    ;; Given an index, retrieve a registered conductor.
    ;; Index must be >= first-comparator-index.
    (define (registered-comparator i)
      (list-ref *registered-comparators* (- i first-comparator-index)))

    (define (binary=? comparator a b)
      ((comparator-equality-predicate comparator) a b))

    (define (binary<? comparator a b)
      ((comparator-ordering-predicate comparator) a b))

    (define (dispatch-equality type a b)
      (case type
        ((0) #t) ; All empty lists are equal
        ((1) ((make-pair=? (make-default-comparator) (make-default-comparator)) a b))
        ((2) (boolean=? a b))
        ((3) (char=? a b))
        ((4) (string=? a b))
        ((5) (symbol=? a b))
        ((6) (= a b))
        ((7) ((make-vector=? (make-default-comparator)
                             vector? vector-length vector-ref) a b))
        ((8) ((make-vector=? (make-comparator exact-integer? = < default-hash)
                             bytevector? bytevector-length bytevector-u8-ref) a b))
        ; Add more here
        (else (binary=? (registered-comparator type) a b))))

    (define (dispatch-ordering type a b)
      (case type
        ((0) 0) ; All empty lists are equal
        ((1) ((make-pair<? (make-default-comparator) (make-default-comparator)) a b))
        ((2) (boolean<? a b))
        ((3) (char<? a b))
        ((4) (string<? a b))
        ((5) (symbol<? a b))
        ((6) (complex<? a b))
        ((7) ((make-vector<? (make-default-comparator) vector? vector-length vector-ref) a b))
        ((8) ((make-vector<? (make-comparator exact-integer? = < default-hash)
           bytevector? bytevector-length bytevector-u8-ref) a b))
        ; Add more here
        (else (binary<? (registered-comparator type) a b))))

    ;; The author of SRFI 128 has suggested a post-finalization note
    ;; saying the first and third bullet items stating "must" requirements
    ;; for default-hash may be weakened.  That allows a much faster hash
    ;; function to be used for lists and vectors.

    (define (default-hash obj)
      (case (object-type obj)
        ((0 1 7) ((make-hasher) (equal-hash obj))) ; empty list, pair, or vector
        ((2)     (boolean-hash obj))
        ((3)     (char-hash obj))
        ((4)     (string-hash obj))
        ((5)     (symbol-hash obj))
        ((6)     (number-hash obj))
        ((8)     ((make-vector-hash (make-default-comparator)
                                       bytevector? bytevector-length bytevector-u8-ref) obj))
        ; Add more here
        (else    (comparator-hash (registered-comparator (object-type obj)) obj))))

    (define (default-ordering a b)
      (let ((a-type (object-type a))
            (b-type (object-type b)))
        (cond
          ((< a-type b-type) #t)
          ((> a-type b-type) #f)
          (else              (dispatch-ordering a-type a b)))))

    (define (default-equality a b)
      (let ((a-type (object-type a))
            (b-type (object-type b)))
        (if (= a-type b-type)
            (dispatch-equality a-type a b)
            #f)))

    (define (make-default-comparator)
      (make-comparator (lambda (obj) #t)
                       default-equality
                       default-ordering
                       default-hash)))
  
  ;; SRFI 162 implementation
  (begin
    
    (define (comparator-max-in-list comp list)
      (let ((< (comparator-ordering-predicate comp)))
        (let loop ((max (car list)) (list (cdr list)))
          (if (null? list)
            max
            (if (< max (car list))
              (loop (car list) (cdr list))
              (loop max (cdr list)))))))

    (define (comparator-min-in-list comp list)
      (let ((< (comparator-ordering-predicate comp)))
        (let loop ((min (car list)) (list (cdr list)))
          (if (null? list)
            min
            (if (< min (car list))
              (loop min (cdr list))
              (loop (car list) (cdr list)))))))

    (define (comparator-max comp . args)
      (comparator-max-in-list comp args))

    (define (comparator-min comp . args)
      (comparator-min-in-list comp args))

    (define default-comparator (make-default-comparator))

    (define boolean-comparator
      (make-comparator
        boolean?
        boolean=?
        (lambda (x y) (and (not x) y))
        boolean-hash))

    (define real-comparator
      (make-comparator
        real?
        =
        <
        number-hash))

    (define char-comparator
      (make-comparator
        char?
        char=?
        char<?
        (lambda (c) (number-hash (char->integer c)))))

    (define char-ci-comparator
      (make-comparator
        char?
        char-ci=?
        char-ci<?
        (lambda (c) (number-hash (char->integer (char-downcase c))))))

    (define string-comparator
      (make-comparator
        string?
        string=?
        string<?
        string-hash))

    (define string-ci-comparator
      (make-comparator
        string?
        string-ci=?
        string-ci<?
        string-ci-hash))

    (define pair-comparator
      (make-pair-comparator
        default-comparator
        default-comparator))

    (define list-comparator
      (make-list-comparator
        default-comparator
        list?
        null?
        car
        cdr))

    (define vector-comparator
      (make-vector-comparator
        default-comparator
        vector?
        vector-length
        vector-ref))

    (define eq-comparator (make-eq-comparator))
    (define eqv-comparator (make-eqv-comparator))
    (define equal-comparator (make-equal-comparator))
  )
)
;;; SRFI 129
;;; Titlecase procedures
;;;
;;; This SRFI defines R7RS-style char-title-case?, char-titlecase, and
;;; string-titlecase procedures.
;;;
;;; Copyright © 2015 John Cowan. All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 129)
 
  (export char-title-case?
          char-titlecase
          string-titlecase)
 
  (import (lispkit base))
 
  (begin
    ;;;; Alists for titlecase functions
 
    ;;; Assumes that char->integer and integer->char are a subset of Unicode
    ;;; codepoint mappings rather than some random codes, as R5RS allows
    ;;; but R[67]RS do not.  It may be necessary to remove some lines if
    ;;; the codepoints referred to don't correspond to characters present
    ;;; in the implementation.
 
    ;;; These maps are valid from Unicode 5.0 to at least Unicode 8.0
    ;;; and are expected to be stable for the foreseeable future.
 
    ;; Alist mapping titlecase characters to themselves
    (define titlecase-chars '(
      (#x01C5 #x01C5) ; LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
      (#x01C8 #x01C8) ; LATIN CAPITAL LETTER L WITH SMALL LETTER J
      (#x01CB #x01CB) ; LATIN CAPITAL LETTER N WITH SMALL LETTER J
      (#x01F2 #x01F2) ; LATIN CAPITAL LETTER D WITH SMALL LETTER Z
      (#x1F88 #x1F88) ; GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
      (#x1F89 #x1F89) ; GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
      (#x1F8A #x1F8A) ; GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
      (#x1F8B #x1F8B) ; GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
      (#x1F8C #x1F8C) ; GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
      (#x1F8D #x1F8D) ; GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
      (#x1F8E #x1F8E) ; GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
      (#x1F8F #x1F8F) ; GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
      (#x1F98 #x1F98) ; GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
      (#x1F99 #x1F99) ; GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
      (#x1F9A #x1F9A) ; GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
      (#x1F9B #x1F9B) ; GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
      (#x1F9C #x1F9C) ; GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
      (#x1F9D #x1F9D) ; GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
      (#x1F9E #x1F9E) ; GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
      (#x1F9F #x1F9F) ; GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
      (#x1FA8 #x1FA8) ; GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
      (#x1FA9 #x1FA9) ; GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
      (#x1FAA #x1FAA) ; GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
      (#x1FAB #x1FAB) ; GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
      (#x1FAC #x1FAC) ; GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
      (#x1FAD #x1FAD) ; GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
      (#x1FAE #x1FAE) ; GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
      (#x1FAF #x1FAF) ; GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
      (#x1FBC #x1FBC) ; GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI
      (#x1FCC #x1FCC) ; GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI
      (#x1FFC #x1FFC) ; GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI
    ))
 
    ;; Alist mapping characters to their single-letter titlecase equivalents
    ;;   when those are distinct from their uppercase equivalents
    (define title-single-map (append titlecase-chars '(
      (#x01C4 #x01C5) ; LATIN CAPITAL LETTER DZ WITH CARON
      (#x01C6 #x01C5) ; LATIN SMALL LETTER DZ WITH CARON
      (#x01C7 #x01C8) ; LATIN CAPITAL LETTER LJ
      (#x01C9 #x01C8) ; LATIN SMALL LETTER LJ
      (#x01CA #x01CB) ; LATIN CAPITAL LETTER NJ
      (#x01CC #x01CB) ; LATIN SMALL LETTER NJ
      (#x01F1 #x01F2) ; LATIN CAPITAL LETTER DZ
      (#x01F3 #x01F2) ; LATIN SMALL LETTER DZ
    )))
 
    ;; Alist mapping characters to their multiple-letter titlecase equivalents
    (define title-multiple-map (append title-single-map '(
      (#x00DF #x0053 #x0073) ; LATIN SMALL LETTER SHARP S
      (#xFB00 #x0046 #x0066) ; LATIN SMALL LIGATURE FF
      (#xFB01 #x0046 #x0069) ; LATIN SMALL LIGATURE FI
      (#xFB02 #x0046 #x006C) ; LATIN SMALL LIGATURE FL
      (#xFB03 #x0046 #x0066 #x0069) ; LATIN SMALL LIGATURE FFI
      (#xFB04 #x0046 #x0066 #x006C) ; LATIN SMALL LIGATURE FFL
      (#xFB05 #x0053 #x0074) ; LATIN SMALL LIGATURE LONG S T
      (#xFB06 #x0053 #x0074) ; LATIN SMALL LIGATURE ST
      (#x0587 #x0535 #x0582) ; ARMENIAN SMALL LIGATURE ECH YIWN
      (#xFB13 #x0544 #x0576) ; ARMENIAN SMALL LIGATURE MEN NOW
      (#xFB14 #x0544 #x0565) ; ARMENIAN SMALL LIGATURE MEN ECH
      (#xFB15 #x0544 #x056B) ; ARMENIAN SMALL LIGATURE MEN INI
      (#xFB16 #x054E #x0576) ; ARMENIAN SMALL LIGATURE VEW NOW
      (#xFB17 #x0544 #x056D) ; ARMENIAN SMALL LIGATURE MEN XEH
      (#x0149 #x02BC #x004E) ; LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
      (#x0390 #x0399 #x0308 #x0301) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
      (#x03B0 #x03A5 #x0308 #x0301) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
      (#x01F0 #x004A #x030C) ; LATIN SMALL LETTER J WITH CARON
      (#x1E96 #x0048 #x0331) ; LATIN SMALL LETTER H WITH LINE BELOW
      (#x1E97 #x0054 #x0308) ; LATIN SMALL LETTER T WITH DIAERESIS
      (#x1E98 #x0057 #x030A) ; LATIN SMALL LETTER W WITH RING ABOVE
      (#x1E99 #x0059 #x030A) ; LATIN SMALL LETTER Y WITH RING ABOVE
      (#x1E9A #x0041 #x02BE) ; LATIN SMALL LETTER A WITH RIGHT HALF RING
      (#x1F50 #x03A5 #x0313) ; GREEK SMALL LETTER UPSILON WITH PSILI
      (#x1F52 #x03A5 #x0313 #x0300) ; GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
      (#x1F54 #x03A5 #x0313 #x0301) ; GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
      (#x1F56 #x03A5 #x0313 #x0342) ; GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
      (#x1FB6 #x0391 #x0342) ; GREEK SMALL LETTER ALPHA WITH PERISPOMENI
      (#x1FC6 #x0397 #x0342) ; GREEK SMALL LETTER ETA WITH PERISPOMENI
      (#x1FD2 #x0399 #x0308 #x0300) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
      (#x1FD3 #x0399 #x0308 #x0301) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA
      (#x1FD6 #x0399 #x0342) ; GREEK SMALL LETTER IOTA WITH PERISPOMENI
      (#x1FD7 #x0399 #x0308 #x0342) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
      (#x1FE2 #x03A5 #x0308 #x0300) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
      (#x1FE3 #x03A5 #x0308 #x0301) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA
      (#x1FE4 #x03A1 #x0313) ; GREEK SMALL LETTER RHO WITH PSILI
      (#x1FE6 #x03A5 #x0342) ; GREEK SMALL LETTER UPSILON WITH PERISPOMENI
      (#x1FE7 #x03A5 #x0308 #x0342) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
      (#x1FF6 #x03A9 #x0342) ; GREEK SMALL LETTER OMEGA WITH PERISPOMENI
      (#x1FB2 #x1FBA #x0345) ; GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
      (#x1FB4 #x0386 #x0345) ; GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
      (#x1FC2 #x1FCA #x0345) ; GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
      (#x1FC4 #x0389 #x0345) ; GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
      (#x1FF2 #x1FFA #x0345) ; GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
      (#x1FF4 #x038F #x0345) ; GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
      (#x1FB7 #x0391 #x0342 #x0345) ; GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
      (#x1FC7 #x0397 #x0342 #x0345) ; GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
      (#x1FF7 #x03A9 #x0342 #x0345) ; GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
    )))
 
    ;; Alist mapping characters to their multiple-character lowercase equivalents
    (define lower-multiple-map '(
      (#x0130 #x0069 #x0307) ; LATIN CAPITAL LETTER I WITH DOT ABOVE
    ))
  )
 
  (begin
    ;;;; Implementation of SRFI 129 titlecase functions
 
    ;; Returns #t if argument is a titlecase character, #f if not
    (define (char-title-case? ch)
      (let* ((codepoint (char->integer ch))
             (result (assq codepoint titlecase-chars)))
        (if result #t #f)))
 
    ;; Returns the single-character titlecase mapping of argument
    (define (char-titlecase ch)
      (let* ((codepoint (char->integer ch))
             (result (assq codepoint title-single-map)))
        (if result
            (integer->char (cadr result))
            (char-upcase ch))))
 
    ;; Returns #t if a character is caseless, otherwise #f
    (define (char-caseless? ch)
      (not (or (char-lower-case? ch) (char-upper-case? ch) (char-title-case? ch))))
 
    ;; Push a list onto another list in reverse order
    (define (reverse-push new old)
      (if (null? new)
          old
          (reverse-push (cdr new) (cons (car new) old))))
  )
)

;;; SRFI 132
;;; Sort libraries
;;;
;;; Current Scheme sorting packages are, every one of them, surprisingly bad. This library
;;; provides a full-featured sort toolkit.
;;;
;;; Author of spec: John Cowan
;;; Copyright © 1998-1999 Olin Shivers. All Rights Reserved.
;;;
;;; This code is open-source.
;;; The terms are: You may do as you please with this code, as long as you do not delete
;;; this notice or hold me responsible for any outcome related to its use.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;; 
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 132)

  (export list-sorted?
          list-sort
          list-stable-sort
          list-merge
          list-delete-neighbor-dups
          vector-sorted?
          vector-sort
          vector-sort!
          vector-stable-sort
          vector-stable-sort!
          vector-merge
          vector-merge!
          vector-delete-neighbor-dups
          vector-delete-neighbor-dups!
          vector-find-median
          vector-find-median!
          vector-select
          vector-select!
          vector-separate!)

  (import (except (lispkit base) vector-sort vector-sort!)
          (only (srfi 27) random-integer))
  
  ;;; Delete neighboring duplicate elts
  ;;; 
  ;;; Problem:
  ;;; vector-delete-neighbor-dups pushes N stack frames, where N is the number
  ;;; of elements in the answer vector. This is arguably a very efficient thing
  ;;; to do, but it might blow out on a system with a limited stack but a big
  ;;; heap. We could rewrite this to "chunk" up answers in temp vectors if we
  ;;; push more than a certain number of frames, then allocate a final answer,
  ;;; copying all the chunks into the answer. But it's much more complex code.
  ;;; 
  ;;; Exports:
  ;;; (list-delete-neighbor-dups  = lis) -> list
  ;;; (vector-delete-neighbor-dups  = v [start end]) -> vector
  ;;; (vector-delete-neighbor-dups! = v [start end]) -> end'
  ;;; 
  ;;; These procedures delete adjacent duplicate elements from a list or
  ;;; a vector, using a given element equality procedure. The first or leftmost
  ;;; element of a run of equal elements is the one that survives. The list
  ;;; or vector is not otherwise disordered.
  ;;;
  ;;; These procedures are linear time -- much faster than the O(n^2) general 
  ;;; duplicate-elt deletors that do not assume any "bunching" of elements.
  ;;; If you want to delete duplicate elements from a large list or vector,
  ;;; sort the elements to bring equal items together, then use one of these
  ;;; procedures -- for a total time of O(n lg n).

  (begin
    
    ;;; LIST-DELETE-NEIGHBOR-DUPS
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Below is a simple implementation of the LIST-DELETE-NEIGHBOR-DUPS procedure.
    ;;; RECUR's contract: Strip off any leading X's from LIS, and return that list
    ;;; neighbor-dup-deleted.
    ;;; - Always allocates a fresh list / never shares storage.
    ;;; - Needs N stack frames, if answer is length N.
    
    (define (list-delete-neighbor-dups = lis)
      (if (pair? lis)
          (let ((x0 (car lis)))
            (cons x0 (let recur ((x0 x0) (xs (cdr lis)))
                       (if (pair? xs)
                           (let ((x1  (car xs))
                                 (x2+ (cdr xs)))
                             (if (= x0 x1)
                                 (recur x0 x2+)
                                 (cons x1 (recur x1 x2+))))
                           xs))))
          lis))
     
    (define (vector-delete-neighbor-dups elt= v . maybe-start+end)
      (let ((start (start-arg maybe-start+end))
            (end   (end-arg maybe-start+end v)))
        (if (< start end)
          (let* ((x (vector-ref v start))
                 (ans (let recur ((x x)
                                  (i start)
                                  (j 1))
                        (if (< i end)
                            (let ((y (vector-ref v i))
                                  (nexti (+ i 1)))
                              (if (elt= x y)
                                  (recur x nexti j)
                                  (let ((ansvec (recur y nexti (+ j 1))))
                                        (vector-set! ansvec j y)
                                    ansvec)))
                            (make-vector j)))))
            (vector-set! ans 0 x)
            ans)
          '#())))

    ;;; Packs the surviving elements to the left, in range [start,end'),
    ;;; and returns END'.
    (define (vector-delete-neighbor-dups! elt= v . maybe-start+end)
      (let ((start (start-arg maybe-start+end))
            (end   (end-arg maybe-start+end v)))
        (if (>= start end)
            end
            ;; To eliminate unnecessary copying (read elt i then write the value 
            ;; back at index i), we scan until we find the first dup.
            (let skip ((j start)
                       (vj (vector-ref v start)))
              (let ((j+1 (+ j 1)))
                (if (>= j+1 end)
                    end
                    (let ((vj+1 (vector-ref v j+1)))
                      (if (not (elt= vj vj+1))
                          (skip j+1 vj+1)
                          (let lp2 ((j j)
                                    (vj vj)
                                    (k (+ j 2)))
                            (let lp3 ((k k))
                              (if (>= k end)
                                  (+ j 1)
                                  (let ((vk (vector-ref v k))
                                        (k+1 (+ k 1)))
                                    (if (elt= vj vk)
                                        (lp3 k+1)
                                        (let ((j+1 (+ j 1)))
                                          (vector-set! v j+1 vk)
                                          (lp2 j+1 vk k+1))))))))))))))))
  
  ;;; list merge & list merge-sort
  ;;; 
  ;;; Exports:
  ;;; (list-merge  < lis lis) -> list
  ;;; (list-merge-sort  < lis) -> list
  ;;; 
  ;;; A stable list merge sort of my own device
  ;;; Two variants: pure & destructive
  ;;;
  ;;; This list merge sort is opportunistic (a "natural" sort) -- it exploits
  ;;; existing order in the input set. Instead of recursing all the way down to
  ;;; individual elements, the leaves of the merge tree are maximal contiguous
  ;;; runs of elements from the input list. So the algorithm does very well on
  ;;; data that is mostly ordered, with a best-case time of O(n) when the input
  ;;; list is already completely sorted. In any event, worst-case time is
  ;;; O(n lg n).
  ;;; 
  ;;; The interesting control structure is the combination recursion/iteration
  ;;; of the core GROW function that does an "opportunistic" DFS walk of the
  ;;; merge tree, adaptively subdividing in response to the length of the
  ;;; merges, without requiring any auxiliary data structures beyond the
  ;;; recursion stack. It's actually quite simple -- ten lines of code.

  (begin
    
    ;;; (mlet ((var-list mv-exp) ...) body ...)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; A LET* form that handles multiple values. Move this into the two clients
    ;;; if you don't have a module system handy to restrict its visibility...
    (define-syntax mlet ; Multiple-value LET*
      (syntax-rules ()
        ((mlet ((() exp) rest ...) body ...)
         (begin exp (mlet (rest ...) body ...)))

        ((mlet (((var) exp) rest ...) body ...)
         (let ((var exp)) (mlet (rest ...) body ...)))

        ((mlet ((vars exp) rest ...) body ...)
         (call-with-values (lambda () exp) 
           (lambda vars (mlet (rest ...) body ...))))

        ((mlet () body ...) (begin body ...))))
     
    ;;; (list-merge-sort < lis)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; A natural, stable list merge sort. 
    ;;; - natural: picks off maximal contiguous runs of pre-ordered data.
    ;;; - stable: won't invert the order of equal elements in the input list.

    (define (list-merge-sort elt< lis)

      ;; (getrun lis) -> run runlen rest
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Pick a run of non-decreasing data off of non-empty list LIS. 
      ;; Return the length of this run, and the following list.
      (define (getrun lis)
        (let lp ((ans '())  (i 1)  (prev (car lis))  (xs (cdr lis)))
          (if (pair? xs)
        (let ((x (car xs)))
          (if (elt< x prev) 
        (values (append-reverse ans (cons prev '())) i xs)
        (lp (cons prev ans) (+ i 1) x (cdr xs))))
        (values (append-reverse ans (cons prev '())) i xs))))

      (define (append-reverse rev-head tail)
        (let lp ((rev-head rev-head) (tail tail))
          (if (null-list? rev-head) tail
        (lp (cdr rev-head) (cons (car rev-head) tail)))))

      (define (null-list? l)
        (cond ((pair? l) #f)
        ((null? l) #t)
        (else (error  "argument out of domain" l))))

      ;; (merge a b) -> list
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; List merge -- stably merge lists A (length > 0) & B (length > 0).
      ;; This version requires up to |a|+|b| stack frames.
      (define (merge a b)
        (let recur ((x (car a))
                    (a a)
                    (y (car b)) (b b))
          (if (elt< y x)
              (cons y (let ((b (cdr b))) (if (pair? b) (recur x a (car b) b) a)))
              (cons x (let ((a (cdr a))) (if (pair? a) (recur (car a) a y b) b))))))

      ;; (grow s ls ls2 u lw) -> [a la unused]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; The core routine. Read the next 20 lines of comments & all is obvious.
      ;; - S is a sorted list of length LS > 1.
      ;; - LS2 is some power of two <= LS.
      ;; - U is an unsorted list.
      ;; - LW is a positive integer.
      ;; Starting with S, and taking data from U as needed, produce
      ;; a sorted list of *at least* length LW, if there's enough data
      ;; (LW <= LS + length(U)), or use all of U if not.
      ;;
      ;; GROW takes maximal contiguous runs of data from U at a time;
      ;; it is allowed to return a list *longer* than LW if it gets lucky
      ;; with a long run.
      ;;
      ;; The key idea: If you want a merge operation to "pay for itself," the two
      ;; lists being merged should be about the same length. Remember that.
      ;;
      ;; Returns:
      ;;   - A:      The result list
      ;;   - LA:     The length of the result list
      ;;   - UNUSED: The unused tail of U.

      (define (grow s ls ls2 u lw)	; The core of the sort algorithm.
        (if (or (<= lw ls) (not (pair? u)))	; Met quota or out of data?
      (values s ls u)			; If so, we're done.
      (mlet (((ls2) (let lp ((ls2 ls2))
          (let ((ls2*2 (+ ls2 ls2)))
            (if (<= ls2*2 ls) (lp ls2*2) ls2))))
             ;; LS2 is now the largest power of two <= LS.
             ;; (Just think of it as being roughly LS.)
             ((r lr u2)  (getrun u))			; Get a run, then
             ((t lt u3)  (grow r lr 1 u2 ls2))) 	; grow it up to be T.
        (grow (merge s t) (+ ls lt)	 		; Merge S & T, 
        (+ ls2 ls2) u3 lw))))	     		;   and loop.

      ;; Note: (LENGTH LIS) or any constant guaranteed 
      ;; to be greater can be used in place of INFINITY.
      (if (pair? lis)				; Don't sort an empty list.
          (mlet (((r lr tail)  (getrun lis))	; Pick off an initial run,
           ((infinity)   #o100000000)		; then grow it up maximally.
           ((a la v)     (grow r lr 1 tail infinity)))
      a)
          '()))
    
    ;;; Merge
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; These two merge procedures are stable -- ties favor list A.

    (define (list-merge < a b)
      (cond ((not (pair? a)) b)
            ((not (pair? b)) a)
            (else
              (let recur ((x (car a)) (a a)   ; A is a pair; X = (CAR A).
                          (y (car b)) (b b))  ; B is a pair; Y = (CAR B).
              (if (< y x)
                  (let ((b (cdr b)))
                    (if (pair? b)
                      (cons y (recur x a (car b) b))
                      (cons y a)))
                  (let ((a (cdr a)))
                    (if (pair? a)
                        (cons x (recur (car a) a y b))
                        (cons x b)))))))))
  
  (begin
    (define (list-sorted? < list)
      (or (not (pair? list))
          (let lp ((prev (car list)) (tail (cdr list)))
            (or (not (pair? tail))
                (let ((next (car tail)))
                  (and (not (< next prev)) (lp next (cdr tail))))))))

    (define (vector-sorted? elt< v . maybe-start+end)
      (let ((start (start-arg maybe-start+end))
            (end   (end-arg maybe-start+end v)))
        (or (>= start end)			; Empty range
            (let lp ((i (+ start 1)) (vi-1 (vector-ref v start)))
              (or (>= i end)
                  (let ((vi (vector-ref v i)))
                    (and (not (elt< vi vi-1)) (lp (+ i 1) vi)))))))))
  
  (begin
    (define (vector-portion-copy vec start end)
      (let* ((len (vector-length vec))
             (new-len (- end start))
             (new (make-vector new-len)))
        (do ((i start (+ i 1))
             (j 0 (+ j 1)))
            ((= i end) new)
          (vector-set! new j (vector-ref vec i)))))

    (define (vector-portion-copy! target src start end)
      (let ((len (- end start)))
        (do ((i (- len 1) (- i 1))
             (j (- end 1) (- j 1)))
            ((< i 0))
          (vector-set! target i (vector-ref src j)))))

    (define (start-arg args)
      (if (pair? args) (car args) 0))

    (define (end-arg args v)
      (if (and (pair? args) (pair? (cdr args))) (cadr args) (vector-length v)))

    (define (has-element list index)
      (cond ((zero? index)
              (if (pair? list)
                  (values #t (car list))
                  (values #f #f)))
            ((null? list)
              (values #f #f))
            (else
              (has-element (cdr list) (- index 1)))))

    (define (list-ref-or-default list index default)
      (call-with-values
        (lambda () (has-element list index))
        (lambda (has? maybe) (if has? maybe default))))

    (define (vectors-start+end-2 vector-1 vector-2 maybe-start+end)
      (let ((start-1 (list-ref-or-default maybe-start+end 0 0))
            (end-1   (list-ref-or-default maybe-start+end 1 (vector-length vector-1)))
            (start-2 (list-ref-or-default maybe-start+end 2 0))
            (end-2   (list-ref-or-default maybe-start+end 3 (vector-length vector-2))))
        (values start-1 end-1 start-2 end-2))))
  
  (begin
    ;;; Two key facts
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; If a heap structure is embedded into a vector at indices [start,end), then:
    ;;;   1. The two children of index k are start + 2*(k-start) + 1 = k*2-start+1
    ;;;                                  and start + 2*(k-start) + 2 = k*2-start+2.
    ;;;
    ;;;   2. The first index of a leaf node in the range [start,end) is
    ;;;          first-leaf = floor[(start+end)/2]
    ;;;      (You can deduce this from fact #1 above.) 
    ;;;      Any index before FIRST-LEAF is an internal node.

    (define (really-vector-heap-sort! elt< v start end)
      ;; Vector V contains a heap at indices [START,END). The heap is in heap
      ;; order in the range (I,END) -- i.e., every element in this range is >=
      ;; its children. Bubble HEAP[I] down into the heap to impose heap order on
      ;; the range [I,END).
      (let ((restore-heap!
              (lambda (end i)
                (let* ((vi (vector-ref v i))
                       (first-leaf (quotient (+ start end) 2))
                       (final-k (let lp ((k i))
                                  (if (>= k first-leaf)
                                      k	 ; Leaf, so done.
                                      (let* ((k*2-start (+ k (- k start)))
                                             (child1 (+ 1 k*2-start))
                                             (child2 (+ 2 k*2-start))
                                             (child1-val (vector-ref v child1)))
                                        (call-with-values
                                          (lambda ()
                                            (if (< child2 end)
                                                (let ((child2-val (vector-ref v child2)))
                                                  (if (elt< child2-val child1-val)
                                                      (values child1 child1-val)
                                                      (values child2 child2-val)))
                                                (values child1 child1-val)))
                                          (lambda (max-child max-child-val)
                                            (cond ((elt< vi max-child-val)
                                                    (vector-set! v k max-child-val)
                                                    (lp max-child))
                                                  (else k)))))))))
                  (vector-set! v final-k vi))))
            (first-leaf (quotient (+ start end) 2)))
        (do ((i (- first-leaf 1) (- i 1)))
            ((< i start))
          (restore-heap! end i))
        (do ((i (- end 1) (- i 1)))
            ((<= i start))
          (let ((top (vector-ref v start)))
            (vector-set! v start (vector-ref v i))
            (vector-set! v i top)
            (restore-heap! i start)))))

    ;;; Here are the two exported interfaces.

    (define (vector-heap-sort! elt< v . maybe-start+end)
      (let ((start (start-arg maybe-start+end))
            (end   (end-arg maybe-start+end v)))
        (really-vector-heap-sort! elt< v start end)))

    (define (vector-heap-sort elt< v . maybe-start+end)
      (let* ((start (start-arg maybe-start+end))
             (end   (end-arg maybe-start+end v))
             (ans (vector-portion-copy v start end)))
        (really-vector-heap-sort! elt< ans 0 (- end start))
        ans))

    ;;; Notes on porting
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; 
    ;;; Bumming the code for speed
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; If you can use a module system to lock up the internal function
    ;;; REALLY-VECTOR-HEAP-SORT! so that it can only be called from VECTOR-HEAP-SORT and
    ;;; VECTOR-HEAP-SORT!, then you can hack the internal functions to run with no safety
    ;;; checks. The safety checks performed by the exported functions VECTOR-HEAP-SORT &
    ;;; VECTOR-HEAP-SORT! guarantee that there will be no type errors or array-indexing
    ;;; errors. In addition, with the exception of the two computations of
    ;;; FIRST-LEAF, all arithmetic will be fixnum arithmetic that never overflows
    ;;; into bignums, assuming your Scheme provides that you can't allocate an
    ;;; array so large you might need a bignum to index an element, which is
    ;;; definitely the case for every implementation with which I am familiar. 
    ;;;
    ;;; If you want to code up the first-leaf = (quotient (+ s e) 2) computation
    ;;; so that it will never fixnum overflow when S & E are fixnums, you can do
    ;;; it this way:
    ;;;   - compute floor(e/2), which throws away e's low-order bit.
    ;;;   - add e's low-order bit to s, and divide that by two:
    ;;;     floor[(s + e mod 2) / 2]
    ;;;   - add these two parts together.
    ;;; giving you
    ;;;   (+ (quotient e 2)
    ;;;      (quotient (+ s (modulo e 2)) 2))
    ;;; If we know that e & s are fixnums, and that 0 <= s <= e, then this
    ;;; can only fixnum-overflow when s = e = max-fixnum. Note that the
    ;;; two divides and one modulo op can be done very quickly with two 
    ;;; right-shifts and a bitwise and.
    ;;;
    ;;; I suspect there has never been a heapsort written in the history of
    ;;; the world in C that got this detail right.
    ;;;
    ;;; If your Scheme has a faster mechanism for handling optional arguments
    ;;; (e.g., Chez), you should definitely port over to it. Note that argument
    ;;; defaulting and error-checking are interleaved -- you don't have to
    ;;; error-check defaulted START/END args to see if they are fixnums that are
    ;;; legal vector indices for the corresponding vector, etc.
  )
  
  (begin
    (define (vector-insert-sort elt< v . maybe-start+end)
      (let* ((start (start-arg maybe-start+end))
             (end   (end-arg maybe-start+end v))
             (ans   (vector-portion-copy v start end)))
        (%vector-insert-sort! elt< ans 0 (- end start))
        ans))

    (define (vector-insert-sort! < v . maybe-start+end)
      (let ((start (start-arg maybe-start+end))
            (end   (end-arg maybe-start+end v)))
        (%vector-insert-sort! < v start end)))

    (define (%vector-insert-sort! elt< v start end)
      (do ((i (+ 1 start) (+ i 1)))    ; Invariant: [start,i) is sorted.
          ((>= i end))
        (let ((val (vector-ref v i)))
          (vector-set! v
                       (let lp ((j i))        ; J is the location of the
                         (if (<= j start)
                             start    ; "hole" as it bubbles down.
                             (let* ((j-1 (- j 1))
                                    (vj-1 (vector-ref v j-1)))
                               (cond ((elt< val vj-1)
                                       (vector-set! v j vj-1)
                                       (lp j-1))
                                     (else j)))))
                       val))))
    
    ;;; Code tuning & porting
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; This code is tightly bummed as far as I can go in portable Scheme.
    ;;; 
    ;;; The code can be converted to use unsafe vector-indexing and
    ;;; fixnum-specific arithmetic ops -- the safety checks done on entry
    ;;; to VECTOR-INSERT-SORT and VECTOR-INSERT-SORT! are sufficient to
    ;;; guarantee nothing bad will happen. However, note that if you alter
    ;;; %VECTOR-INSERT-SORT! to use dangerous primitives, you must ensure
    ;;; it is only called from clients that guarantee to observe its
    ;;; preconditions. In the implementation, %VECTOR-INSERT-SORT! is only
    ;;; called from VECTOR-INSERT-SORT! and the quick-sort code in
    ;;; vqsort.scm, and the preconditions are guaranteed for these two
    ;;; clients.  This should provide *big* speedups. In fact, all the
    ;;; code bumming I've done pretty much disappears in the noise unless
    ;;; you have a good compiler and also can dump the vector-index checks
    ;;; and generic arithmetic -- so I've really just set things up for
    ;;; you to exploit.
    ;;;
    ;;; If your Scheme has a faster mechanism for handling optional arguments
    ;;; (e.g., Chez), you should definitely port over to it. Note that argument
    ;;; defaulting and error-checking are interleaved -- you don't have to
    ;;; error-check defaulted START/END args to see if they are fixnums that are
    ;;; legal vector indices for the corresponding vector, etc.
  )
  
  (begin
    ;;; Merge
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; (vector-merge < v1 v2 [start1 end1 start2 end2]) -> vector
    ;;; (vector-merge! < v v1 v2 [start start1 end1 start2 end2]) -> unspecific
    ;;;
    ;;; Stable vector merge -- V1's elements come out ahead of equal V2 elements.

    (define (vector-merge < v1 v2 . maybe-starts+ends)
      (call-with-values
        (lambda () (vectors-start+end-2 v1 v2 maybe-starts+ends))
        (lambda (start1 end1 start2 end2)
          (let ((ans (make-vector (+ (- end1 start1) (- end2 start2)))))
            (%vector-merge! < ans v1 v2 0 start1 end1 start2 end2)
            ans))))

    (define (vector-merge! < v v1 v2 . maybe-starts+ends)
      (call-with-values
        (lambda () (if (pair? maybe-starts+ends)
                       (values (car maybe-starts+ends) (cdr maybe-starts+ends))
                       (values 0 '())))
        (lambda (start rest)
          (call-with-values
            (lambda () (vectors-start+end-2 v1 v2 rest))
            (lambda (start1 end1 start2 end2)
              (%vector-merge! < v v1 v2 start start1 end1 start2 end2))))))

    ;;; This routine is not exported. The code is tightly bummed.
    ;;;
    ;;; If these preconditions hold, the routine can be bummed to run with 
    ;;; unsafe vector-indexing and fixnum arithmetic ops:
    ;;;   - V V1 V2 are vectors.
    ;;;   - START START1 END1 START2 END2 are fixnums.
    ;;;   - (<= 0 START END0 (vector-length V),
    ;;;     where end0 = start + (end1 - start1) + (end2 - start2)
    ;;;   - (<= 0 START1 END1 (vector-length V1))
    ;;;   - (<= 0 START2 END2 (vector-length V2))
    ;;; If you put these error checks in the two client procedures above, you can
    ;;; safely convert this procedure to use unsafe ops -- which is why it isn't
    ;;; exported. This will provide *huge* speedup.

    (define (%vector-merge! elt< v v1 v2 start start1 end1 start2 end2)
      (letrec ((vblit (lambda (fromv j i end)
                        (let lp ((j j)
                                 (i i))
                          (vector-set! v i (vector-ref fromv j))
                          (let ((j (+ j 1)))
                            (if (< j end) (lp j (+ i 1))))))))
        (cond ((<= end1 start1) (if (< start2 end2) (vblit v2 start2 start end2)))
              ((<= end2 start2) (vblit v1 start1 start end1))
              (else (let lp ((i start)
                             (j start1)
                             (x (vector-ref v1 start1))
                             (k start2)
                             (y (vector-ref v2 start2)))
                      (let ((i1 (+ i 1)))    ; "i+1" is a complex number in R4RS!
                        (if (elt< y x)
                            (let ((k (+ k 1)))
                              (vector-set! v i y)
                              (if (< k end2)
                                  (lp i1 j x k (vector-ref v2 k))
                                  (vblit v1 j i1 end1)))
                            (let ((j (+ j 1)))
                              (vector-set! v i x)
                              (if (< j end1)
                                  (lp i1 j (vector-ref v1 j) k y)
                                  (vblit v2 k i1 end2))))))))))

    ;;; (vector-merge-sort  < v [start end temp]) -> vector
    ;;; (vector-merge-sort! < v [start end temp]) -> unspecific
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Stable natural vector merge sort

    (define (vector-merge-sort! < v . maybe-args)
      (let ((start (start-arg maybe-args))
            (end   (end-arg maybe-args v))
            (temp  (if (and (pair? maybe-args)
                            (pair? (cdr maybe-args))
                            (pair? (cddr maybe-args)))
                       (caddr maybe-args)
                       (vector-portion-copy v 0 (vector-length v)))))
        (%vector-merge-sort! < v start end temp)))

    (define (vector-merge-sort < v . maybe-args)
      (let* ((start (start-arg maybe-args))
             (end   (end-arg maybe-args v))
             (ans   (vector-copy v start end)))
        (vector-merge-sort! < ans)
        ans))
    
    ;;; %VECTOR-MERGE-SORT! is not exported.
    ;;; Preconditions:
    ;;;   V TEMP vectors
    ;;;   START END fixnums
    ;;;   START END legal indices for V and TEMP
    ;;; If these preconditions are ensured by the cover functions, you
    ;;; can safely change this code to use unsafe fixnum arithmetic and vector
    ;;; indexing ops, for *huge* speedup.

    ;;; This merge sort is "opportunistic" -- the leaves of the merge tree are
    ;;; contiguous runs of already sorted elements in the vector. In the best
    ;;; case -- an already sorted vector -- it runs in linear time. Worst case
    ;;; is still O(n lg n) time.

    (define (%vector-merge-sort! elt< v0 l r temp0)
      (define (xor a b) (not (eq? a b)))

      ;; Merge v1[l,l+len1) and v2[l+len1,l+len1+len2) into target[l,l+len1+len2)
      ;; Merge left-to-right, so that TEMP may be either V1 or V2
      ;; (that this is OK takes a little bit of thought).
      ;; V2=TARGET? is true if V2 and TARGET are the same, which allows
      ;; merge to punt the final blit half of the time.
  
      (define (merge target v1 v2 l len1 len2 v2=target?)
        (letrec ((vblit (lambda (fromv j i end)    ; Blit FROMV[J,END) to TARGET[I,?]
                  (let lp ((j j) (i i))    ; J < END. The final copy.
                (vector-set! target i (vector-ref fromv j))
                (let ((j (+ j 1)))
                  (if (< j end) (lp j (+ i 1))))))))
  
          (let* ((r1 (+ l  len1))
             (r2 (+ r1 len2)))
                                ; Invariants:
        (let lp ((n l)                    ; N is next index of 
             (j l)   (x (vector-ref v1 l))        ;   TARGET to write.   
             (k r1)  (y (vector-ref v2 r1)))    ; X = V1[J]          
          (let ((n+1 (+ n 1)))                ; Y = V2[K]          
            (if (elt< y x)
            (let ((k (+ k 1)))
              (vector-set! target n y)
              (if (< k r2)
                  (lp n+1 j x k (vector-ref v2 k))
                  (vblit v1 j n+1 r1)))
            (let ((j (+ j 1)))
              (vector-set! target n x)
              (if (< j r1)
                  (lp n+1 j (vector-ref v1 j) k y)
                  (if (not v2=target?) (vblit v2 k n+1 r2))))))))))
  

      ;; Might hack GETRUN so that if the run is short it pads it out to length
      ;; 10 with insert sort...
  
      ;; Precondition: l < r.
      (define (getrun v l r)
        (let lp ((i (+ l 1))  (x (vector-ref v l)))
          (if (>= i r)
          (- i l)
          (let ((y (vector-ref v i)))
            (if (elt< y x)
            (- i l)
            (lp (+ i 1) y))))))
  
      ;; RECUR: Sort V0[L,L+LEN) for some LEN where 0 < WANT <= LEN <= (R-L).
      ;;   That is, sort *at least* WANT elements in V0 starting at index L.
      ;;   May put the result into either V0[L,L+LEN) or TEMP0[L,L+LEN).
      ;;   Must not alter either vector outside this range.
      ;;   Return:
      ;;     - LEN -- the number of values we sorted
      ;;     - ANSVEC -- the vector holding the value
      ;;     - ANS=V0? -- tells if ANSVEC is V0 or TEMP
      ;;
      ;; LP: V[L,L+PFXLEN) holds a sorted prefix of V0.
      ;;     TEMP = if V = V0 then TEMP0 else V0. (I.e., TEMP is the other vec.)
      ;;     PFXLEN2 is a power of 2 <= PFXLEN.
      ;;     Solve RECUR's problem.
      (if (< l r) ; Don't try to sort an empty range.
          (call-with-values
           (lambda ()
         (let recur ((l l) (want (- r l)))
           (let ((len (- r l)))
             (let lp ((pfxlen (getrun v0 l r)) (pfxlen2 1)
                  (v v0) (temp temp0)
                  (v=v0? #t))
               (if (or (>= pfxlen want) (= pfxlen len))
               (values pfxlen v v=v0?)
               (let ((pfxlen2 (let lp ((j pfxlen2))
                        (let ((j*2 (+ j j)))
                          (if (<= j pfxlen) (lp j*2) j))))
                 (tail-len (- len pfxlen)))
                 ;; PFXLEN2 is now the largest power of 2 <= PFXLEN.
                 ;; (Just think of it as being roughly PFXLEN.)
                 (call-with-values
                  (lambda ()
                (recur (+ pfxlen l) pfxlen2))
                  (lambda (nr-len nr-vec nrvec=v0?)
                (merge temp v nr-vec l pfxlen nr-len
                       (xor nrvec=v0? v=v0?))
                (lp (+ pfxlen nr-len) (+ pfxlen2 pfxlen2)
                    temp v (not v=v0?))))))))))
           (lambda (ignored-len ignored-ansvec ansvec=v0?)
         (if (not ansvec=v0?)
                 (vector-copy! v0 l temp0 l r))))))

    ;;; Code tuning & porting
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; This code is *tightly* bummed as far as I can go in portable Scheme.
    ;;;
    ;;; The two internal primitives that do the real work can be converted to
    ;;; use unsafe vector-indexing and fixnum-specific arithmetic ops *if* you
    ;;; alter the four small cover functions to enforce the invariants. This should
    ;;; provide *big* speedups. In fact, all the code bumming I've done pretty
    ;;; much disappears in the noise unless you have a good compiler and also
    ;;; can dump the vector-index checks and generic arithmetic -- so I've really
    ;;; just set things up for you to exploit.
    ;;;
    ;;; The optional-arg parsing, defaulting, and error checking is done with a
    ;;; portable R4RS macro. But if your Scheme has a faster mechanism (e.g., 
    ;;; Chez), you should definitely port over to it. Note that argument defaulting
    ;;; and error-checking are interleaved -- you don't have to error-check 
    ;;; defaulted START/END args to see if they are fixnums that are legal vector
    ;;; indices for the corresponding vector, etc.
  )
  
  (begin
    ;;; (quick-sort  < v [start end]) -> vector
    ;;; (quick-sort! < v [start end]) -> unspecific
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; The algorithm is a standard quicksort, but the partition loop is fancier,
    ;;; arranging the vector into a left part that is <, a middle region that is
    ;;; =, and a right part that is > the pivot. Here's how it is done:
    ;;;   The partition loop divides the range being partitioned into five 
    ;;;   subranges:
    ;;;       =======<<<<<<<<<?????????>>>>>>>=======
    ;;;   where = marks a value that is equal the pivot, < marks a value that
    ;;;   is less than the pivot, ? marks a value that hasn't been scanned, and
    ;;;   > marks a value that is greater than the pivot. Let's consider the 
    ;;;   left-to-right scan. If it checks a ? value that is <, it keeps scanning.
    ;;;   If the ? value is >, we stop the scan -- we are ready to start the
    ;;;   right-to-left scan and then do a swap. But if the rightward scan checks 
    ;;;   a ? value that is =, we swap it *down* to the end of the initial chunk
    ;;;   of ====='s -- we exchange it with the leftmost < value -- and then
    ;;;   continue our rightward scan. The leftwards scan works in a similar 
    ;;;   fashion, scanning past > elements, stopping on a < element, and swapping
    ;;;   up = elements. When we are done, we have a picture like this
    ;;;       ========<<<<<<<<<<<<>>>>>>>>>>=========
    ;;;   Then swap the = elements up into the middle of the vector to get
    ;;;   this:
    ;;;       <<<<<<<<<<<<=================>>>>>>>>>>
    ;;;   Then recurse on the <'s and >'s. Work out all the tricky little
    ;;;   boundary cases, and you're done.
    ;;;
    ;;; Other tricks:
    ;;; - This quicksort also makes some effort to pick the pivot well -- it uses
    ;;;   the median of three elements as the partition pivot, so pathological n^2
    ;;;   run time is much rarer (but not eliminated completely). If you really
    ;;;   wanted to get fancy, you could use a random number generator to choose
    ;;;   pivots. The key to this trick is that you only need to pick one random
    ;;;   number for each *level* of recursion -- i.e. you only need (lg n) random
    ;;;   numbers. 
    ;;; - After the partition, we *recurse* on the smaller of the two pending
    ;;;   regions, then *tail-recurse* (iterate) on the larger one. This guarantees
    ;;;   we use no more than lg(n) stack frames, worst case.
    ;;; - There are two ways to finish off the sort.
    ;;;   A Recurse down to regions of size 10, then sort each such region using
    ;;;     insertion sort.
    ;;;   B Recurse down to regions of size 10, then sort *the entire vector*
    ;;;     using insertion sort.
    ;;;   We do A. Each choice has a cost. Choice A has more overhead to invoke
    ;;;   all the separate insertion sorts -- choice B only calls insertion sort
    ;;;   once. But choice B will call the comparison function *more times* --
    ;;;   it will unnecessarily compare elt 9 of one segment to elt 0 of the
    ;;;   following segment. The overhead of choice A is linear in the length
    ;;;   of the vector, but *otherwise independent of the algorithm's parameters*.
    ;;;   I.e., it's a *fixed*, *small* constant factor. The cost of the extra 
    ;;;   comparisons made by choice B, however, is dependent on an externality: 
    ;;;   the comparison function passed in by the client. This can be made 
    ;;;   arbitrarily bad -- that is, the constant factor *isn't* fixed by the
    ;;;   sort algorithm; instead, it's determined by the comparison function.
    ;;;   If your comparison function is very, very slow, you want to eliminate
    ;;;   every single one that you can. Choice A limits the potential badness, 
    ;;;   so that is what we do.

    (define (vector-quick-sort! < v . maybe-start+end)
      (let ((start (start-arg maybe-start+end))
            (end   (end-arg maybe-start+end v)))
        (%quick-sort! < v start end)))

    (define (vector-quick-sort < v . maybe-start+end)
      (let* ((start (start-arg maybe-start+end))
             (end   (end-arg maybe-start+end v))
             (ans   (make-vector (- end start))))
        (vector-portion-copy! ans v start end)
        (%quick-sort! < ans 0 (- end start))
        ans))

    ;;; %QUICK-SORT is not exported.
    ;;; Preconditions:
    ;;;   V vector
    ;;;   START END fixnums
    ;;;   0 <= START, END <= (vector-length V)
    ;;; If these preconditions are ensured by the cover functions, you
    ;;; can safely change this code to use unsafe fixnum arithmetic and vector
    ;;; indexing ops, for *huge* speedup.
    ;;;
    ;;; We bail out to insertion sort for small ranges; feel free to tune the
    ;;; crossover -- it's just a random guess. If you don't have the insertion
    ;;; sort routine, just kill that branch of the IF and change the recursion
    ;;; test to (< 1 (- r l)) -- the code is set up to work that way.
    
    (define (%quick-sort! elt< v start end)
      ;; Swap the N outer pairs of the range [l,r)
      (define (swap l r n)
        (if (> n 0)
            (let ((x (vector-ref v l))
                  (r-1 (- r 1)))
              (vector-set! v l (vector-ref v r-1))
              (vector-set! v r-1 x)
              (swap (+ l 1) r-1 (- n 1)))))
      ;; Choose the median of V[l], V[r], and V[middle] for the pivot.
      (define (median v1 v2 v3)
        (call-with-values
          (lambda () (if (elt< v1 v2) (values v1 v2) (values v2 v1)))
          (lambda (little big)
            (if (elt< big v3)
                big
                (if (elt< little v3) v3 little)))))
      (let recur ((l start)
                  (r end))         ; Sort the range [l,r).
        (if (< 10 (- r l))         ; Ten: the gospel according to Sedgewick.
            (let ((pivot (median (vector-ref v l)
                         (vector-ref v (quotient (+ l r) 2))
                         (vector-ref v (- r 1)))))

              ;; Everything in these loops is driven by the invariants expressed
              ;; in the little pictures & the corresponding l,i,j,k,m,r indices
              ;; and the associated ranges.

              ;; =======<<<<<<<<<?????????>>>>>>>=======
              ;; l      i        j       k      m       r
              ;; [l,i)  [i,j)      [j,k]    (k,m]  (m,r)
              (letrec ((lscan (lambda (i j k m) ; left-to-right scan
                         (let lp ((i i)
                                  (j j))
                           (if (> j k)
                           (done i j m)
                           (let ((x (vector-ref v j)))
                             (cond ((elt< x pivot) (lp i (+ j 1)))
                                   ((elt< pivot x) (rscan i j k m))
                                   (else ; Equal
                                    (if (< i j)
                                        (begin (vector-set! v j (vector-ref v i))
                                           (vector-set! v i x)))
                                    (lp (+ i 1) (+ j 1)))))))))

                       ;; =======<<<<<<<<<>????????>>>>>>>=======
                       ;; l      i        j       k      m       r
                       ;; [l,i)  [i,j)    j (j,k]    (k,m]  (m,r)
                       (rscan (lambda (i j k m) ; right-to-left scan
                         (let lp ((k k) (m m))    
                           (if (<= k j)
                           (done i j m)
                           (let* ((x (vector-ref v k)))
                             (cond ((elt< pivot x) (lp (- k 1) m))

                               ((elt< x pivot) ; Swap j & k & lscan.
                                (vector-set! v k (vector-ref v j))
                                (vector-set! v j x)
                                (lscan i (+ j 1) (- k 1) m))

                               (else    ; x=pivot
                                (if (< k m)
                                    (begin (vector-set! v k (vector-ref v m))
                                       (vector-set! v m x)))
                                (lp (- k 1) (- m 1)))))))))

                       ;; =======<<<<<<<<<<<<<>>>>>>>>>>>=======
                       ;; l      i            j         m       r
                       ;; [l,i)  [i,j)        [j,m]        (m,r)
                       (done (lambda (i j m)
                         (let ((num< (- j i))
                               (num> (+ 1 (- m j)))
                               (num=l (- i l))
                               (num=r (- (- r m) 1)))
                           (swap l j (min num< num=l)) ; Swap ='s into
                           (swap j r (min num> num=r)) ; the middle.
                           ;; Recur on the <'s and >'s. Recurring on the
                           ;; smaller range and iterating on the bigger 
                           ;; range ensures O(lg n) stack frames, worst case.
                           (cond ((<= num< num>)
                                   (recur l          (+ l num<))
                                   (recur (- r num>) r))
                                 (else
                                   (recur (- r num>) r)
                                   (recur l          (+ l num<))))))))
                (let ((r-1 (- r 1)))
                  (lscan l l r-1 r-1))))
            ;; Small segment => punt to insert sort.
            ;; Use the dangerous subprimitive.
            (%vector-insert-sort! elt< v l r)))))
  
  (begin
    (define (list-sort < l)			    ; Sort lists by converting to a vector and sorting that.
      (let ((v (list->vector l)))
        (vector-heap-sort! < v)
        (vector->list v)))

    (define list-stable-sort  list-merge-sort)

    (define vector-sort  vector-quick-sort)
    (define vector-sort! vector-quick-sort!)

    (define vector-stable-sort  vector-merge-sort)
    (define vector-stable-sort! vector-merge-sort!))
  
  (begin
    (define (vector-find-median < v knil . rest)
      (let* ((mean (if (null? rest)
                       (lambda (a b) (/ (+ a b) 2))
                       (car rest)))
             (n (vector-length v)))
        (cond ((zero? n) knil)
              ((odd? n) (%vector-select < v (quotient n 2) 0 n))
              (else
                (call-with-values
                  (lambda () (%vector-select2 < v (- (quotient n 2) 1) 0 n))
                  (lambda (a b) (mean a b)))))))

    ;;; For this procedure, the SRFI 132 specification demands the vector be sorted
    ;;; (by side effect).

    (define (vector-find-median! < v knil . rest)
      (let* ((mean (if (null? rest)
                       (lambda (a b) (/ (+ a b) 2))
                       (car rest)))
             (n (vector-length v)))
        (vector-sort! < v)
        (cond ((zero? n) knil)
              ((odd? n) (vector-ref v (quotient n 2)))
              (else
                (mean (vector-ref v (- (quotient n 2) 1)) (vector-ref v (quotient n 2)))))))

    ;;; SRFI 132 says this procedure runs in O(n) time.
    ;;; As implemented, however, the worst-case time is O(n^2).
    ;;; The average time is O(n), and you'd have to be unlucky
    ;;; to approach the worst case.
    ;;;
    ;;; After rest argument processing, calls the private version defined below.

    (define (vector-select < v k . rest)
      (let* ((start (if (null? rest) 0 (car rest)))
             (end (if (and (pair? rest) (pair? (cdr rest)))
                      (car (cdr rest))
                      (vector-length v))))
        (%vector-select < v k start end)))

    ;;; The vector-select procedure is needed internally to implement
    ;;; vector-find-median, but SRFI 132 has been changed (for no good
    ;;; reason) to export vector-select! instead of vector-select.
    ;;; Fortunately, vector-select! is not required to have side effects.

    (define vector-select! vector-select)

    ;;; This could be made slightly more efficient, but who cares?

    (define (vector-separate! < v k . rest)
      (let* ((start (if (null? rest)
                        0
                        (car rest)))
             (end   (if (and (pair? rest) (pair? (cdr rest)))
                        (car (cdr rest))
                        (vector-length v))))
        (if (and (> k 0) (> end start))
            (let ((pivot (vector-select < v (- k 1) start end)))
              (call-with-values
                (lambda () (count-smaller < pivot v start end 0 0))
                (lambda (count count2)
                  (let* ((v2 (make-vector count))
                         (v3 (make-vector (- end start count count2))))
                    (copy-smaller! < pivot v2 0 v start end)
                    (copy-bigger! < pivot v3 0 v start end)
                    (vector-copy! v start v2)
                    (vector-fill! v pivot (+ start count) (+ start count count2))
                    (vector-copy! v (+ start count count2) v3))))))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; For small ranges, sorting may be the fastest way to find the kth element.
    ;;; This threshold is not at all critical, and may not even be worthwhile.

    (define just-sort-it-threshold 50)

    ;;; Given
    ;;;     an irreflexive total order <?
    ;;;     a vector v
    ;;;     an index k
    ;;;     an index start
    ;;;     an index end
    ;;; with
    ;;;     0 <= k < (- end start)
    ;;;     0 <= start < end <= (vector-length v)
    ;;; returns
    ;;;     (vector-ref (vector-sort <? (vector-copy v start end)) (+ start k))
    ;;; but is usually faster than that.

    (define (%vector-select <? v k start end)
      (assert (and 'vector-select
                   (procedure? <?)
                   (vector? v)
                   (exact-integer? k)
                   (exact-integer? start)
                   (exact-integer? end)
                   (<= 0 k (- end start 1))
                   (<= 0 start end (vector-length v))))
      (%%vector-select <? v k start end))

    ;;; Given
    ;;;     an irreflexive total order <?
    ;;;     a vector v
    ;;;     an index k
    ;;;     an index start
    ;;;     an index end
    ;;; with
    ;;;     0 <= k < (- end start 1)
    ;;;     0 <= start < end <= (vector-length v)
    ;;; returns two values:
    ;;;     (vector-ref (vector-sort <? (vector-copy v start end)) (+ start k))
    ;;;     (vector-ref (vector-sort <? (vector-copy v start end)) (+ start k 1))
    ;;; but is usually faster than that.

    (define (%vector-select2 <? v k start end)
      (assert (and 'vector-select
                   (procedure? <?)
                   (vector? v)
                   (exact-integer? k)
                   (exact-integer? start)
                   (exact-integer? end)
                   (<= 0 k (- end start 1 1))
                   (<= 0 start end (vector-length v))))
      (%%vector-select2 <? v k start end))

    ;;; Like %vector-select, but its preconditions have been checked.

    (define (%%vector-select <? v k start end)
      (let ((size (- end start)))
        (cond ((= 1 size) (vector-ref v (+ k start)))
              ((= 2 size) (if (<? (vector-ref v start) (vector-ref v (+ start 1)))
                              (vector-ref v (+ k start))
                              (vector-ref v (+ (- 1 k) start))))
              ((< size just-sort-it-threshold)
                (vector-ref (vector-sort <? (vector-copy v start end)) k))
              (else
                (let* ((ip (random-integer size))
                       (pivot (vector-ref v (+ start ip))))
                  (call-with-values
                    (lambda () (count-smaller <? pivot v start end 0 0))
                    (lambda (count count2)
                      (cond ((< k count)
                               (let* ((n count)
                                      (v2 (make-vector n)))
                                 (copy-smaller! <? pivot v2 0 v start end)
                                 (%%vector-select <? v2 k 0 n)))
                            ((< k (+ count count2))
                               pivot)
                            (else
                              (let* ((n (- size count count2))
                                     (v2 (make-vector n))
                                     (k2 (- k count count2)))
                                (copy-bigger! <? pivot v2 0 v start end)
                                (%%vector-select <? v2 k2 0 n)))))))))))

    ;;; Like %%vector-select, but returns two values:
    ;;;
    ;;;     (vector-ref (vector-sort <? (vector-copy v start end)) (+ start k))
    ;;;     (vector-ref (vector-sort <? (vector-copy v start end)) (+ start k 1))
    ;;;
    ;;; Returning two values is useful when finding the median of an even
    ;;; number of things.

    (define (%%vector-select2 <? v k start end)
      (let ((size (- end start)))
        (cond ((= 2 size)
                 (let ((a (vector-ref v start))
                       (b (vector-ref v (+ start 1))))
                   (if (<? a b)
                       (values a b))
                       (values b a)))
              ((< size just-sort-it-threshold)
                 (let ((v2 (vector-sort <? (vector-copy v start end))))
                   (values (vector-ref v2 k) (vector-ref v2 (+ k 1)))))
              (else
                (let* ((ip (random-integer size))
                       (pivot (vector-ref v (+ start ip))))
                  (call-with-values
                    (lambda () (count-smaller <? pivot v start end 0 0))
                    (lambda (count count2)
                      (cond ((= (+ k 1) count)
                               (values (%%vector-select <? v k start end) pivot))
                            ((< k count)
                              (let* ((n count)
                                     (v2 (make-vector n)))
                                (copy-smaller! <? pivot v2 0 v start end)
                                (%%vector-select2 <? v2 k 0 n)))
                            ((< k (+ count count2))
                              (values pivot
                                      (if (< (+ k 1) (+ count count2))
                                          pivot
                                          (%%vector-select <? v (+ k 1) start end))))
                            (else
                              (let* ((n (- size count count2))
                                     (v2 (make-vector n))
                                     (k2 (- k count count2)))
                                (copy-bigger! <? pivot v2 0 v start end)
                                (%%vector-select2 <? v2 k2 0 n)))))))))))

    ;;; Counts how many elements within the range are less than the pivot
    ;;; and how many are equal to the pivot, returning both of those counts.

    (define (count-smaller <? pivot v i end count count2)
      (cond ((= i end)
              (values count count2))
            ((<? (vector-ref v i) pivot)
              (count-smaller <? pivot v (+ i 1) end (+ count 1) count2))
            ((<? pivot (vector-ref v i))
              (count-smaller <? pivot v (+ i 1) end count count2))
            (else
              (count-smaller <? pivot v (+ i 1) end count (+ count2 1)))))

    ;;; Like vector-copy! but copies an element only if it is less than the pivot.
    ;;; The destination vector must be large enough.

    (define (copy-smaller! <? pivot dst at src start end)
      (cond ((= start end) dst)
            ((<? (vector-ref src start) pivot)
              (vector-set! dst at (vector-ref src start))
              (copy-smaller! <? pivot dst (+ at 1) src (+ start 1) end))
            (else
              (copy-smaller! <? pivot dst at src (+ start 1) end))))

    ;;; Like copy-smaller! but copies only elements that are greater than the pivot.

    (define (copy-bigger! <? pivot dst at src start end)
      (cond ((= start end)
              dst)
            ((<? pivot (vector-ref src start))
              (vector-set! dst at (vector-ref src start))
              (copy-bigger! <? pivot dst (+ at 1) src (+ start 1) end))
            (else
              (copy-bigger! <? pivot dst at src (+ start 1) end))))))
;;; SRFI 133
;;; Vector library
;;;
;;; This SRFI proposes a comprehensive library of vector operations accompanied by a freely
;;; available and complete reference implementation. The reference implementation is
;;; unencumbered by copyright, and useable with no modifications on any Scheme system
;;; that is R5RS-compliant. It also provides several hooks for implementation-specific
;;; optimization as well.
;;;
;;; Specification:
;;;   Copyright © 2016 John Cowan. All Rights Reserved.
;;;
;;;   Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;;   software and associated documentation files (the "Software"), to deal in the Software
;;;   without restriction, including without limitation the rights to use, copy, modify,
;;;   merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;;   permit persons to whom the Software is furnished to do so, subject to the following
;;;   conditions:
;;;
;;;   The above copyright notice and this permission notice shall be included in all copies
;;;   or substantial portions of the Software.
;;;
;;; Implementation:
;;;   Taylor Campbell wrote this code; he places it in the public domain.
;;;   Will Clinger [wdc] made some corrections, also in the public domain.
;;;   John Cowan modified this code for SRFI 133; his changes are also in
;;;   the public domain. However, in jurisdictions where it is not possible
;;;   to dedicate something to the public domain, the entire implementation
;;;   is made available under the same license as SRFI 133.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 133)
  
  ;; Constructors 
  (export vector-unfold
          vector-unfold-right
          vector-reverse-copy
          vector-concatenate
          vector-append-subvectors)

  ;; Predicates 
  (export vector-empty?
          vector=)

  ;; Iteration 
  (export vector-fold
          vector-fold-right
          vector-map!
          vector-count
          vector-cumulate)

  ;; Searching 
  (export vector-index
          vector-index-right
          vector-skip
          vector-skip-right
          vector-binary-search
          vector-any
          vector-every
          vector-partition)

  ;; Mutators 
  (export vector-swap!
          vector-reverse!
          vector-reverse-copy!
          vector-unfold!
          vector-unfold-right!)

  ;; Conversion 
  (export reverse-vector->list
          reverse-list->vector)

  (import (except (lispkit base) vector-copy vector-copy! vector-map vector-map! list->vector)
          (srfi 8))
  
  (begin
    ;;; This code is somewhat tuned for efficiency.  There are several
    ;;; internal routines that can be optimized greatly to greatly improve
    ;;; the performance of much of the library.  These internal procedures
    ;;; are already carefully tuned for performance, and lambda-lifted by
    ;;; hand.  Some other routines are lambda-lifted by hand, but only the
    ;;; loops are lambda-lifted, and only if some routine has two possible
    ;;; loops -- a fast path and an n-ary case --, whereas _all_ of the
    ;;; internal routines' loops are lambda-lifted so as to never cons a
    ;;; closure in their body (VECTOR-PARSE-START+END doesn't have a loop),
    ;;; even in Scheme systems that perform no loop optimization (which is
    ;;; most of them, unfortunately).
    ;;;
    ;;; Fast paths are provided for common cases in most of the loops in
    ;;; this library.
    ;;;
    ;;; All calls to primitive vector operations are protected by a prior
    ;;; type check; they can be safely converted to use unsafe equivalents
    ;;; of the operations, if available.  Ideally, the compiler should be
    ;;; able to determine this, but the state of Scheme compilers today is
    ;;; not a happy one.
    ;;;
    ;;; Efficiency of the actual algorithms is a rather mundane point to
    ;;; mention; vector operations are rarely beyond being straightforward.

    ;;; --------------------
    ;;; Utilities

    (define (nonneg-int? x)
      (and (integer? x) (not (negative? x))))

    (define (between? x y z)
      (and (< x y) (<= y z)))

    ;; This should be implemented more efficiently.  It shouldn't cons a
    ;; closure, and the cons cells used in the loops when using this could
    ;; be reused.
    (define (vectors-ref vectors i)
      (map (lambda (v) (vector-ref v i)) vectors))

    ;;; --------------------
    ;;; Error checking

    ;;; Error signalling (not checking) is done in a way that tries to be
    ;;; as helpful to the person who gets the debugging prompt as possible.
    ;;; That said, error _checking_ tries to be as unredundant as possible.

    ;;; I don't use any sort of general condition mechanism; I use simply
    ;;; SRFI 23's ERROR, even in cases where it might be better to use such
    ;;; a general condition mechanism.  Fix that when porting this to a
    ;;; Scheme implementation that has its own condition system.

    ;;; In argument checks, upon receiving an invalid argument, the checker
    ;;; procedure recursively calls itself, but in one of the arguments to
    ;;; itself is a call to ERROR; this mechanism is used in the hopes that
    ;;; the user may be thrown into a debugger prompt, proceed with another
    ;;; value, and let it be checked again.

    ;;; Type checking is pretty basic, but easily factored out and replaced
    ;;; with whatever your implementation's preferred type checking method
    ;;; is.  I doubt there will be many other methods of index checking,
    ;;; though the index checkers might be better implemented natively.

    ;;; (CHECK-TYPE <type-predicate?> <value> <callee>) -> value
    ;;;   Ensure that VALUE satisfies TYPE-PREDICATE?; if not, signal an
    ;;;   error stating that VALUE did not satisfy TYPE-PREDICATE?, showing
    ;;;   that this happened while calling CALLEE.  Return VALUE if no
    ;;;   error was signalled.
    (define (check-type pred? value callee)
      (if (pred? value)
          value
          ;; Recur: when (or if) the user gets a debugger prompt, he can
          ;; proceed where the call to ERROR was with the correct value.
          (check-type pred?
                      (error "erroneous value"
                             (list pred? value)
                             `(while calling ,callee))
                      callee)))

    ;;; (CHECK-INDEX <vector> <index> <callee>) -> index
    ;;;   Ensure that INDEX is a valid index into VECTOR; if not, signal an
    ;;;   error stating that it is not and that this happened in a call to
    ;;;   CALLEE.  Return INDEX when it is valid.  (Note that this does NOT
    ;;;   check that VECTOR is indeed a vector.)
    (define (check-index vec index callee)
      (let ((index (check-type integer? index callee)))
        (cond ((< index 0)
               (check-index vec
                            (error "vector index too low"
                                   index
                                   `(into vector ,vec)
                                   `(while calling ,callee))
                            callee))
              ((>= index (vector-length vec))
               (check-index vec
                            (error "vector index too high"
                                   index
                                   `(into vector ,vec)
                                   `(while calling ,callee))
                            callee))
              (else index))))

    ;;; (CHECK-INDICES <vector>
    ;;;                <start> <start-name>
    ;;;                <end> <end-name>
    ;;;                <caller>) -> [start end]
    ;;;   Ensure that START and END are valid bounds of a range within
    ;;;   VECTOR; if not, signal an error stating that they are not, with
    ;;;   the message being informative about what the argument names were
    ;;;   called -- by using START-NAME & END-NAME --, and that it occurred
    ;;;   while calling CALLEE.  Also ensure that VEC is in fact a vector.
    ;;;   Returns no useful value.
    (define (check-indices vec start start-name end end-name callee)
      (let ((lose (lambda things
                    (apply error "vector range out of bounds"
                           (append things
                                   `(vector was ,vec)
                                   `(,start-name was ,start)
                                   `(,end-name was ,end)
                                   `(while calling ,callee)))))
            (start (check-type integer? start callee))
            (end   (check-type integer? end   callee)))
        (cond ((> start end)
               ;; I'm not sure how well this will work.  The intent is that
               ;; the programmer tells the debugger to proceed with both a
               ;; new START & a new END by returning multiple values
               ;; somewhere.
               (receive (new-start new-end)
                        (lose `(,end-name < ,start-name))
                 (check-indices vec
                                new-start start-name
                                new-end end-name
                                callee)))
              ((< start 0)
               (check-indices vec
                              (lose `(,start-name < 0))
                              start-name
                              end end-name
                              callee))
              ((>= start (vector-length vec))
               (check-indices vec
                              (lose `(,start-name > len)
                                    `(len was ,(vector-length vec)))
                              start-name
                              end end-name
                              callee))
              ((> end (vector-length vec))
               (check-indices vec
                              start start-name
                              (lose `(,end-name > len)
                                    `(len was ,(vector-length vec)))
                              end-name
                              callee))
              (else
               (values start end)))))

    ;;; --------------------
    ;;; Internal routines

    ;;; These should all be integrated, native, or otherwise optimized --
    ;;; they're used a _lot_ --.  All of the loops and LETs inside loops
    ;;; are lambda-lifted by hand, just so as not to cons closures in the
    ;;; loops.  (If your compiler can do better than that if they're not
    ;;; lambda-lifted, then lambda-drop (?) them.)

    ;;; (VECTOR-PARSE-START+END <vector> <arguments>
    ;;;                         <start-name> <end-name>
    ;;;                         <callee>)
    ;;;       -> [start end]
    ;;;   Return two values, composing a valid range within VECTOR, as
    ;;;   extracted from ARGUMENTS or defaulted from VECTOR -- 0 for START
    ;;;   and the length of VECTOR for END --; START-NAME and END-NAME are
    ;;;   purely for error checking.
    (define (vector-parse-start+end vec args start-name end-name callee)
      (let ((len (vector-length vec)))
        (cond ((null? args)
               (values 0 len))
              ((null? (cdr args))
               (check-indices vec
                              (car args) start-name
                              len end-name
                              callee))
              ((null? (cddr args))
               (check-indices vec
                              (car  args) start-name
                              (cadr args) end-name
                              callee))
              (else
               (error "too many arguments"
                      `(extra args were ,(cddr args))
                      `(while calling ,callee))))))

    (define-syntax let-vector-start+end
      (syntax-rules ()
        ((let-vector-start+end ?callee ?vec ?args (?start ?end)
           ?body1 ?body2 ...)
         (let ((?vec (check-type vector? ?vec ?callee)))
           (receive (?start ?end)
                    (vector-parse-start+end ?vec ?args '?start '?end
                                            ?callee)
             ?body1 ?body2 ...)))))

    ;;; (%SMALLEST-LENGTH <vector-list> <default-length> <callee>)
    ;;;       -> exact, nonnegative integer
    ;;;   Compute the smallest length of VECTOR-LIST.  DEFAULT-LENGTH is
    ;;;   the length that is returned if VECTOR-LIST is empty.  Common use
    ;;;   of this is in n-ary vector routines:
    ;;;     (define (f vec . vectors)
    ;;;       (let ((vec (check-type vector? vec f)))
    ;;;         ...(%smallest-length vectors (vector-length vec) f)...))
    ;;;   %SMALLEST-LENGTH takes care of the type checking -- which is what
    ;;;   the CALLEE argument is for --; thus, the design is tuned for
    ;;;   avoiding redundant type checks.
    (define %smallest-length
      (letrec ((loop (lambda (vector-list length callee)
                       (if (null? vector-list)
                           length
                           (loop (cdr vector-list)
                                 (min (vector-length
                                       (check-type vector?
                                                   (car vector-list)
                                                   callee))
                                      length)
                                 callee)))))
        loop))

    ;;; (%VECTOR-COPY! <target> <tstart> <source> <sstart> <send>)
    ;;;   Copy elements at locations SSTART to SEND from SOURCE to TARGET,
    ;;;   starting at TSTART in TARGET.
    ;;;
    ;;; Optimize this!  Probably with some combination of:
    ;;;   - Force it to be integrated.
    ;;;   - Let it use unsafe vector element dereferencing routines: bounds
    ;;;     checking already happens outside of it.  (Or use a compiler
    ;;;     that figures this out, but Olin Shivers' PhD thesis seems to
    ;;;     have been largely ignored in actual implementations...)
    ;;;   - Implement it natively as a VM primitive: the VM can undoubtedly
    ;;;     perform much faster than it can make Scheme perform, even with
    ;;;     bounds checking.
    ;;;   - Implement it in assembly: you _want_ the fine control that
    ;;;     assembly can give you for this.
    ;;; I already lambda-lift it by hand, but you should be able to make it
    ;;; even better than that.
    (define %vector-copy!
      (letrec ((loop/l->r (lambda (target source send i j)
                            (cond ((< i send)
                                   (vector-set! target j
                                                (vector-ref source i))
                                   (loop/l->r target source send
                                              (+ i 1) (+ j 1))))))
               (loop/r->l (lambda (target source sstart i j)
                            (cond ((>= i sstart)
                                   (vector-set! target j
                                                (vector-ref source i))
                                   (loop/r->l target source sstart
                                              (- i 1) (- j 1)))))))
        (lambda (target tstart source sstart send)
          (if (> sstart tstart)             ; Make sure we don't copy over
                                            ;   ourselves.
              (loop/l->r target source send sstart tstart)
              (loop/r->l target source sstart (- send 1)
                         (+ -1 tstart send (- sstart)))))))

    ;;; (%VECTOR-REVERSE-COPY! <target> <tstart> <source> <sstart> <send>)
    ;;;   Copy elements from SSTART to SEND from SOURCE to TARGET, in the
    ;;;   reverse order.
    (define %vector-reverse-copy!
      (letrec ((loop (lambda (target source sstart i j)
                       (cond ((>= i sstart)
                              (vector-set! target j (vector-ref source i))
                              (loop target source sstart
                                    (- i 1)
                                    (+ j 1)))))))
        (lambda (target tstart source sstart send)
          (loop target source sstart
                (- send 1)
                tstart))))

    ;;; (%VECTOR-REVERSE! <vector>)
    (define %vector-reverse!
      (letrec ((loop (lambda (vec i j)
                       (cond ((<= i j)
                              (let ((v (vector-ref vec i)))
                                (vector-set! vec i (vector-ref vec j))
                                (vector-set! vec j v)
                                (loop vec (+ i 1) (- j 1))))))))
        (lambda (vec start end)
          (loop vec start (- end 1)))))

    ;;; (%VECTOR-FOLD1 <kons> <knil> <vector>) -> knil'
    ;;;     (KONS <index> <knil> <elt>) -> knil'
    (define %vector-fold1
      (letrec ((loop (lambda (kons knil len vec i)
                       (if (= i len)
                           knil
                           (loop kons
                                 (kons knil (vector-ref vec i))
                                 len vec (+ i 1))))))
        (lambda (kons knil len vec)
          (loop kons knil len vec 0))))

    ;;; (%VECTOR-FOLD2+ <kons> <knil> <vector> ...) -> knil'
    ;;;     (KONS <index> <knil> <elt> ...) -> knil'
    (define %vector-fold2+
      (letrec ((loop (lambda (kons knil len vectors i)
                       (if (= i len)
                           knil
                           (loop kons
                                 (apply kons knil
                                        (vectors-ref vectors i))
                                 len vectors (+ i 1))))))
        (lambda (kons knil len vectors)
          (loop kons knil len vectors 0))))

    ;;; (%VECTOR-MAP! <f> <target> <length> <vector>) -> target
    ;;;     (F <index> <elt>) -> elt'
    (define %vector-map1!
      (letrec ((loop (lambda (f target vec i)
                       (if (zero? i)
                           target
                           (let ((j (- i 1)))
                             (vector-set! target j
                                          (f (vector-ref vec j)))
                             (loop f target vec j))))))
        (lambda (f target vec len)
          (loop f target vec len))))

    ;;; (%VECTOR-MAP2+! <f> <target> <vectors> <len>) -> target
    ;;;     (F <index> <elt> ...) -> elt'
    (define %vector-map2+!
      (letrec ((loop (lambda (f target vectors i)
                       (if (zero? i)
                           target
                           (let ((j (- i 1)))
                             (vector-set! target j
                               (apply f (vectors-ref vectors j)))
                             (loop f target vectors j))))))
        (lambda (f target vectors len)
          (loop f target vectors len))))

    ;;;;;;;;;;;;;;;;;;;;;;;; ***** vector-lib ***** ;;;;;;;;;;;;;;;;;;;;;;;

    ;;; --------------------
    ;;; Constructors

    ;;; (VECTOR-UNFOLD <f> <length> <initial-seed> ...) -> vector
    ;;;     (F <index> <seed> ...) -> [elt seed' ...]
    ;;;   The fundamental vector constructor.  Creates a vector whose
    ;;;   length is LENGTH and iterates across each index K between 0 and
    ;;;   LENGTH, applying F at each iteration to the current index and the
    ;;;   current seeds to receive N+1 values: first, the element to put in
    ;;;   the Kth slot and then N new seeds for the next iteration.
    (define (vector-unfold f length . initial-seeds)
      (define vec (make-vector length))
      (apply vector-unfold! f vec 0 length initial-seeds)
      vec)

    ;;; (VECTOR-UNFOLD! <vec> <start> <end> <f> <initial-seed> ...) -> vector
    ;;;     (F <index> <seed> ...) -> [elt seed' ...]
    ;;;   Like VECTOR-UNFOLD, but unfolds onto an existing vector starting
    ;;;   at <start> up to but not including <end>.
    (define vector-unfold!
      (letrec ((tabulate!                   ; Special zero-seed case.
                (lambda (f vec i len)
                  (cond ((< i len)
                         (vector-set! vec i (f i))
                         (tabulate! f vec (+ i 1) len)))))
               (unfold1!                    ; Fast path for one seed.
                (lambda (f vec i len seed)
                  (if (< i len)
                      (receive (elt new-seed)
                               (f i seed)
                        (vector-set! vec i elt)
                        (unfold1! f vec (+ i 1) len new-seed)))))
               (unfold2+!                   ; Slower variant for N seeds.
                (lambda (f vec i len seeds)
                  (if (< i len)
                      (receive (elt . new-seeds)
                               (apply f i seeds)
                        (vector-set! vec i elt)
                        (unfold2+! f vec (+ i 1) len new-seeds))))))
        (lambda (f vec start end . initial-seeds)
          (let ((f     (check-type procedure?  f   vector-unfold!))
                (start (check-type nonneg-int? start vector-unfold!))
                (end   (check-type nonneg-int? end vector-unfold!)))
            (let ()
              (cond ((null? initial-seeds)
                     (tabulate! f vec start end))
                    ((null? (cdr initial-seeds))
                     (unfold1! f vec start end (car initial-seeds)))
                    (else
                     (unfold2+! f vec start end initial-seeds))))))))

    ;;; (VECTOR-UNFOLD-RIGHT <f> <length> <initial-seed> ...) -> vector
    ;;;     (F <seed> ...) -> [seed' ...]
    ;;;   Like VECTOR-UNFOLD, but it generates elements from LENGTH to 0
    ;;;   (still exclusive with  LENGTH and inclusive with 0), not 0 to
    ;;;   LENGTH as with VECTOR-UNFOLD.
    (define (vector-unfold-right f len . initial-seeds)
      (define vec (make-vector len))
      (apply vector-unfold-right! f vec 0 len initial-seeds)
      vec)

    ;;; (VECTOR-UNFOLD-RIGHT! <vec> <start> <end> <f> <initial-seed> ...) -> vector
    ;;;   Like VECTOR-UNFOLD-RIGHT, but unfolds onto an existing vector.
    (define (vector-unfold-right! f vec start end . initial-seeds)
      (letrec ((tabulate!
                (lambda (f vec i)
                  (cond ((>= i start)
                         (vector-set! vec i (f i))
                         (tabulate! f vec (- i 1))))))
               (unfold1!
                (lambda (f vec i seed)
                  (if (>= i start)
                      (receive (elt new-seed)
                               (f i seed)
                        (vector-set! vec i elt)
                        (unfold1! f vec (- i 1) new-seed)))))
               (unfold2+!
                (lambda (f vec i seeds)
                  (if (>= i start)
                      (receive (elt . new-seeds)
                               (apply f i seeds)
                        (vector-set! vec i elt)
                        (unfold2+! f vec (- i 1) new-seeds))))))
          (let ((f     (check-type procedure?  f   vector-unfold-right!))
                (start (check-type nonneg-int? start vector-unfold-right!))
                (end   (check-type nonneg-int? end vector-unfold-right!)))
            (let ((i (- end 1)))
              (cond ((null? initial-seeds)
                     (tabulate! f vec i))
                    ((null? (cdr initial-seeds))
                     (unfold1!  f vec i (car initial-seeds)))
                    (else
                     (unfold2+! f vec i initial-seeds)))))))

    ;;; (VECTOR-COPY <vector> [<start> <end> <fill>]) -> vector
    ;;;   Create a newly allocated vector containing the elements from the
    ;;;   range [START,END) in VECTOR.  START defaults to 0; END defaults
    ;;;   to the length of VECTOR.  END may be greater than the length of
    ;;;   VECTOR, in which case the vector is enlarged; if FILL is passed,
    ;;;   the new locations from which there is no respective element in
    ;;;   VECTOR are filled with FILL.
    (define (vector-copy vec . args)
      (let ((vec (check-type vector? vec vector-copy)))
        ;; We can't use LET-VECTOR-START+END, because we have one more
        ;; argument, and we want finer control, too.
        ;;
        ;; Olin's implementation of LET*-OPTIONALS would prove useful here:
        ;; the built-in argument-checks-as-you-go-along produces almost
        ;; _exactly_ the same code as VECTOR-COPY:PARSE-ARGS.
        (receive (start end fill)
                 (vector-copy:parse-args vec args)
          (let ((new-vector (make-vector (- end start) fill)))
            (%vector-copy! new-vector 0
                           vec        start
                           (if (> end (vector-length vec))
                               (vector-length vec)
                               end))
            new-vector))))

    ;;; Auxiliary for VECTOR-COPY.
    ;;; [wdc] Corrected to allow 0 <= start <= (vector-length vec).
    (define (vector-copy:parse-args vec args)
      (define (parse-args start end n fill)
        (let ((start (check-type nonneg-int? start vector-copy))
              (end   (check-type nonneg-int? end vector-copy)))
          (cond ((and (<= 0 start end)
                      (<= start n))
                 (values start end fill))
                (else
                 (error "illegal arguments"
                        `(while calling ,vector-copy)
                        `(start was ,start)
                        `(end was ,end)
                        `(vector was ,vec))))))
      (let ((n (vector-length vec)))
        (cond ((null? args)
               (parse-args 0 n n (void)))
              ((null? (cdr args))
               (parse-args (car args) n n (void)))
              ((null? (cddr args))
               (parse-args (car args) (cadr args) n (void)))
              ((null? (cdddr args))
               (parse-args (car args) (cadr args) n (caddr args)))
              (else
               (error "too many arguments"
                      vector-copy
                      (cdddr args))))))

    ;;; (VECTOR-REVERSE-COPY <vector> [<start> <end>]) -> vector
    ;;;   Create a newly allocated vector whose elements are the reversed
    ;;;   sequence of elements between START and END in VECTOR.  START's
    ;;;   default is 0; END's default is the length of VECTOR.
    (define (vector-reverse-copy vec . maybe-start+end)
      (let-vector-start+end vector-reverse-copy vec maybe-start+end
                            (start end)
        (let ((new (make-vector (- end start))))
          (%vector-reverse-copy! new 0 vec start end)
          new)))

    ;;; (VECTOR-APPEND <vector> ...) -> vector
    ;;;   Append VECTOR ... into a newly allocated vector and return that
    ;;;   new vector.
    ; (define (vector-append . vectors)
    ;   (vector-concatenate:aux vectors vector-append))

    ;;; (VECTOR-CONCATENATE <vector-list>) -> vector
    ;;;   Concatenate the vectors in VECTOR-LIST.  This is equivalent to
    ;;;     (apply vector-append VECTOR-LIST)
    ;;;   but VECTOR-APPEND tends to be implemented in terms of
    ;;;   VECTOR-CONCATENATE, and some Schemes bork when the list to apply
    ;;;   a function to is too long.
    ;;;
    ;;; Actually, they're both implemented in terms of an internal routine.
    ; (define (vector-concatenate vector-list)
    ;   (vector-concatenate:aux vector-list vector-concatenate))

    ;;; Auxiliary for VECTOR-APPEND and VECTOR-CONCATENATE
    (define vector-concatenate:aux
      (letrec ((compute-length
                (lambda (vectors len callee)
                  (if (null? vectors)
                      len
                      (let ((vec (check-type vector? (car vectors)
                                             callee)))
                        (compute-length (cdr vectors)
                                        (+ (vector-length vec) len)
                                        callee)))))
               (concatenate!
                (lambda (vectors target to)
                  (if (null? vectors)
                      target
                      (let* ((vec1 (car vectors))
                             (len (vector-length vec1)))
                        (%vector-copy! target to vec1 0 len)
                        (concatenate! (cdr vectors) target
                                      (+ to len)))))))
        (lambda (vectors callee)
          (cond ((null? vectors)            ;+++
                 (make-vector 0))
                ((null? (cdr vectors))      ;+++
                 ;; Blech, we still have to allocate a new one.
                 (let* ((vec (check-type vector? (car vectors) callee))
                        (len (vector-length vec))
                        (new (make-vector len)))
                   (%vector-copy! new 0 vec 0 len)
                   new))
                (else
                 (let ((new-vector
                        (make-vector (compute-length vectors 0 callee))))
                   (concatenate! vectors new-vector 0)
                   new-vector))))))

    ;;; (VECTOR-APPEND-SUBVECTORS <arg> ...) -> vector
    ;;;   Like VECTOR-APPEND but appends subvectors specified by
    ;;;   <vector> <start> <end> argument triples.
    (define (vector-append-subvectors . args)
      ;; GATHER-ARGS returns three values: vectors, starts, ends
      (define (gather-args args)
        (let loop ((args args) (vecs '()) (starts '()) (ends '()))
          (if (null? args)
             (values (reverse vecs) (reverse starts) (reverse ends))
             (loop (cdddr args)
                   (cons (car args) vecs)
                   (cons (cadr args) starts)
                   (cons (caddr args) ends)))))
      ;; TOTAL-LENGTH computes the length of all subvectors
      (define (total-length starts ends)
        (let loop ((count 0) (starts starts) (ends ends))
          (if (null? starts)
            count
            (let ((start (car starts)) (end (car ends)))
              (loop (+ count (- end start))
                    (cdr starts)
                    (cdr ends))))))
     ;; COPY-EACH! copies each subvector into a result vector
      (define (copy-each! result vecs starts ends)
        (let loop ((at 0) (vecs vecs) (starts starts) (ends ends))
          (if (null? vecs)
            result
            (let ((vec (car vecs)) (start (car starts)) (end (car ends)))
              (%vector-copy! result at vec start end)
              (loop (+ at (- end start))
                    (cdr vecs)
                    (cdr starts)
                    (cdr ends))))))
      ;; put them all together, they spell VECTOR-APPEND-SUBVECTORS
      (receive (vecs starts ends) (gather-args args)
        (define result (make-vector (total-length starts ends)))
        (copy-each! result vecs starts ends)))


    ;;; --------------------
    ;;; Predicates

    ;;; (VECTOR-EMPTY? <vector>) -> boolean
    ;;;   Return #T if VECTOR has zero elements in it, i.e. VECTOR's length
    ;;;   is 0, and #F if not.
    (define (vector-empty? vec)
      (let ((vec (check-type vector? vec vector-empty?)))
        (zero? (vector-length vec))))

    ;;; (VECTOR= <elt=?> <vector> ...) -> boolean
    ;;;     (ELT=? <value> <value>) -> boolean
    ;;;   Determine vector equality generalized across element comparators.
    ;;;   Vectors A and B are equal iff their lengths are the same and for
    ;;;   each respective elements E_a and E_b (element=? E_a E_b) returns
    ;;;   a true value.  ELT=? is always applied to two arguments.  Element
    ;;;   comparison must be consistent wtih EQ?; that is, if (eq? E_a E_b)
    ;;;   results in a true value, then (ELEMENT=? E_a E_b) must result in a
    ;;;   true value.  This may be exploited to avoid multiple unnecessary
    ;;;   element comparisons.  (This implementation does, but does not deal
    ;;;   with the situation that ELEMENT=? is EQ? to avoid more unnecessary
    ;;;   comparisons, but I believe this optimization is probably fairly
    ;;;   insignificant.)
    ;;;
    ;;;   If the number of vector arguments is zero or one, then #T is
    ;;;   automatically returned.  If there are N vector arguments,
    ;;;   VECTOR_1 VECTOR_2 ... VECTOR_N, then VECTOR_1 & VECTOR_2 are
    ;;;   compared; if they are equal, the vectors VECTOR_2 ... VECTOR_N
    ;;;   are compared.  The precise order in which ELT=? is applied is not
    ;;;   specified.
    ; (define (vector= elt=? . vectors)
    ;   (let ((elt=? (check-type procedure? elt=? vector=)))
    ;         (cond ((null? vectors) #t)
    ;               ((null? (cdr vectors))
    ;                 (check-type vector? (car vectors) vector=)
    ;                 #t)
    ;               (else
    ;                 (let loop ((vecs vectors))
    ;                   (let ((vec1 (check-type vector? (car vecs) vector=))
    ;                         (vec2+ (cdr vecs)))
    ;                     (or (null? vec2+)
    ;                         (and (binary-vector= elt=? vec1 (car vec2+))
    ;                              (loop vec2+)))))))))

    (define (binary-vector= elt=? vector-a vector-b)
      (or (eq? vector-a vector-b)           ;+++
          (let ((length-a (vector-length vector-a))
                (length-b (vector-length vector-b)))
            (letrec ((loop (lambda (i)
                             (or (= i length-a)
                                 (and (< i length-b)
                                      (test (vector-ref vector-a i)
                                            (vector-ref vector-b i)
                                            i)))))
                     (test (lambda (elt-a elt-b i)
                             (and (or (eq? elt-a elt-b) ;+++
                                      (elt=? elt-a elt-b))
                                  (loop (+ i 1))))))
              (and (= length-a length-b)
                   (loop 0))))))


    ;;; --------------------
    ;;; Selectors


    ;;; --------------------
    ;;; Iteration

    ;;; (VECTOR-FOLD <kons> <initial-knil> <vector> ...) -> knil
    ;;;     (KONS <knil> <elt> ...) -> knil' ; N vectors -> N+1 args
    ;;;   The fundamental vector iterator.  KONS is iterated over each
    ;;;   index in all of the vectors in parallel, stopping at the end of
    ;;;   the shortest; KONS is applied to an argument list of (list I
    ;;;   STATE (vector-ref VEC I) ...), where STATE is the current state
    ;;;   value -- the state value begins with KNIL and becomes whatever
    ;;;   KONS returned at the respective iteration --, and I is the
    ;;;   current index in the iteration.  The iteration is strictly left-
    ;;;   to-right.
    ;;;     (vector-fold KONS KNIL (vector E_1 E_2 ... E_N))
    ;;;       <=>
    ;;;     (KONS (... (KONS (KONS KNIL E_1) E_2) ... E_N-1) E_N)
    (define (vector-fold kons knil vec . vectors)
      (let ((kons (check-type procedure? kons vector-fold))
            (vec  (check-type vector?    vec  vector-fold)))
        (if (null? vectors)
            (%vector-fold1 kons knil (vector-length vec) vec)
            (%vector-fold2+ kons knil
                            (%smallest-length vectors
                                              (vector-length vec)
                                              vector-fold)
                            (cons vec vectors)))))

    ;;; (VECTOR-FOLD-RIGHT <kons> <initial-knil> <vector> ...) -> knil
    ;;;     (KONS <knil> <elt> ...) -> knil' ; N vectors => N+1 args
    ;;;   The fundamental vector recursor.  Iterates in parallel across
    ;;;   VECTOR ... right to left, applying KONS to the elements and the
    ;;;   current state value; the state value becomes what KONS returns
    ;;;   at each next iteration.  KNIL is the initial state value.
    ;;;     (vector-fold-right KONS KNIL (vector E_1 E_2 ... E_N))
    ;;;       <=>
    ;;;     (KONS (... (KONS (KONS KNIL E_N) E_N-1) ... E_2) E_1)
    ;;;
    ;;; Not implemented in terms of a more primitive operations that might
    ;;; called %VECTOR-FOLD-RIGHT due to the fact that it wouldn't be very
    ;;; useful elsewhere.
    (define vector-fold-right
      (letrec ((loop1 (lambda (kons knil vec i)
                        (if (negative? i)
                            knil
                            (loop1 kons (kons knil (vector-ref vec i))
                                   vec
                                   (- i 1)))))
               (loop2+ (lambda (kons knil vectors i)
                         (if (negative? i)
                             knil
                             (loop2+ kons
                                     (apply kons knil
                                            (vectors-ref vectors i))
                                     vectors
                                     (- i 1))))))
        (lambda (kons knil vec . vectors)
          (let ((kons (check-type procedure? kons vector-fold-right))
                (vec  (check-type vector?    vec  vector-fold-right)))
            (if (null? vectors)
                (loop1  kons knil vec (- (vector-length vec) 1))
                (loop2+ kons knil (cons vec vectors)
                        (- (%smallest-length vectors
                                             (vector-length vec)
                                             vector-fold-right)
                           1)))))))

    ;;; (VECTOR-MAP <f> <vector> ...) -> vector
    ;;;     (F <elt> ...) -> value ; N vectors -> N args
    ;;;   Constructs a new vector of the shortest length of the vector
    ;;;   arguments.  Each element at index I of the new vector is mapped
    ;;;   from the old vectors by (F I (vector-ref VECTOR I) ...).  The
    ;;;   dynamic order of application of F is unspecified.
    (define (vector-map f vec . vectors)
      (let ((f   (check-type procedure? f   vector-map))
            (vec (check-type vector?    vec vector-map)))
        (if (null? vectors)
            (let ((len (vector-length vec)))
              (%vector-map1! f (make-vector len) vec len))
            (let ((len (%smallest-length vectors
                                         (vector-length vec)
                                         vector-map)))
              (%vector-map2+! f (make-vector len) (cons vec vectors)
                              len)))))

    ;;; (VECTOR-MAP! <f> <vector> ...) -> unspecified
    ;;;     (F <elt> ...) -> element' ; N vectors -> N args
    ;;;   Similar to VECTOR-MAP, but rather than mapping the new elements
    ;;;   into a new vector, the new mapped elements are destructively
    ;;;   inserted into the first vector.  Again, the dynamic order of
    ;;;   application of F is unspecified, so it is dangerous for F to
    ;;;   manipulate the first VECTOR.
    (define (vector-map! f vec . vectors)
      (let ((f   (check-type procedure? f   vector-map!))
            (vec (check-type vector?    vec vector-map!)))
        (if (null? vectors)
            (%vector-map1!  f vec vec (vector-length vec))
            (%vector-map2+! f vec (cons vec vectors)
                            (%smallest-length vectors
                                              (vector-length vec)
                                              vector-map!)))
        (void)))

    ;;; (VECTOR-FOR-EACH <f> <vector> ...) -> unspecified
    ;;;     (F <elt> ...) ; N vectors -> N args
    ;;;   Simple vector iterator: applies F to each index in the range [0,
    ;;;   LENGTH), where LENGTH is the length of the smallest vector
    ;;;   argument passed, and the respective element at that index.  In
    ;;;   contrast with VECTOR-MAP, F is reliably applied to each
    ;;;   subsequent elements, starting at index 0 from left to right, in
    ;;;   the vectors.
    ;    (define vector-for-each
    ;      (letrec ((for-each1
    ;                (lambda (f vec i len)
    ;                  (cond ((< i len)
    ;                         (f (vector-ref vec i))
    ;                         (for-each1 f vec (+ i 1) len)))))
    ;               (for-each2+
    ;                (lambda (f vecs i len)
    ;                  (cond ((< i len)
    ;                         (apply f (vectors-ref vecs i))
    ;                         (for-each2+ f vecs (+ i 1) len))))))
    ;        (lambda (f vec . vectors)
    ;          (let ((f   (check-type procedure? f   vector-for-each))
    ;                (vec (check-type vector?    vec vector-for-each)))
    ;            (if (null? vectors)
    ;                (for-each1 f vec 0 (vector-length vec))
    ;                (for-each2+ f (cons vec vectors) 0
    ;                            (%smallest-length vectors
    ;                                              (vector-length vec)
    ;                                              vector-for-each)))))))

    ;;; (VECTOR-COUNT <predicate?> <vector> ...)
    ;;;       -> exact, nonnegative integer
    ;;;     (PREDICATE? <value> ...) ; N vectors -> N args
    ;;;   PREDICATE? is applied element-wise to the elements of VECTOR ...,
    ;;;   and a count is tallied of the number of elements for which a
    ;;;   true value is produced by PREDICATE?.  This count is returned.
    (define (vector-count pred? vec . vectors)
      (let ((pred? (check-type procedure? pred? vector-count))
            (vec   (check-type vector?    vec   vector-count)))
        (if (null? vectors)
            (%vector-fold1 (lambda (count elt)
                             (if (pred? elt)
                                 (+ count 1)
                                 count))
                           0
                           (vector-length vec)
                           vec)
            (%vector-fold2+ (lambda (count . elts)
                              (if (apply pred? elts)
                                  (+ count 1)
                                  count))
                            0
                            (%smallest-length vectors
                                              (vector-length vec)
                                              vector-count)
                            (cons vec vectors)))))

    ;;; (VECTOR-CUMULATE <f> <knil> <vector>)
    ;;;       -> vector
    ;;;   Returns a <new>ly allocated vector <new> with the same length as
    ;;;   <vec>. Each element <i> of <new> is set to the result of invoking <f> on
    ;;;   <new>[i-1] and <vec>[i], except that for the first call on <f>, the first
    ;;;   argument is <knil>. The <new> vector is returned.
    (define (vector-cumulate f knil vec)
      (let* ((len (vector-length vec))
             (result (make-vector len)))
        (let loop ((i 0) (left knil))
          (if (= i len)
            result
            (let* ((right (vector-ref vec i)) (r (f left right)))
              (vector-set! result i r)
              (loop (+ i 1) r))))))

    

    ;;; --------------------
    ;;; Searching

    ;;; (VECTOR-INDEX <predicate?> <vector> ...)
    ;;;       -> exact, nonnegative integer or #F
    ;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
    ;;;   Search left-to-right across VECTOR ... in parallel, returning the
    ;;;   index of the first set of values VALUE ... such that (PREDICATE?
    ;;;   VALUE ...) returns a true value; if no such set of elements is
    ;;;   reached, return #F.
    (define (vector-index pred? vec . vectors)
      (vector-index/skip pred? vec vectors vector-index))

    ;;; (VECTOR-SKIP <predicate?> <vector> ...)
    ;;;       -> exact, nonnegative integer or #F
    ;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
    ;;;   (vector-index (lambda elts (not (apply PREDICATE? elts)))
    ;;;                 VECTOR ...)
    ;;;   Like VECTOR-INDEX, but find the index of the first set of values
    ;;;   that do _not_ satisfy PREDICATE?.
    (define (vector-skip pred? vec . vectors)
      (vector-index/skip (lambda elts (not (apply pred? elts)))
                         vec vectors
                         vector-skip))

    ;;; Auxiliary for VECTOR-INDEX & VECTOR-SKIP
    (define vector-index/skip
      (letrec ((loop1  (lambda (pred? vec len i)
                         (cond ((= i len) #f)
                               ((pred? (vector-ref vec i)) i)
                               (else (loop1 pred? vec len (+ i 1))))))
               (loop2+ (lambda (pred? vectors len i)
                         (cond ((= i len) #f)
                               ((apply pred? (vectors-ref vectors i)) i)
                               (else (loop2+ pred? vectors len
                                             (+ i 1)))))))
        (lambda (pred? vec vectors callee)
          (let ((pred? (check-type procedure? pred? callee))
                (vec   (check-type vector?    vec   callee)))
            (if (null? vectors)
                (loop1 pred? vec (vector-length vec) 0)
                (loop2+ pred? (cons vec vectors)
                        (%smallest-length vectors
                                          (vector-length vec)
                                          callee)
                        0))))))

    ;;; (VECTOR-INDEX-RIGHT <predicate?> <vector> ...)
    ;;;       -> exact, nonnegative integer or #F
    ;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
    ;;;   Right-to-left variant of VECTOR-INDEX.
    (define (vector-index-right pred? vec . vectors)
      (vector-index/skip-right pred? vec vectors vector-index-right))

    ;;; (VECTOR-SKIP-RIGHT <predicate?> <vector> ...)
    ;;;       -> exact, nonnegative integer or #F
    ;;;     (PREDICATE? <elt> ...) -> boolean ; N vectors -> N args
    ;;;   Right-to-left variant of VECTOR-SKIP.
    (define (vector-skip-right pred? vec . vectors)
      (vector-index/skip-right (lambda elts (not (apply pred? elts)))
                               vec vectors
                               vector-index-right))

    (define vector-index/skip-right
      (letrec ((loop1  (lambda (pred? vec i)
                         (cond ((negative? i) #f)
                               ((pred? (vector-ref vec i)) i)
                               (else (loop1 pred? vec (- i 1))))))
               (loop2+ (lambda (pred? vectors i)
                         (cond ((negative? i) #f)
                               ((apply pred? (vectors-ref vectors i)) i)
                               (else (loop2+ pred? vectors (- i 1)))))))
        (lambda (pred? vec vectors callee)
          (let ((pred? (check-type procedure? pred? callee))
                (vec   (check-type vector?    vec   callee)))
            (if (null? vectors)
                (loop1 pred? vec (- (vector-length vec) 1))
                (loop2+ pred? (cons vec vectors)
                        (- (%smallest-length vectors
                                             (vector-length vec)
                                             callee)
                           1)))))))

    ;;; (VECTOR-BINARY-SEARCH <vector> <value> <cmp> [<start> <end>])
    ;;;       -> exact, nonnegative integer or #F
    ;;;     (CMP <value1> <value2>) -> integer
    ;;;       positive -> VALUE1 > VALUE2
    ;;;       zero     -> VALUE1 = VALUE2
    ;;;       negative -> VALUE1 < VALUE2
    ;;;   Perform a binary search through VECTOR for VALUE, comparing each
    ;;;   element to VALUE with CMP.
    (define (vector-binary-search vec value cmp . maybe-start+end)
      (let ((cmp (check-type procedure? cmp vector-binary-search)))
        (let-vector-start+end vector-binary-search vec maybe-start+end
                              (start end)
          (let loop ((start start) (end end) (j #f))
            (let ((i (quotient (+ start end) 2)))
              (if (or (= start end) (and j (= i j)))
                  #f
                  (let ((comparison
                         (check-type integer?
                                     (cmp (vector-ref vec i) value)
                                     `(,cmp for ,vector-binary-search))))
                    (cond ((zero?     comparison) i)
                          ((positive? comparison) (loop start i i))
                          (else                   (loop i end i))))))))))

    ;;; (VECTOR-ANY <pred?> <vector> ...) -> value
    ;;;   Apply PRED? to each parallel element in each VECTOR ...; if PRED?
    ;;;   should ever return a true value, immediately stop and return that
    ;;;   value; otherwise, when the shortest vector runs out, return #F.
    ;;;   The iteration and order of application of PRED? across elements
    ;;;   is of the vectors is strictly left-to-right.
    (define vector-any
      (letrec ((loop1 (lambda (pred? vec i len len-1)
                        (and (not (= i len))
                             (if (= i len-1)
                                 (pred? (vector-ref vec i))
                                 (or (pred? (vector-ref vec i))
                                     (loop1 pred? vec (+ i 1)
                                            len len-1))))))
               (loop2+ (lambda (pred? vectors i len len-1)
                         (and (not (= i len))
                              (if (= i len-1)
                                  (apply pred? (vectors-ref vectors i))
                                  (or (apply pred? (vectors-ref vectors i))
                                      (loop2+ pred? vectors (+ i 1)
                                             len len-1)))))))
        (lambda (pred? vec . vectors)
          (let ((pred? (check-type procedure? pred? vector-any))
                (vec   (check-type vector?    vec   vector-any)))
            (if (null? vectors)
                (let ((len (vector-length vec)))
                  (loop1 pred? vec 0 len (- len 1)))
                (let ((len (%smallest-length vectors
                                             (vector-length vec)
                                             vector-any)))
                  (loop2+ pred? (cons vec vectors) 0 len (- len 1))))))))

    ;;; (VECTOR-EVERY <pred?> <vector> ...) -> value
    ;;;   Apply PRED? to each parallel value in each VECTOR ...; if PRED?
    ;;;   should ever return #F, immediately stop and return #F; otherwise,
    ;;;   if PRED? should return a true value for each element, stopping at
    ;;;   the end of the shortest vector, return the last value that PRED?
    ;;;   returned.  In the case that there is an empty vector, return #T.
    ;;;   The iteration and order of application of PRED? across elements
    ;;;   is of the vectors is strictly left-to-right.
    (define vector-every
      (letrec ((loop1 (lambda (pred? vec i len len-1)
                        (or (= i len)
                            (if (= i len-1)
                                (pred? (vector-ref vec i))
                                (and (pred? (vector-ref vec i))
                                     (loop1 pred? vec (+ i 1)
                                            len len-1))))))
               (loop2+ (lambda (pred? vectors i len len-1)
                         (or (= i len)
                             (if (= i len-1)
                                 (apply pred? (vectors-ref vectors i))
                                 (and (apply pred? (vectors-ref vectors i))
                                      (loop2+ pred? vectors (+ i 1)
                                              len len-1)))))))
        (lambda (pred? vec . vectors)
          (let ((pred? (check-type procedure? pred? vector-every))
                (vec   (check-type vector?    vec   vector-every)))
            (if (null? vectors)
                (let ((len (vector-length vec)))
                  (loop1 pred? vec 0 len (- len 1)))
                (let ((len (%smallest-length vectors
                                             (vector-length vec)
                                             vector-every)))
                  (loop2+ pred? (cons vec vectors) 0 len (- len 1))))))))

    ;;; (VECTOR-PARTITION <pred?> <vector>) -> vector
    ;;;   A vector the same size as <vec> is newly allocated and filled with
    ;;;   all the elements of <vec> that satisfy <pred?> in their original
    ;;;   order followed by all the elements that do not satisfy <pred?>,
    ;;;   also in their original order.

    ;;;   Two values are returned, the newly allocated vector and the index
    ;;;   of the leftmost element that does not satisfy <pred?>.
    (define (vector-partition pred? vec)
      (let* ((len (vector-length vec))
             (cnt (vector-count pred? vec))
             (result (make-vector len)))
        (let loop ((i 0) (yes 0) (no cnt))
          (if (= i len)
            (values result cnt)
            (let ((elem (vector-ref vec i)))
              (if (pred? elem)
                (begin
                  (vector-set! result yes elem)
                  (loop (+ i 1) (+ yes 1) no))
                (begin
                  (vector-set! result no elem)
                  (loop (+ i 1) yes (+ no 1)))))))))

    

    ;;; --------------------
    ;;; Mutators

    ;;; (VECTOR-SWAP! <vector> <index1> <index2>) -> unspecified
    ;;;   Swap the values in the locations at INDEX1 and INDEX2.
    ; (define (vector-swap! vec i j)
    ;   (let ((vec (check-type vector? vec vector-swap!)))
    ;     (let ((i (check-index vec i vector-swap!))
    ;           (j (check-index vec j vector-swap!)))
    ;       (let ((x (vector-ref vec i)))
    ;         (vector-set! vec i (vector-ref vec j))
    ;         (vector-set! vec j x)))))

    ;;; (VECTOR-FILL! <vector> <value> [<start> <end>]) -> unspecified
    ;;;   [R5RS+] Fill the locations in VECTOR between START, whose default
    ;;;   is 0, and END, whose default is the length of VECTOR, with VALUE.
    ;;;
    ;;; This one can probably be made really fast natively.
    ; (define (vector-fill! vec value . maybe-start+end)
    ;   (let-vector-start+end vector-fill! vec maybe-start+end (start end)
    ;     (do ((i start (+ i 1)))
    ;          ((= i end))
    ;       (vector-set! vec i value))))

    ;;; (VECTOR-COPY! <target> <tstart> <source> [<sstart> <send>])
    ;;;       -> unspecified
    ;;;   Copy the values in the locations in [SSTART,SEND) from SOURCE to
    ;;;   to TARGET, starting at TSTART in TARGET.
    ;;; [wdc] Corrected to allow 0 <= sstart <= send <= (vector-length source).
    (define (vector-copy! target tstart source . maybe-sstart+send)
      (define (doit! sstart send source-length)
        (let ((tstart (check-type nonneg-int? tstart vector-copy!))
              (sstart (check-type nonneg-int? sstart vector-copy!))
              (send   (check-type nonneg-int? send vector-copy!)))
          (cond ((and (<= 0 sstart send source-length)
                      (<= (+ tstart (- send sstart)) (vector-length target)))
                 (%vector-copy! target tstart source sstart send))
                (else
                 (error "illegal arguments"
                        `(while calling ,vector-copy!)
                        `(target was ,target)
                        `(target-length was ,(vector-length target))
                        `(tstart was ,tstart)
                        `(source was ,source)
                        `(source-length was ,source-length)
                        `(sstart was ,sstart)
                        `(send   was ,send))))))
      (let ((n (vector-length source)))
        (cond ((null? maybe-sstart+send)
               (doit! 0 n n))
              ((null? (cdr maybe-sstart+send))
               (doit! (car maybe-sstart+send) n n))
              ((null? (cddr maybe-sstart+send))
               (doit! (car maybe-sstart+send) (cadr maybe-sstart+send) n))
              (else
               (error "too many arguments"
                      vector-copy!
                      (cddr maybe-sstart+send))))))

    ;;; (VECTOR-REVERSE-COPY! <target> <tstart> <source> [<sstart> <send>])
    ;;; [wdc] Corrected to allow 0 <= sstart <= send <= (vector-length source).
    (define (vector-reverse-copy! target tstart source . maybe-sstart+send)
      (define (doit! sstart send source-length)
        (let ((tstart (check-type nonneg-int? tstart vector-reverse-copy!))
              (sstart (check-type nonneg-int? sstart vector-reverse-copy!))
              (send   (check-type nonneg-int? send vector-reverse-copy!)))
          (cond ((and (eq? target source)
                      (or (between? sstart tstart send)
                          (between? tstart sstart
                                    (+ tstart (- send sstart)))))
                   (error "vector range for self-copying overlaps"
                          vector-reverse-copy!
                          `(vector was ,target)
                          `(tstart was ,tstart)
                          `(sstart was ,sstart)
                          `(send   was ,send)))
                ((and (<= 0 sstart send source-length)
                      (<= (+ tstart (- send sstart)) (vector-length target)))
                 (%vector-reverse-copy! target tstart source sstart send))
                (else
                 (error "illegal arguments"
                        `(while calling ,vector-reverse-copy!)
                        `(target was ,target)
                        `(target-length was ,(vector-length target))
                        `(tstart was ,tstart)
                        `(source was ,source)
                        `(source-length was ,source-length)
                        `(sstart was ,sstart)
                        `(send   was ,send))))))
      (let ((n (vector-length source)))
        (cond ((null? maybe-sstart+send)
               (doit! 0 n n))
              ((null? (cdr maybe-sstart+send))
               (doit! (car maybe-sstart+send) n n))
              ((null? (cddr maybe-sstart+send))
               (doit! (car maybe-sstart+send) (cadr maybe-sstart+send) n))
              (else
               (error "too many arguments"
                      vector-reverse-copy!
                      (cddr maybe-sstart+send))))))

    ;;; (VECTOR-REVERSE! <vector> [<start> <end>]) -> unspecified
    ;;;   Destructively reverse the contents of the sequence of locations
    ;;;   in VECTOR between START, whose default is 0, and END, whose
    ;;;   default is the length of VECTOR.
    ; (define (vector-reverse! vec . start+end)
    ;   (let-vector-start+end vector-reverse! vec start+end (start end)
    ;     (%vector-reverse! vec start end)))

    ;;; --------------------
    ;;; Conversion

    ;;; (VECTOR->LIST <vector> [<start> <end>]) -> list
    ;;;   [R5RS+] Produce a list containing the elements in the locations
    ;;;   between START, whose default is 0, and END, whose default is the
    ;;;   length of VECTOR, from VECTOR.
    ; (define (vector->list vec . maybe-start+end)
    ;   (let-vector-start+end vector->list vec maybe-start+end (start end)
    ;     (do ((i (- end 1) (- i 1))
    ;          (result '() (cons (vector-ref vec i) result)))
    ;       ((< i start) result))))

    ;;; (REVERSE-VECTOR->LIST <vector> [<start> <end>]) -> list
    ;;;   Produce a list containing the elements in the locations between
    ;;;   START, whose default is 0, and END, whose default is the length
    ;;;   of VECTOR, from VECTOR, in reverse order.
    (define (reverse-vector->list vec . maybe-start+end)
      (let-vector-start+end reverse-vector->list vec maybe-start+end (start end)
        (do ((i start (+ i 1))
             (result '() (cons (vector-ref vec i) result)))
            ((= i end) result))))

    ;;; (LIST->VECTOR <list> [<start> <end>]) -> vector
    ;;;   [R5RS+] Produce a vector containing the elements in LIST, which
    ;;;   must be a proper list, between START, whose default is 0, & END,
    ;;;   whose default is the length of LIST.  It is suggested that if the
    ;;;   length of LIST is known in advance, the START and END arguments
    ;;;   be passed, so that LIST->VECTOR need not call LENGTH to determine
    ;;;   the length.
    ;;;
    ;;; This implementation diverges on circular lists, unless LENGTH fails
    ;;; and causes - to fail as well.  Given a LENGTH* that computes the
    ;;; length of a list's cycle, this wouldn't diverge, and would work
    ;;; great for circular lists.
    (define (list->vector lst . maybe-start+end)
       ;; We can't use LET-VECTOR-START+END, because we're using the
       ;; bounds of a _list_, not a vector.
       (let*-optionals maybe-start+end
           ((start 0)
            (end (length lst)))      ; Ugh -- LENGTH
         (let ((start (check-type nonneg-int? start list->vector))
               (end   (check-type nonneg-int? end   list->vector)))
           ((lambda (f)
              (vector-unfold f (- end start) (list-tail lst start)))
            (lambda (index l)
              (cond ((null? l)
                     (error "list was too short"
                            `(list was ,lst)
                            `(attempted end was ,end)
                            `(while calling ,list->vector)))
                    ((pair? l)
                     (values (car l) (cdr l)))
                    (else
                     ;; Make this look as much like what CHECK-TYPE
                     ;; would report as possible.
                     (error "erroneous value"
                            ;; We want SRFI 1's PROPER-LIST?, but it
                            ;; would be a waste to link all of SRFI
                            ;; 1 to this module for only the single
                            ;; function PROPER-LIST?.
                            (list list? lst)
                            `(while calling
                              ,list->vector)))))))))

    ;;; (REVERSE-LIST->VECTOR <list> [<start> <end>]) -> vector
    ;;;   Produce a vector containing the elements in LIST, which must be a
    ;;;   proper list, between START, whose default is 0, and END, whose
    ;;;   default is the length of LIST, in reverse order.  It is suggested
    ;;;   that if the length of LIST is known in advance, the START and END
    ;;;   arguments be passed, so that REVERSE-LIST->VECTOR need not call
    ;;;   LENGTH to determine the the length.
    ;;;
    ;;; This also diverges on circular lists unless, again, LENGTH returns
    ;;; something that makes - bork.
    (define (reverse-list->vector lst . maybe-start+end)
      (let*-optionals maybe-start+end
          ((start 0)
           (end (length lst)))              ; Ugh -- LENGTH
        (let ((start (check-type nonneg-int? start reverse-list->vector))
              (end   (check-type nonneg-int? end   reverse-list->vector)))
          ((lambda (f)
             (vector-unfold-right f (- end start) (list-tail lst start)))
           (lambda (index l)
             (cond ((null? l)
                    (error "list too short"
                           `(list was ,lst)
                           `(attempted end was ,end)
                           `(while calling ,reverse-list->vector)))
                   ((pair? l)
                    (values (car l) (cdr l)))
                   (else
                    (error "erroneous value"
                           (list list? lst)
                           `(while calling ,reverse-list->vector)))))))))

    ;;; (VECTOR->STRING <vector> [<start> <end>]) -> string
    ;;;   Produce a string containing the elements in the locations
    ;;;   between START, whose default is 0, and END, whose default is the
    ;;;   length of VECTOR, from VECTOR.
    ;    (define (vector->string vec . maybe-start+end)
    ;      (let* ((len (vector-length vec))
    ;             (start (if (null? maybe-start+end) 0 (car maybe-start+end)))
    ;             (end (if (null? maybe-start+end)
    ;                      len
    ;                      (if (null? (cdr maybe-start+end)) len (cadr maybe-start+end))))
    ;             (size (- end start)))
    ;        (define result (make-string size))
    ;        (let loop ((at 0) (i start))
    ;          (if (= i end)
    ;            result
    ;            (begin
    ;              (string-set! result at (vector-ref vec i))
    ;              (loop (+ at 1) (+ i 1)))))))

    ;;; (STRING->VECTOR <string> [<start> <end>]) -> vector
    ;;;   Produce a vector containing the elements in STRING
    ;;;   between START, whose default is 0, & END,
    ;;;   whose default is the length of STRING, from STRING.
    ;    (define (string->vector str . maybe-start+end)
    ;      (let* ((len (string-length str))
    ;             (start (if (null? maybe-start+end) 0 (car maybe-start+end)))
    ;             (end (if (null? maybe-start+end)
    ;                      len
    ;                      (if (null? (cdr maybe-start+end)) len (cadr maybe-start+end))))
    ;             (size (- end start)))
    ;        (define result (make-vector size))
    ;        (let loop ((at 0) (i start))
    ;          (if (= i end)
    ;            result
    ;            (begin
    ;              (vector-set! result at (string-ref str i))
    ;              (loop (+ at 1) (+ i 1)))))))
  )
)
;;; SRFI 134
;;; Immutable Deques
;;;
;;; This SRFI defines immutable deques. A deque is a double-ended queue, a sequence
;;; which allows elements to be added or removed efficiently from either end. A deque
;;; is a generalization of both a queue and a stack, and can be used as either by
;;; disregarding the irrelevant procedures. A data structure is immutable when all its
;;; operations leave the structure unchanged. Note that none of the procedures specified
;;; here ends with an exclamation point.
;;;
;;; Specification:
;;;   Copyright © 2015 John Cowan, Kevin Wortman. All Rights Reserved.
;;;
;;;   Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;;   software and associated documentation files (the "Software"), to deal in the Software
;;;   without restriction, including without limitation the rights to use, copy, modify,
;;;   merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;;   permit persons to whom the Software is furnished to do so, subject to the following
;;;   conditions:
;;;
;;;   The above copyright notice and this permission notice shall be included in all copies
;;;   or substantial portions of the Software.
;;;
;;; Implementation:
;;;   Copyright © 2015 Shiro Kawai. All Rights Reserved.
;;;
;;;   Redistribution and use in source and binary forms, with or without modification,
;;;   are permitted provided that the following conditions are met:
;;;
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 134)

  (export ideque
          ideque-tabulate
          ideque-unfold
          ideque-unfold-right
          ideque?
          ideque-empty?
          ideque=
          ideque-any
          ideque-every
          ideque-front
          ideque-add-front
          ideque-remove-front
          ideque-back
          ideque-add-back
          ideque-remove-back
          ideque-ref
          ideque-take
          ideque-take-right
          ideque-drop
          ideque-drop-right
          ideque-split-at
          ideque-length
          ideque-append
          ideque-reverse
          ideque-count
          ideque-zip
          ideque-map
          ideque-filter-map
          ideque-for-each
          ideque-for-each-right
          ideque-fold
          ideque-fold-right
          ideque-append-map
          ideque-filter
          ideque-remove
          ideque-partition
          ideque-find
          ideque-find-right
          ideque-take-while
          ideque-take-while-right
          ideque-drop-while
          ideque-drop-while-right
          ideque-span
          ideque-break
          list->ideque
          ideque->list
          generator->ideque
          ideque->generator)

  (import (lispkit base)
          (srfi 1)
          (srfi 8)
          (srfi 121))
  
  (begin
    ;; This implements banker's deque as described in Chris Okasaki's "Purely Functional
    ;; Data Structures". It provides amortized O(1) basic operations.
    ;; Originally written for Gauche, and ported to R7RS.

    ;;;
    ;;; Record
    ;;;

    (define-record-type <ideque>
      (%make-dq lenf f lenr r) ideque?
      (lenf dq-lenf)  ; length of front chain
      (f    dq-f)     ; front chain
      (lenr dq-lenr)  ; length of rear chain
      (r    dq-r))    ; rear chain

    ;; We use a singleton for empty deque
    (define *empty* (%make-dq 0 '() 0 '()))

    ;; Common type checker
    (define (%check-ideque x)
      (unless (ideque? x) (error "ideque expected, but got:" x)))
    
    ;;;
    ;;; Constructors
    ;;;

    (define (ideque . args) (list->ideque args))

    (define (ideque-tabulate size init)
      (let ((lenf (quotient size 2))
            (lenr (quotient (+ size 1) 2)))
        (%make-dq lenf (list-tabulate lenf init)
                  lenr (unfold (lambda (n) (= n lenr))
                               (lambda (n) (init (- size n 1)))
                               (lambda (n) (+ n 1))
                               0))))

    (define (ideque-unfold p f g seed)
      (list->ideque (unfold p f g seed)))

    (define (ideque-unfold-right p f g seed)
      (list->ideque (unfold-right p f g seed)))
    ;; alternatively:
    ;; (ideque-reverse (list->ideque (unfold p f g seed)))

    ;; Internal constructor.  Returns a new ideque, with balancing 'front' and
    ;; 'rear' chains.  (The name 'check' comes from Okasaki's book.)

    (define C 3)

    (define (check lenf f lenr r)
      (cond ((> lenf (+ (* lenr C) 1))
             (let* ((i (quotient (+ lenf lenr) 2))
                    (j (- (+ lenf lenr) i))
                    (f. (take f i))
                    (r. (append r (reverse (drop f i)))))
               (%make-dq i f. j r.)))
            ((> lenr (+ (* lenf C) 1))
             (let* ((j (quotient (+ lenf lenr) 2))
                    (i (- (+ lenf lenr) j))
                    (r. (take r j))
                    (f. (append f (reverse (drop r j)))))
               (%make-dq i f. j r.)))
            (else (%make-dq lenf f lenr r))))

    ;;;
    ;;; Basic operations
    ;;;

    (define (ideque-empty? dq)
      (%check-ideque dq)
      (and (zero? (dq-lenf dq)) (zero? (dq-lenr dq))))

    (define (ideque-add-front dq x)
      (%check-ideque dq)
      (check (+ (dq-lenf dq) 1) (cons x (dq-f dq)) (dq-lenr dq) (dq-r dq)))

    (define (ideque-front dq)
      (%check-ideque dq)
      (if (zero? (dq-lenf dq))
        (if (zero? (dq-lenr dq))
          (error "Empty deque:" dq)
          (car (dq-r dq)))
        (car (dq-f dq))))

    (define (ideque-remove-front dq)
      (%check-ideque dq)
      (if (zero? (dq-lenf dq))
        (if (zero? (dq-lenr dq))
          (error "Empty deque:" dq)
          *empty*)
        (check (- (dq-lenf dq) 1) (cdr (dq-f dq)) (dq-lenr dq) (dq-r dq))))

    (define (ideque-add-back dq x)
      (%check-ideque dq)
      (check (dq-lenf dq) (dq-f dq) (+ (dq-lenr dq) 1) (cons x (dq-r dq))))

    (define (ideque-back dq)
      (%check-ideque dq)
      (if (zero? (dq-lenr dq))
        (if (zero? (dq-lenf dq))
          (error "Empty deque:" dq)
          (car (dq-f dq)))
        (car (dq-r dq))))

    (define (ideque-remove-back dq)
      (%check-ideque dq)
      (if (zero? (dq-lenr dq))
        (if (zero? (dq-lenf dq))
          (error "Empty deque:" dq)
          *empty*)
        (check (dq-lenf dq) (dq-f dq) (- (dq-lenr dq) 1) (cdr (dq-r dq)))))

    (define (ideque-reverse dq)
      (%check-ideque dq)
      (if (ideque-empty? dq)
        *empty*
        (%make-dq (dq-lenr dq) (dq-r dq) (dq-lenf dq) (dq-f dq))))

    ;;
    ;; Other operations
    ;;

    (define ideque=
      (case-lambda
        ((elt=) #t)
        ((elt= ideque) (%check-ideque ideque) #t)
        ((elt= dq1 dq2)
         ;; we optimize two-arg case
         (%check-ideque dq1)
         (%check-ideque dq2)
         (or (eq? dq1 dq2)
             (let ((len1 (+ (dq-lenf dq1) (dq-lenr dq1)))
                   (len2 (+ (dq-lenf dq2) (dq-lenr dq2))))
               (and (= len1 len2)
                    (receive (x t1 t2) (list-prefix= elt= (dq-f dq1) (dq-f dq2))
                      (and x
                           (receive (y r1 r2) (list-prefix= elt= (dq-r dq1) (dq-r dq2))
                             (and y
                                  (if (null? t1)
                                    (list= elt= t2 (reverse r1))
                                    (list= elt= t1 (reverse r2)))))))))))
        ((elt= . dqs)
         ;; The comparison scheme is the same as srfi-1's list=.
         (apply list= elt= (map ideque->list dqs)))))

    ;; Compare two lists up to whichever shorter one.
    ;; Returns the compare result and the tails of uncompared lists.
    (define (list-prefix= elt= a b)
      (let loop ((a a) (b b))
        (cond ((or (null? a) (null? b)) (values #t a b))
              ((elt= (car a) (car b)) (loop (cdr a) (cdr b)))
              (else (values #f a b)))))

    (define (ideque-ref dq n)
      (%check-ideque dq)
      (let ((len (+ (dq-lenf dq) (dq-lenr dq))))
        (cond ((or (< n 0) (>= n len)) (error "Index out of range:" n))
              ((< n (dq-lenf dq)) (list-ref (dq-f dq) n))
              (else (list-ref (dq-r dq) (- len n 1))))))

    (define (%ideque-take dq n)             ; n is within the range
      (let ((lenf (dq-lenf dq))
            (f    (dq-f dq)))
        (if (<= n lenf)
          (check n (take f n) 0 '())
          (let ((lenr. (- n lenf)))
            (check lenf f lenr. (take-right (dq-r dq) lenr.))))))

    (define (%ideque-drop dq n)             ; n is within the range
      (let ((lenf (dq-lenf dq))
            (f    (dq-f dq))
            (lenr (dq-lenr dq))
            (r    (dq-r dq)))
        (if (<= n lenf)
          (check n (drop f n) lenr r)
          (let ((lenr. (- lenr (- n lenf))))
            (check 0 '() lenr. (take r lenr.))))))

    (define (%check-length dq n)
      (unless (<= 0 n (- (ideque-length dq) 1))
        (error "argument is out of range:" n)))

    (define (ideque-take dq n)
      (%check-ideque dq)
      (%check-length dq n)
      (%ideque-take dq n))

    (define (ideque-take-right dq n)
      (%check-ideque dq)
      (%check-length dq n)
      (%ideque-drop dq (- (ideque-length dq) n)))

    (define (ideque-drop dq n)
      (%check-ideque dq)
      (%check-length dq n)
      (%ideque-drop dq n))

    (define (ideque-drop-right dq n)
      (%check-ideque dq)
      (%check-length dq n)
      (%ideque-take dq (- (ideque-length dq) n)))

    (define (ideque-split-at dq n)
      (%check-ideque dq)
      (%check-length dq n)
      (values (%ideque-take dq n)
              (%ideque-drop dq n)))

    (define (ideque-length dq)
      (%check-ideque dq)
      (+ (dq-lenf dq) (dq-lenr dq)))

    (define (ideque-append . dqs)
      ;; We could save some list copying by carefully split dqs into front and
      ;; rear groups and append separately, but for now we don't bother...
      (list->ideque (concatenate (map ideque->list dqs))))

    (define (ideque-count pred dq)
      (%check-ideque dq)
      (+ (count pred (dq-f dq)) (count pred (dq-r dq))))

    (define (ideque-zip dq . dqs)
      ;; An easy way.
      (let ((elts (apply zip (ideque->list dq) (map ideque->list dqs))))
        (check (length elts) elts 0 '())))

    (define (ideque-map proc dq)
      (%check-ideque dq)
      (%make-dq (dq-lenf dq) (map proc (dq-f dq))
                (dq-lenr dq) (map proc (dq-r dq))))

    (define (ideque-filter-map proc dq)
      (%check-ideque dq)
      (let ((f (filter-map proc (dq-f dq)))
            (r (filter-map proc (dq-r dq))))
        (check (length f) f (length r) r)))

    (define (ideque-for-each proc dq)
      (%check-ideque dq)
      (for-each proc (dq-f dq))
      (for-each proc (reverse (dq-r dq))))

    (define (ideque-for-each-right proc dq)
      (%check-ideque dq)
      (for-each proc (dq-r dq))
      (for-each proc (reverse (dq-f dq))))

    (define (ideque-fold proc knil dq)
      (%check-ideque dq)
      (fold proc (fold proc knil (dq-f dq)) (reverse (dq-r dq))))

    (define (ideque-fold-right proc knil dq)
      (%check-ideque dq)
      (fold-right proc (fold-right proc knil (reverse (dq-r dq))) (dq-f dq)))

    (define (ideque-append-map proc dq)
      ;; can be cleverer, but for now...
      (list->ideque (append-map proc (ideque->list dq))))

    (define (%ideque-filter-remove op pred dq)
      (%check-ideque dq)
      (let ((f (op pred (dq-f dq)))
            (r (op pred (dq-r dq))))
        (check (length f) f (length r) r)))

    (define (ideque-filter pred dq) (%ideque-filter-remove filter pred dq))
    (define (ideque-remove pred dq) (%ideque-filter-remove remove pred dq))

    (define (ideque-partition pred dq)
      (%check-ideque dq)
      (receive (f1 f2) (partition pred (dq-f dq))
        (receive (r1 r2) (partition pred (dq-r dq))
          (values (check (length f1) f1 (length r1) r1)
                  (check (length f2) f2 (length r2) r2)))))

    (define *not-found* (cons #f #f)) ; unique value

    (define (%search pred seq1 seq2 failure)
      ;; We could write seek as CPS, but we employ *not-found* instead to avoid
      ;; closure allocation.
      (define (seek pred s)
        (cond ((null? s) *not-found*)
              ((pred (car s)) (car s))
              (else (seek pred (cdr s)))))
      (let ((r (seek pred seq1)))
        (if (not (eq? r *not-found*))
          r
          (let ((r (seek pred (reverse seq2))))
            (if (not (eq? r *not-found*))
              r
              (failure))))))

    (define (ideque-find pred dq . opts)
      (%check-ideque dq)
      (let ((failure (if (pair? opts) (car opts) (lambda () #f))))
        (%search pred (dq-f dq) (dq-r dq) failure)))

    (define (ideque-find-right pred dq . opts)
      (%check-ideque dq)
      (let ((failure (if (pair? opts) (car opts) (lambda () #f))))
        (%search pred (dq-r dq) (dq-f dq) failure)))

    (define (ideque-take-while pred dq)
      (%check-ideque dq)
      (receive (hd tl) (span pred (dq-f dq))
        (if (null? tl)
          (receive (hd. tl.) (span pred (reverse (dq-r dq)))
            (check (dq-lenf dq) (dq-f dq) (length hd.) (reverse hd.)))
          (check (length hd) hd 0 '()))))

    (define (ideque-take-while-right pred dq)
      (%check-ideque dq)
      (ideque-reverse (ideque-take-while pred (ideque-reverse dq))))

    (define (ideque-drop-while pred dq)
      (%check-ideque dq)
      (receive (hd tl) (span pred (dq-f dq))
        (if (null? tl)
          (receive (hd. tl.) (span pred (reverse (dq-r dq)))
            (check (length tl.) tl. 0 '()))
          (check (length tl) tl (dq-lenr dq) (dq-r dq)))))

    (define (ideque-drop-while-right pred dq)
      (%check-ideque dq)
      (ideque-reverse (ideque-drop-while pred (ideque-reverse dq))))

    (define (%idq-span-break op pred dq)
      (%check-ideque dq)
      (receive (head tail) (op pred (dq-f dq))
        (if (null? tail)
          (receive (head. tail.) (op pred (reverse (dq-r dq)))
            (values (check (length head) head (length head.) (reverse head.))
                    (check (length tail.) tail. 0 '())))
          (values (check (length head) head 0 '())
                  (check (length tail) tail (dq-lenr dq) (dq-r dq))))))

    (define (ideque-span pred dq)
      (%idq-span-break span pred dq))

    (define (ideque-break pred dq)
      (%idq-span-break break pred dq))

    (define (ideque-any pred dq)
      (%check-ideque dq)
      (if (null? (dq-r dq))
        (any pred (dq-f dq))
        (or (any pred (dq-f dq)) (any pred (reverse (dq-r dq))))))

    (define (ideque-every pred dq)
      (%check-ideque dq)
      (if (null? (dq-r dq))
        (every pred (dq-f dq))
        (and (every pred (dq-f dq)) (every pred (reverse (dq-r dq))))))

    (define (ideque->list dq)
      (%check-ideque dq)
      (append (dq-f dq) (reverse (dq-r dq))))

    (define (list->ideque lis)
      (check (length lis) lis 0 '()))

    (define (ideque->generator dq)
      (%check-ideque dq)
      (lambda ()
        (if (ideque-empty? dq)
          (eof-object)
          (let ((v (ideque-front dq)))
            (set! dq (ideque-remove-front dq))
            v))))

    (define (generator->ideque gen)
      (list->ideque (generator->list gen)))))
;;; SRFI 135
;;; Immutable Texts
;;;
;;; In Scheme, strings are a mutable data type. Although it "is an error" (R5RS and R7RS) to
;;; use string-set! on literal strings or on strings returned by symbol->string, and any attempt
;;; to do so "should raise an exception" (R6RS), all other strings are mutable.
;;;
;;; Although many mutable strings are never actually mutated, the mere possibility of mutation
;;; complicates specifications of libraries that use strings, encourages precautionary copying
;;; of strings, and precludes structure sharing that could otherwise be used to make procedures
;;; such as substring and string-append faster and more space-efficient.
;;;
;;; This SRFI specifies a new data type of immutable texts. It comes with efficient and portable
;;; sample implementations that guarantee O(1) indexing for both sequential and random access,
;;; even in systems whose string-ref procedure takes linear time. The operations of this new data
;;; type include analogues for all of the non-mutating operations on strings specified by the
;;; R7RS and most of those specified by SRFI 130, but the immutability of texts and uniformity
;;; of character-based indexing simplify the specification of those operations while avoiding
;;; several inefficiencies associated with the mutability of Scheme's strings.
;;;
;;; Copyright (C) William D Clinger (2016).
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE. 

(define-library (srfi 135)

  (export ;; Predicates
          text?
          textual?
          textual-null?
          textual-every
          textual-any

          ;; Constructors
          text
          make-text
          text-tabulate
          text-unfold
          text-unfold-right

          ;; Conversion
          textual->text
          textual->string
          textual->vector
          textual->list
          string->text
          vector->text
          list->text
          reverse-list->text
          textual->utf8
          textual->utf16be
          textual->utf16
          textual->utf16le
          utf8->text
          utf16be->text
          utf16->text
          utf16le->text

          ;; Selection
          text-length
          textual-length
          text-ref
          textual-ref
          subtext
          subtextual
          textual-copy
          textual-take
          textual-take-right
          textual-drop
          textual-drop-right
          textual-pad
          textual-pad-right
          textual-trim
          textual-trim-right
          textual-trim-both

          ;; Replacement
          textual-replace

          ;; Comparison
          textual=?
          textual<?
          textual>?
          textual<=?
          textual>=?
          textual-ci=?
          textual-ci<?
          textual-ci>?
          textual-ci<=?
          textual-ci>=?

          ;; Prefixes & suffixes
          textual-prefix-length
          textual-suffix-length
          textual-prefix?
          textual-suffix?

          ;; Searching
          textual-index
          textual-index-right
          textual-skip
          textual-skip-right
          textual-contains
          textual-contains-right

          ;; Case conversion
          textual-upcase
          textual-downcase
          textual-foldcase
          textual-titlecase

          ;; Concatenation
          textual-append
          textual-concatenate
          textual-concatenate-reverse
          textual-join

          ;; Fold & map & friends
          textual-fold
          textual-fold-right
          textual-map
          textual-for-each
          textual-map-index
          textual-for-each-index
          textual-count
          textual-filter
          textual-remove

          ;; Replication & splitting
          textual-replicate
          textual-split)

  (import (lispkit base)
          (srfi 135 kernel0))

  (begin
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; The following procedures are not part of R7RS (small).
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define (last-pair x)
      (if (and (pair? x) (pair? (cdr x)))
          (last-pair (cdr x))
          x))

    ;;; Returns first n elements of the list x.

    (define (list-take x n)
      (let loop ((n n)
                 (x x)
                 (y '()))
        (if (= n 0)
            (reverse y)
            (loop (- n 1) (cdr x) (cons (car x) y)))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; Some macros to make textual arguments and optional arguments
    ;;; less painful.
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define-syntax %textual->text
      (syntax-rules ()
        ((_ x)
         (if (string? x)
             (string->text x)
             x))
        ((_ x name arg ...)
         (cond ((string? x)
                (string->text x))
               ((text? x)
                x)
               (else
                (complain name arg ...))))))

    ;;; Several procedures take a first argument that can be either
    ;;; a text or a string.  They can be written as though the first
    ;;; argument is always a text:
    ;;;
    ;;; (define-textual (f textual args ...) ...)

    (define-syntax define-textual
      (syntax-rules ()
        ((_ (f textual arg . args) expr1 expr2 ...)
         (define (f textual arg . args)
           (let ((textual (%textual->text textual 'f textual arg)))
             expr1 expr2 ...)))))

    ;;; Several procedures take optional start and end arguments
    ;;; that follow a textual argument.  They can be written as
    ;;; though the textual argument is always a text, the start
    ;;; and end arguments are always provided, and the start and
    ;;; end arguments are always legal:
    ;;;
    ;;; (define-textual-start-end (f args ... textual start end)
    ;;;   ...)

    (define-syntax define-textual-start-end
      (syntax-rules ()
        ((_ (f textual start end args ...) expr1 expr2 ...)
         (define f
           ;; Don't change this to letrec or an internal definition,
           ;; because recursive calls should call the version that checks.
           (let ((f (lambda (args ... textual start end) expr1 expr2 ...)))
             (case-lambda
              ((args ... textual)
               (let ((text (%textual->text textual f args ... textual)))
                 (f args ... text 0 (%text-length text))))
              ((args ... textual start)
               (let* ((text (%textual->text textual f args ... textual start))
                      (n (%text-length text)))
                 (if (and (exact-integer? start)
                          (<= 0 start n))
                     (f args ... text start n)
                     (complain 'f args ... textual start))))
              ((args ... textual start end)
               (let* ((text (%textual->text textual f args ... textual start end))
                      (n (%text-length text)))
                 (if (and (exact-integer? start)
                          (exact-integer? end)
                          (<= 0 start end n))
                     (f args ... text start end)
                     (complain 'f args ... textual start end))))))))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; Predicates
    ;;;
    ;;; text? is defined by the kernel

    (define (textual? x)
      (or (text? x)
          (string? x)))

    (define (textual-null? txt)
      (= 0 (textual-length txt)))

    (define-textual-start-end (textual-every textual start end pred)
      (if (= start end)
          #t
          (let ((end-1 (- end 1)))
            (let loop ((i start))
              (if (= i end-1)
                  (pred (%text-ref textual i))
                  (and (pred (%text-ref textual i))
                       (loop (+ i 1))))))))

    (define-textual-start-end (textual-any textual start end pred)
      (let loop ((i start))
        (if (= i end)
            #f
            (or (pred (%text-ref textual i))
                (loop (+ i 1))))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; Constructors
    ;;;
    ;;; text-tabulate is defined by the kernel

    (define (make-text n c)
      (text-tabulate (lambda (i) c) n))

    (define (text . chars)
      (string->text (list->string chars)))

    ;;; These next two procedures take care to accumulate texts of
    ;;; the kernel's preferred size, N.

    (define text-unfold
      (case-lambda
       ((stop? mapper succ seed)
        (text-unfold stop? mapper succ seed (text) (lambda (x) (text))))
       ((stop? mapper succ seed base)
        (text-unfold stop? mapper succ seed base (lambda (x) (text))))
       ((stop? mapper succ seed base make-final)
        (let* ((txt (%textual->text (if (char? base) (text base) base)
                                    'text-unfold
                                    stop? mapper succ seed base make-final))
               (k (%text-length txt)))
          (let loop ((k k)
                     (texts (list txt))
                     (chars '())
                     (seed seed))
            (cond ((>= k N)
                   (let* ((k/N   (quotient k N))
                          (k     (- k (* k/N N)))
                          (texts (cons (reverse-list->text (list-tail chars k))
                                       texts))
                          (chars (list-take chars k)))
                     (loop k texts chars seed)))
                  ((stop? seed)
                   (let* ((texts (if (null? chars)
                                     texts
                                     (cons (reverse-list->text chars) texts)))
                          (final (make-final seed))
                          (final2 (cond ((char? final) (text final))
                                        ((string? final) (string->text final))
                                        ((text? final) final)
                                        (else (%bad-final 'text-unfold final)))))
                     (textual-concatenate-reverse texts final2)))
                  (else
                   (let ((x (mapper seed)))
                     (cond ((char? x)
                            (loop (+ k 1)
                                  texts
                                  (cons x chars)
                                  (succ seed)))
                           ((string? x)
                            (loop (+ k (string-length x))
                                  texts
                                  (append (reverse (string->list x)) chars)
                                  (succ seed)))
                           ((text? x)
                            (loop (+ k (%text-length x))
                                  texts
                                  (append (reverse (textual->list x)) chars)
                                  (succ seed)))
                           (else
                            (complain 'text-unfold
                                      stop? mapper succ seed
                                      base make-final)))))))))))

    (define text-unfold-right
      (case-lambda
       ((stop? mapper succ seed)
        (text-unfold-right stop? mapper succ seed (text) (lambda (x) (text))))
       ((stop? mapper succ seed base)
        (text-unfold-right stop? mapper succ seed base (lambda (x) (text))))
       ((stop? mapper succ seed base make-final)
        (let* ((txt (%textual->text (if (char? base) (text base) base)
                                    'text-unfold-right
                                    stop? mapper succ seed base make-final))
               (k (%text-length txt)))
          (let loop ((k k)
                     (texts (list txt))
                     (chars '())
                     (seed seed))
            (cond ((>= k N)
                   (let* ((k/N   (quotient k N))
                          (k     (- k (* k/N N)))
                          (texts (cons (list->text (list-tail chars k)) texts))
                          (chars (list-take chars k)))
                     (loop k texts chars seed)))
                  ((stop? seed)
                   (let* ((texts (if (null? chars)
                                     texts
                                     (cons (list->text chars) texts)))
                          (final (make-final seed))
                          (final2 (cond ((char? final) (text final))
                                        ((string? final) (string->text final))
                                        ((text? final) final)
                                        (else (%bad-final 'text-unfold-right final)))))
                     (textual-concatenate (cons final2 texts))))
                  (else
                   (let ((x (mapper seed)))
                     (cond ((char? x)
                            (loop (+ k 1)
                                  texts
                                  (cons x chars)
                                  (succ seed)))
                           ((string? x)
                            (loop (+ k (string-length x))
                                  texts
                                  (append (string->list x) chars)
                                  (succ seed)))
                           ((text? x)
                            (loop (+ k (%text-length x))
                                  texts
                                  (append (textual->list x) chars)
                                  (succ seed)))
                           (else
                            (complain 'text-unfold-right
                                      stop? mapper succ seed
                                      base make-final)))))))))))

    (define (%bad-final name final)
      (error (string-append (symbol->string name)
                            " : make-final returned illegal value : ")
             final))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; Conversion
    ;;;
    ;;; FIXME: a lot of these could be made more efficient, especially
    ;;; when a string is passed instead of a text.

    (define (textual->text x . rest)
      (cond ((string? x)
             (string->text x))
            ((text? x)
             x)
            ((null? rest)
             (error "illegal argument passed to textual->text : " x))
            (else (apply error rest))))

    (define textual->string
      (case-lambda
       ((txt)
        (if (string? txt)
            txt
            (textual->string txt 0 (textual-length txt))))
       ((txt start)
        (if (string? txt)
            (substring txt start (string-length txt))
            (textual->string txt start (textual-length txt))))
       ((txt start end)
        (let* ((txt (%textual->text txt 'textual->string txt start end))
               (n (- end start))
               (s (make-string n)))
          (do ((i start (+ i 1)))
              ((= i end)
               s)
            (string-set! s (- i start) (%text-ref txt i)))))))

    (define-textual-start-end (textual->vector txt start end)
      (list->vector (string->list (textual->string (subtext txt start end)))))

    (define-textual-start-end (textual->list txt start end)
      (string->list (textual->string (subtext txt start end))))

    (define string->text
      (case-lambda
       ((s)
        (%string->text s))
       ((s start)
        (%string->text (substring s start (string-length s))))
       ((s start end)
        (%string->text (substring s start end)))))

    (define (vector->text v . start/end)
      (%string->text (list->string (apply vector->list v start/end))))

    (define (list->text chars . start/end)
      (apply string->text (list->string chars) start/end))

    (define (reverse-list->text chars)
      (string->text (list->string (reverse chars))))

    ;;; FIXME: if txt is a string, should just call string->utf8

    (define-textual-start-end (textual->utf8 txt start end)
      (string->utf8 (textual->string (subtext txt start end))))

    (define-textual-start-end (textual->utf16 txt start end)
      (%textual->utf16 txt start end #f))

    (define-textual-start-end (textual->utf16be txt start end)
      (%textual->utf16 txt start end 'big))

    (define-textual-start-end (textual->utf16le txt start end)
      (%textual->utf16 txt start end 'little))

    ;;; FIXME: should this check for illegal code points?

    (define (%textual->utf16 txt start end endianness)
      (let* ((n0 (textual-fold (lambda (c n)
                                (cond ((< (char->integer c) #x10000)
                                       (+ n 2))
                                      (else
                                       (+ n 4))))
                              0
                              txt start end))
             (n (if endianness n0 (+ n0 2)))
             (result (make-bytevector n 0))
             (hibits (case endianness
                      ((big) 0)
                      ((little) 1)
                      (else 0)))
             (lobits (- 1 hibits)))
        (if (not endianness)
            (begin (bytevector-u8-set! result 0 #xfe)
                   (bytevector-u8-set! result 1 #xff)))
        (let loop ((i start)
                   (j (if endianness 0 2)))
          (if (= i end)
              result
              (let* ((c (text-ref txt i))
                     (cp (char->integer c)))
                (cond ((< cp #x10000)
                       (let* ((high (quotient cp 256))
                              (low  (- cp (* 256 high))))
                         (bytevector-u8-set! result (+ j hibits) high)
                         (bytevector-u8-set! result (+ j lobits) low))
                       (loop (+ i 1) (+ j 2)))
                      (else
                       (let* ((k (- cp #x10000))
                              (high-surrogate (+ #xd800 (quotient k 1024)))
                              (low-surrogate  (+ #xdc00 (remainder k 1024)))
                              (high0 (quotient high-surrogate 256))
                              (low0  (- high-surrogate (* 256 high0)))
                              (high1 (quotient low-surrogate 256))
                              (low1  (- low-surrogate  (* 256 high1))))
                         (bytevector-u8-set! result (+ j hibits) high0)
                         (bytevector-u8-set! result (+ j lobits) low0)
                         (bytevector-u8-set! result (+ j 2 hibits) high1)
                         (bytevector-u8-set! result (+ j 2 lobits) low1))
                       (loop (+ i 1) (+ j 4)))))))))

    (define utf8->text
      (case-lambda
       ((bv)
        (if (bytevector? bv)
            (string->text (utf8->string bv))
            (complain 'utf8->text bv)))
       ((bv start)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (<= 0 start (bytevector-length bv)))
            (string->text (utf8->string bv start))
            (complain 'utf8->text bv start)))
       ((bv start end)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (exact-integer? end)
                 (<= 0 start end (bytevector-length bv)))
            (string->text (utf8->string bv start end))
            (complain 'utf8->text bv start end)))))

    (define utf16->text
      (case-lambda
       ((bv)
        (if (bytevector? bv)
            (%utf16->text bv 0 (bytevector-length bv) #f)
            (complain 'utf16->text bv)))
       ((bv start)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (<= 0 start (bytevector-length bv)))
            (%utf16->text bv start (bytevector-length bv) #f)
            (complain 'utf16->text bv start)))
       ((bv start end)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (exact-integer? end)
                 (<= 0 start end (bytevector-length bv)))
            (%utf16->text bv start end #f)
            (complain 'utf16->text bv start end)))))

    (define utf16be->text
      (case-lambda
       ((bv)
        (if (bytevector? bv)
            (%utf16->text bv 0 (bytevector-length bv) 'big)
            (complain 'utf16be->text bv)))
       ((bv start)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (<= 0 start (bytevector-length bv)))
            (%utf16->text bv start (bytevector-length bv) 'big)
            (complain 'utf16be->text bv start)))
       ((bv start end)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (exact-integer? end)
                 (<= 0 start end (bytevector-length bv)))
            (%utf16->text bv start end 'big)
            (complain 'utf16be->text bv start end)))))

    (define utf16le->text
      (case-lambda
       ((bv)
        (if (bytevector? bv)
            (%utf16->text bv 0 (bytevector-length bv) 'little)
            (complain 'utf16le->text bv)))
       ((bv start)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (even? start)
                 (<= 0 start (bytevector-length bv)))
            (%utf16->text bv start (bytevector-length bv) 'little)
            (complain 'utf16le->text bv start)))
       ((bv start end)
        (if (and (bytevector? bv)
                 (exact-integer? start)
                 (exact-integer? end)
                 (even? start)
                 (even? end)
                 (<= 0 start end (bytevector-length bv)))
            (%utf16->text bv start end 'little)
            (complain 'utf16le->text bv start end)))))

    (define (%utf16->text bv start end endianness)
      (let* ((bom (and (not endianness)
                       (< start end)
                       (let ((byte0 (bytevector-u8-ref bv start))
                             (byte1 (bytevector-u8-ref bv (+ start 1))))
                         (cond ((and (= byte0 #xfe) (= byte1 #xff))
                                'big)
                               ((and (= byte1 #xfe) (= byte0 #xff))
                                'little)
                               (else #f)))))
             (start (if bom (+ start 2) start))
             (endianness (or endianness bom 'big))
             (hibits (if (eq? endianness 'big) 0 1))
             (lobits (- 1 hibits)))
        (text-unfold
         (lambda (i) (>= i end))
         (lambda (i)
           (let* ((high (bytevector-u8-ref bv (+ i hibits)))
                  (low  (bytevector-u8-ref bv (+ i lobits)))
                  (cp   (if (= high 0) low (+ (* 256 high) low))))
             (cond ((< cp #xd800)
                    (integer->char cp))
                   ((and (< cp #xdc00)
                         (< (+ i 2) end))
                    (let* ((i (+ i 2))
                           (high (bytevector-u8-ref bv (+ i hibits)))
                           (low  (bytevector-u8-ref bv (+ i lobits)))
                           (cp2  (if (= high 0) low (+ (* 256 high) low))))
                      (cond ((<= #xdc00 cp2 #xdfff)
                             (integer->char
                              (+ #x10000
                                 (* 1024 (- cp #xd800))
                                 (- cp2 #xdc00))))
                            (else
                             (%illegal-utf16 bv (- i 2) cp cp2)))))
                   ((< cp #x10000)
                    (integer->char cp))
                   (else
                    (%illegal-utf16 bv i cp)))))
         (lambda (i)
           (let ((cp (+ (* 256 (bytevector-u8-ref bv (+ i hibits)))
                        (bytevector-u8-ref bv (+ i lobits)))))
             (if (or (< cp #xd800)
                     (<= #xe000 cp #xffff))
                 (+ i 2)
                 (+ i 4))))
         start)))

    (define (%illegal-utf16 bv i cp . rest)
      (if (null? rest)
          (error "illegal UTF-16: " bv i cp)
          (error "illegal UTF-16: " bv i cp (car rest))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; Selection
    ;;;
    ;;; text-length, text-ref, and subtext are defined by the kernel

    (define (textual-length txt)
      (cond ((string? txt)
             (string-length txt))
            ((text? txt)
             (%text-length txt))
            (else
             (complain 'textual-length txt))))

    (define (textual-ref txt i)
      (cond ((string? txt)
             (string-ref txt i))
            ((text? txt)
             (%text-ref txt i))
            (else
             (complain 'textual-ref txt))))

    (define-textual (subtextual txt start end)
      (subtext txt start end))

    ;;; FIXME: could be faster, but this procedure shouldn't be used much

    (define-textual-start-end (textual-copy text start end)
      (string->text (textual->string text start end)))

    (define-textual (textual-take txt nchars)
      (subtextual txt 0 nchars))

    (define-textual (textual-drop txt nchars)
      (subtextual txt nchars (%text-length txt)))

    (define-textual (textual-take-right txt nchars)
      (let ((n (%text-length txt)))
        (subtextual txt (- n nchars) n)))

    (define-textual (textual-drop-right txt nchars)
      (let ((n (%text-length txt)))
        (subtextual txt 0 (- n nchars))))

    (define textual-pad
      (case-lambda
       ((txt len)
        (let ((txt (%textual->text txt 'textual-pad txt len)))
          (%text-pad txt len #\space 0 (%text-length txt))))
       ((txt len c)
        (let ((txt (%textual->text txt 'textual-pad txt len c)))
          (%text-pad txt len c 0 (%text-length txt))))
       ((txt len c start)
        (let ((txt (%textual->text txt 'textual-pad txt len c start)))
          (%text-pad txt len c start (%text-length txt))))
       ((txt len c start end)
        (%text-pad (%textual->text txt 'textual-pad txt len c start end)
                   len c start end))))

    (define (%text-pad txt len c start end)
      (if (and (exact-integer? len)
               (char? c)
               (exact-integer? start)
               (exact-integer? end)
               (<= 0 len)
               (<= 0 start end))
          (let* ((n (%text-length txt))
                 (k (- end start)))
            (cond ((not (<= end n))
                   (complain 'textual-pad txt len c start end))
                  ((= n k len)
                   txt)
                  ((= k len)
                   (if (= n k)
                       txt
                       (subtext txt start end)))
                  ((< k len)
                   (textual-append (make-text (- len k) c)
                                   (if (= n k)
                                       txt
                                       (subtext txt start end))))
                  (else
                   (subtext txt (- end len) end))))
          (complain 'textual-pad txt len c start end)))

    (define textual-pad-right
      (case-lambda
       ((txt len)
        (let ((txt (%textual->text txt 'textual-pad-right txt len)))
          (%text-pad-right txt len #\space 0 (%text-length txt))))
       ((txt len c)
        (let ((txt (%textual->text txt 'textual-pad-right txt len c)))
          (%text-pad-right txt len c 0 (%text-length txt))))
       ((txt len c start)
        (let ((txt (%textual->text txt 'textual-pad-right txt len c start)))
          (%text-pad-right txt len c start (%text-length txt))))
       ((txt len c start end)
        (%text-pad-right (%textual->text txt
                                         'textual-pad-right txt len c start end)
                         len c start end))))

    (define (%text-pad-right txt len c start end)
      (if (and (exact-integer? len)
               (char? c)
               (exact-integer? start)
               (exact-integer? end)
               (<= 0 len)
               (<= 0 start end))
          (let* ((n (%text-length txt))
                 (k (- end start)))
            (cond ((not (<= end n))
                   (complain 'textual-pad-right txt len c start end))
                  ((= n k len)
                   txt)
                  ((= k len)
                   (if (= n k)
                       txt
                       (subtext txt start end)))
                  ((< k len)
                   (textual-append (if (= n k)
                                       txt
                                       (subtext txt start end))
                                   (make-text (- len k) c)))
                  (else
                   (subtext txt start (+ start len)))))
          (complain 'textual-pad-right txt len c start end)))

    (define textual-trim
      (case-lambda
       ((txt)
        (textual-trim txt char-whitespace? 0))
       ((txt pred)
        (textual-trim txt pred 0))
       ((txt pred start)
        (let ((txt (%textual->text txt 'textual-trim txt pred start)))
          (%text-trim txt pred start (%text-length txt))))
       ((txt pred start end)
        (let ((txt (%textual->text txt 'textual-trim txt pred start end)))
          (%text-trim txt pred start end)))))

    (define (%text-trim txt pred start end)
      (if (and (procedure? pred)
               (exact-integer? start)
               (exact-integer? end)
               (<= 0 start end (%text-length txt)))
          (let loop ((i start))
            (cond ((= i end)
                   (text))
                  ((pred (%text-ref txt i))
                   (loop (+ i 1)))
                  (else
                   (subtext txt i end))))
          (complain 'textual-trim txt pred start end)))

    (define textual-trim-right
      (case-lambda
       ((txt)
        (textual-trim-right txt char-whitespace? 0))
       ((txt pred)
        (textual-trim-right txt pred 0))
       ((txt pred start)
        (let ((txt (%textual->text txt 'textual-trim-right txt pred start)))
          (%text-trim-right txt pred start (%text-length txt))))
       ((txt pred start end)
        (let ((txt (%textual->text txt 'textual-trim-right txt pred start end)))
          (%text-trim-right txt pred start end)))))

    (define (%text-trim-right txt pred start end)
      (if (and (procedure? pred)
               (exact-integer? start)
               (exact-integer? end)
               (<= 0 start end (%text-length txt)))
          (let loop ((i (- end 1)))
            (cond ((< i start)
                   (text))
                  ((pred (%text-ref txt i))
                   (loop (- i 1)))
                  (else
                   (subtext txt start (+ i 1)))))
          (complain 'textual-trim-right txt pred start end)))

    (define textual-trim-both
      (case-lambda
       ((txt)
        (textual-trim-both txt char-whitespace? 0))
       ((txt pred)
        (textual-trim-both txt pred 0))
       ((txt pred start)
        (let ((txt (%textual->text txt 'textual-trim-both txt pred start)))
          (%text-trim-both txt pred start (%text-length txt))))
       ((txt pred start end)
        (let ((txt (%textual->text txt 'textual-trim-both txt pred start end)))
          (%text-trim-both txt pred start end)))))

    ;;; This is efficient because subtext is fast.

    (define (%text-trim-both txt pred start end)
      (if (and (procedure? pred)
               (exact-integer? start)
               (exact-integer? end)
               (<= 0 start end (%text-length txt)))
          (textual-trim (textual-trim-right txt pred start end)
                        pred)
          (complain 'textual-trim-both txt pred start end)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Replacement

    (define textual-replace
      (case-lambda
       ((txt1 txt2 start1 end1 start2 end2)
        (textual-append (subtextual txt1 0 start1)
                        (subtextual txt2 start2 end2)
                        (subtextual txt1 end1 (textual-length txt1))))
       ((txt1 txt2 start1 end1 start2)
        (textual-append (subtextual txt1 0 start1)
                        (subtextual txt2 start2 (textual-length txt2))
                        (subtextual txt1 end1 (textual-length txt1))))
       ((txt1 txt2 start1 end1)
        (textual-append (subtextual txt1 0 start1)
                        txt2
                        (subtextual txt1 end1 (textual-length txt1))))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Comparison

    (define (make-nary-comparison name binop0)
      (let ((binop (lambda (a b)
                     (let ((a (%textual->text a name a b))
                           (b (%textual->text b name a b)))
                       (binop0 a b)))))
        (letrec ((loop (lambda (first rest)
                         (cond ((null? rest)
                                #t)
                               ((binop first (car rest))
                                (loop (car rest) (cdr rest)))
                               (else
                                #f)))))
          (lambda (a b . rest)
            (if (null? rest)
                (binop a b)
                (and (binop a b)
                     (loop b rest)))))))

    (define textual=?
      (make-nary-comparison 'textual=?
                            (lambda (a b)
                              (%text-compare a b =))))

    (define textual<?
      (make-nary-comparison 'textual<?
                            (lambda (a b)
                              (%text-compare a b <))))

    (define textual<=?
      (make-nary-comparison 'textual<=?
                            (lambda (a b)
                              (%text-compare a b <=))))

    (define textual>?
      (make-nary-comparison 'textual>?
                            (lambda (a b)
                              (%text-compare a b >))))

    (define textual>=?
      (make-nary-comparison 'textual>=?
                            (lambda (a b)
                              (%text-compare a b >=))))

    (define textual-ci=?
      (make-nary-comparison 'textual-ci=?
                            (lambda (a b)
                              (%text-compare-ci a b = string-ci=?))))

    (define textual-ci<?
      (make-nary-comparison 'textual-ci<?
                            (lambda (a b)
                              (%text-compare-ci a b < string-ci<?))))

    (define textual-ci<=?
      (make-nary-comparison 'textual-ci<=?
                            (lambda (a b)
                              (%text-compare-ci a b <= string-ci<=?))))

    (define textual-ci>?
      (make-nary-comparison 'textual-ci>?
                            (lambda (a b)
                              (%text-compare-ci a b > string-ci>?))))

    (define textual-ci>=?
      (make-nary-comparison 'textual-ci>=?
                            (lambda (a b)
                              (%text-compare-ci a b >= string-ci>=?))))

    ;;; Compares texts a and b.
    ;;; Determines whether a is less than b (-1), equal (0), or
    ;;; greater than b (+1), computes the boolean result by
    ;;; calling make-boolean on that numerical value and 0.

    (define (%text-compare a b make-boolean)
      (let* ((na (%text-length a))
             (nb (%text-length b))
             (n (if (<= na nb) na nb)))
        (define (loop i)
          (if (= i n)
              (cond ((< na nb) (make-boolean -1 0))
                    ((> na nb) (make-boolean +1 0))
                    (else (make-boolean 0 0)))
              (let ((ca (%text-ref a i))
                    (cb (%text-ref b i)))
                (cond ((char<? ca cb) (make-boolean -1 0))
                      ((char>? ca cb) (make-boolean +1 0))
                      (else (loop (+ i 1)))))))
        (loop 0)))

    ;;; Compares texts a and b, folding case.
    ;;; If either text contains non-ASCII characters, both are converted
    ;;; to strings and compared using string-pred.

    (define (%text-compare-ci a b make-boolean string-pred)
      (let* ((na (%text-length a))
             (nb (%text-length b))
             (n (if (<= na nb) na nb)))
        (define (loop i)
          (if (= i n)
              (cond ((< na nb) (make-boolean -1 0))
                    ((> na nb) (make-boolean +1 0))
                    (else (make-boolean 0 0)))
              (let ((ca (%text-ref a i))
                    (cb (%text-ref b i)))
                (if (or (char>? ca #\delete)
                        (char>? cb #\delete))
                    (string-pred (textual->string a)
                                 (textual->string b))
                    (let ((ca (char-foldcase ca))
                          (cb (char-foldcase cb)))
                      (cond ((char<? ca cb) (make-boolean -1 0))
                            ((char>? ca cb) (make-boolean +1 0))
                            (else (loop (+ i 1)))))))))
        (loop 0)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Prefixes & suffixes

    ;;; FIXME: this is a prototype of how optional arguments should
    ;;; be handled.

    (define (%make-text-prefix/suffix-proc proc name)
      (case-lambda
       (()
        (complain name))
       ((x)
        (complain name x))
       ((t1 t2)
        (let ((txt1 (%textual->text t1 name t1 t2))
              (txt2 (%textual->text t2 name t1 t2)))
          (proc txt1 txt2 0 (%text-length txt1) 0 (%text-length txt2))))
       ((t1 t2 start1)
        (let* ((txt1 (%textual->text t1 name t1 t2))
               (txt2 (%textual->text t2 name t1 t2))
               (n1 (%text-length txt1)))
          (if (and (exact-integer? start1)
                   (<= 0 start1 n1))
              (proc txt1 txt2 start1 n1 0 (%text-length txt2))
              (complain name t1 t2 start1))))
       ((t1 t2 start1 end1)
        (let* ((txt1 (%textual->text t1 name t1 t2))
               (txt2 (%textual->text t2 name t1 t2))
               (n1 (%text-length txt1)))
          (if (and (exact-integer? start1)
                   (exact-integer? end1)
                   (<= 0 start1 end1 n1))
              (proc txt1 txt2 start1 end1 0 (%text-length txt2))
              (complain name t1 t2 start1 end1))))
       ((t1 t2 start1 end1 start2)
        (let* ((txt1 (%textual->text t1 name t1 t2))
               (txt2 (%textual->text t2 name t1 t2))
               (n1 (%text-length txt1))
               (n2 (%text-length txt2)))
          (if (and (exact-integer? start1)
                   (exact-integer? end1)
                   (exact-integer? start2)
                   (<= 0 start1 end1 n1)
                   (<= 0 start2 n2))
              (proc txt1 txt2 start1 end1 start2 n2)
              (complain name t1 t2 start1 end1 start2))))
       ((t1 t2 start1 end1 start2 end2)
        (let* ((txt1 (%textual->text t1 name t1 t2))
               (txt2 (%textual->text t2 name t1 t2))
               (n1 (%text-length txt1))
               (n2 (%text-length txt2)))
          (if (and (exact-integer? start1)
                   (exact-integer? end1)
                   (exact-integer? start2)
                   (exact-integer? end2)
                   (<= 0 start1 end1 n1)
                   (<= 0 start2 end2 n2))
              (proc txt1 txt2 start1 end1 start2 end2)
              (complain name t1 t2 start1 end1 start2 end2))))
       ((t1 t2 start1 end1 start2 end2 oops . rest)
        (apply complain name t1 t2 start1 end1 start2 end2 oops rest))))

    (define textual-prefix-length
      (%make-text-prefix/suffix-proc
       (lambda (txt1 txt2 start1 end1 start2 end2)
         (%text-prefix-length txt1 txt2 start1 end1 start2 end2))
       'textual-prefix-length))

    (define textual-suffix-length
      (%make-text-prefix/suffix-proc
       (lambda (txt1 txt2 start1 end1 start2 end2)
         (%text-suffix-length txt1 txt2 start1 end1 start2 end2))
       'textual-suffix-length))

    (define textual-prefix?
      (%make-text-prefix/suffix-proc
       (lambda (txt1 txt2 start1 end1 start2 end2)
         (%text-prefix? txt1 txt2 start1 end1 start2 end2))
       'textual-prefix?))

    (define textual-suffix?
      (%make-text-prefix/suffix-proc
       (lambda (txt1 txt2 start1 end1 start2 end2)
         (%text-suffix? txt1 txt2 start1 end1 start2 end2))
       'textual-suffix?))

    ;;; All error checking has already been done.

    (define (%text-prefix-length txt1 txt2 start1 end1 start2 end2)
      (let* ((k1   (- end1 start1))
             (k2   (- end2 start2))
             (k    (min k1 k2))
             (end1 (+ start1 k)))
        (let loop ((i start1)
                   (j start2))
          (cond ((= i end1) k)
                ((char=? (%text-ref txt1 i) (%text-ref txt2 j))
                 (loop (+ i 1) (+ j 1)))
                (else (- i start1))))))

    (define (%text-suffix-length txt1 txt2 start1 end1 start2 end2)
      (let* ((k1     (- end1 start1))
             (k2     (- end2 start2))
             (k      (min k1 k2))
             (start1 (- end1 k)))
        (let loop ((i (- end1 1))
                   (j (- end2 1)))
          (cond ((< i start1) k)
                ((char=? (%text-ref txt1 i) (%text-ref txt2 j))
                 (loop (- i 1) (- j 1)))
                (else (- end1 i 1))))))

    (define (%text-prefix? txt1 txt2 start1 end1 start2 end2)
      (let ((k1 (- end1 start1))
            (k2 (- end2 start2)))
        (and (<= k1 k2)
             (= k1 (%text-prefix-length txt1 txt2 start1 end1 start2 end2)))))

    (define (%text-suffix? txt1 txt2 start1 end1 start2 end2)
      (let ((k1 (- end1 start1))
            (k2 (- end2 start2)))
        (and (<= k1 k2)
             (= k1 (%text-suffix-length txt1 txt2 start1 end1 start2 end2)))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; Searching

    (define-textual (textual-index txt pred . rest)
      (let ((start (if (null? rest) 0 (car rest)))
            (end (if (or (null? rest) (null? (cdr rest)))
                     (%text-length txt)
                     (car (cdr rest)))))
        (if (and (procedure? pred)
                 (exact-integer? start)
                 (exact-integer? end)
                 (<= 0 start end (%text-length txt)))
            (let loop ((i start))
              (cond ((= i end)
                     #f)
                    ((pred (%text-ref txt i))
                     i)
                    (else
                     (loop (+ i 1)))))
            (apply complain 'textual-index txt pred rest))))

    (define-textual (textual-index-right txt pred . rest)
      (let ((start (if (null? rest) 0 (car rest)))
            (end (if (or (null? rest) (null? (cdr rest)))
                     (%text-length txt)
                     (car (cdr rest)))))
        (if (and (procedure? pred)
                 (exact-integer? start)
                 (exact-integer? end)
                 (<= 0 start end (%text-length txt)))
            (let loop ((i (- end 1)))
              (cond ((< i start)
                     #f)
                    ((pred (%text-ref txt i))
                     i)
                    (else
                     (loop (- i 1)))))
            (apply complain 'textual-index-right txt pred rest))))

    (define (textual-skip txt pred . rest)
      (apply textual-index txt (lambda (x) (not (pred x))) rest))

    (define (textual-skip-right txt pred . rest)
      (apply textual-index-right txt (lambda (x) (not (pred x))) rest))

    (define (textual-contains t1 t2 . rest0)
      (let* ((txt1 (%textual->text t1 'textual-contains t1 t2))
             (txt2 (%textual->text t2 'textual-contains t1 t2))
             (rest rest0)
             (start1 (if (null? rest) 0 (car rest)))
             (rest1 (if (null? rest) rest (cdr rest)))
             (end1 (if (null? rest1) (%text-length txt1) (car rest1)))
             (rest2 (if (null? rest1) rest1 (cdr rest1)))
             (start2 (if (null? rest2) 0 (car rest2)))
             (rest3 (if (null? rest2) rest2 (cdr rest2)))
             (end2 (if (null? rest3) (%text-length txt2) (car rest3)))
             (rest4 (if (null? rest3) rest3 (cdr rest3))))
        (if (and (null? rest4)
                 (exact-integer? start1)
                 (exact-integer? end1)
                 (exact-integer? start2)
                 (exact-integer? end2)
                 (<= 0 start1 end1 (%text-length txt1))
                 (<= 0 start2 end2 (%text-length txt2)))
            (%textual-contains txt1 txt2 start1 end1 start2 end2)
            (apply complain 'textual-contains t1 t2 rest0))))

    ;;; No checking needed here.
    ;;;
    ;;; Naive search works well when
    ;;;     txt1 is very short
    ;;;     txt2 is very short
    ;;;     txt2 is almost as long as txt1
    ;;; Boyer-Moore-Horspool search works well when
    ;;;     txt2 is very short
    ;;;     txt1 is considerably longer than txt2, txt2 is not too short,
    ;;;         and the rightmost character of txt2 is distinct from
    ;;;         (in its low 8 bits) from several characters that precede it
    ;;; Rabin-Karp works reasonably well all the time, so is used when
    ;;;     neither naive search nor Boyer-Moore-Horspool do well

    (define %threshold:short1 10)   ; is txt1 shorter than this?
    (define %threshold:short2 3)    ; is txt2 shorter than this?
    (define %threshold:longer 1)    ; is txt1 at least this much longer?
    (define %threshold:rightmost 2) ; are rightmost characters the same?

    (define (%textual-contains txt1 txt2 start1 end1 start2 end2)
      (let ((n1 (- end1 start1))
            (n2 (- end2 start2)))
        (cond ((< n1 %threshold:short1)
               (%textual-contains:naive txt1 txt2 start1 end1 start2 end2))
              ((< (- n1 n2) %threshold:longer)
               (%textual-contains:naive txt1 txt2 start1 end1 start2 end2))
              ((< n2 %threshold:short2)
               (%textual-contains:boyer-moore txt1 txt2 start1 end1 start2 end2))
              ((and (> n2 %threshold:rightmost)
                    (let ((j (remainder (char->integer (text-ref txt2 (- end2 1)))
                                        128)))
                      (let loop ((i (- end2 %threshold:rightmost)))
                        (cond ((= i (- end2 1))
                               #t)
                              ((= j
                                  (remainder (char->integer (text-ref txt2 i))
                                             128))
                               #f)
                              (else
                               (loop (+ i 1)))))))
               (%textual-contains:boyer-moore txt1 txt2 start1 end1 start2 end2))
              (else
               (%textual-contains:rabin-karp txt1 txt2 start1 end1 start2 end2)))))

    (define (%textual-contains:naive txt1 txt2 start1 end1 start2 end2)
      (let* ((n1 (- end1 start1))
             (n2 (- end2 start2))
             (lim1 (- end1 n2)))
        (let loop ((i start1))
          (cond ((> i lim1)
                 #f)
                ((textual-prefix? txt2 txt1 start2 end2 i end1)
                 i)
                (else
                 (loop (+ i 1)))))))

    (define (%textual-contains:rabin-karp txt1 txt2 start1 end1 start2 end2)
      (define (hash txt start end)
        (do ((i start (+ i 1))
             (h 0 (+ h (char->integer (text-ref txt i)))))
            ((= i end)
             h)))
      (let* ((n1 (- end1 start1))
             (n2 (- end2 start2))
             (lim1 (- end1 n2))
             (h1 (hash txt1 start1 (min (+ start1 n2) end1)))
             (h2 (hash txt2 start2 end2)))
        (let loop ((i start1)
                   (h1 h1))
          (cond ((> i lim1)
                 #f)
                ((and (= h1 h2)
                      (textual-prefix? txt2 txt1 start2 end2 i end1))
                 i)
                ((= i lim1)
                 #f)
                (else
                 (loop (+ i 1)
                       (+ (- h1 (char->integer (text-ref txt1 i)))
                          (char->integer (text-ref txt1 (+ i n2))))))))))

    ;;; This is actually the Boyer-Moore-Horspool algorithm,
    ;;; but the name is already pretty long.

    (define (%textual-contains:boyer-moore txt1 txt2 start1 end1 start2 end2)
      (if (= start2 end2)
          start1
          (let* ((n1 (- end1 start1))
                 (n2 (- end2 start2))
                 (lim1 (- end1 n2))
                 (lastchar (text-ref txt2 (- end2 1)))
                 (lastj (remainder (char->integer lastchar) 128))
                 (table (make-vector 128 n2)))
            (do ((i 0 (+ i 1)))
                ((>= i (- n2 1)))
              (let* ((c  (text-ref txt2 (+ i start2)))
                     (cp (char->integer c))
                     (j  (remainder cp 128)))
                (vector-set! table j (- n2 i 1))))
            (let loop ((i start1))
              (if (>= i lim1)
                  (if (and (= i lim1)
                           (textual-prefix? txt2 txt1 start2 end2 i end1))
                      i
                      #f)
                  (let* ((c  (text-ref txt1 (+ i n2 -1)))
                         (cp (char->integer c))
                         (j  (remainder cp 128)))
                    (cond ((not (char=? c lastchar))
                           (loop (+ i (vector-ref table j))))
                          ((textual-prefix? txt2 txt1 start2 end2 i end1)
                           i)
                          (else
                           (loop (+ i (vector-ref table lastj)))))))))))

    ;;; FIXME: no Rabin-Karp algorithm for now

    (define (textual-contains-right t1 t2 . rest0)
      (let* ((txt1 (%textual->text t1 'textual-contains-right t1 t2))
             (txt2 (%textual->text t2 'textual-contains-right t1 t2))
             (rest rest0)
             (start1 (if (null? rest) 0 (car rest)))
             (rest1 (if (null? rest) rest (cdr rest)))
             (end1 (if (null? rest1) (%text-length txt1) (car rest1)))
             (rest2 (if (null? rest1) rest1 (cdr rest1)))
             (start2 (if (null? rest2) 0 (car rest2)))
             (rest3 (if (null? rest2) rest2 (cdr rest2)))
             (end2 (if (null? rest3) (%text-length txt2) (car rest3)))
             (rest4 (if (null? rest3) rest3 (cdr rest3))))
        (if (and (null? rest4)
                 (exact-integer? start1)
                 (exact-integer? end1)
                 (exact-integer? start2)
                 (exact-integer? end2)
                 (<= 0 start1 end1 (%text-length txt1))
                 (<= 0 start2 end2 (%text-length txt2)))
            (%textual-contains-right txt1 txt2 start1 end1 start2 end2)
            (apply complain 'textual-contains-right t1 t2 rest0))))

    (define (%textual-contains-right txt1 txt2 start1 end1 start2 end2)
      (let ((n1 (- end1 start1))
            (n2 (- end2 start2)))
        (cond ((< n1 %threshold:short1)
               (%textual-contains-right:naive
                txt1 txt2 start1 end1 start2 end2))
              ((< (- n1 n2) %threshold:longer)
               (%textual-contains-right:naive
                txt1 txt2 start1 end1 start2 end2))
              ((< n2 %threshold:short2)
               (%textual-contains-right:boyer-moore
                txt1 txt2 start1 end1 start2 end2))
              (else
               (%textual-contains-right:boyer-moore
                txt1 txt2 start1 end1 start2 end2)))))

    (define (%textual-contains-right:naive txt1 txt2 start1 end1 start2 end2)
      (let* ((n1 (- end1 start1))
             (n2 (- end2 start2))
             (lim1 (- end1 n2)))
        (let loop ((i lim1))
          (cond ((< i start1)
                 #f)
                ((textual-prefix? txt2 txt1 start2 end2 i end1)
                 i)
                (else
                 (loop (- i 1)))))))

    ;;; This is actually the Boyer-Moore-Horspool algorithm,
    ;;; but the name is already pretty long.

    (define (%textual-contains-right:boyer-moore txt1 txt2 start1 end1 start2 end2)
      (if (= start2 end2)
          end1
          (let* ((n1 (- end1 start1))
                 (n2 (- end2 start2))
                 (firstchar (text-ref txt2 0))
                 (firstj (remainder (char->integer firstchar) 128))
                 (table (make-vector 128 n2)))
            (do ((i (- n2 1) (- i 1)))
                ((<= i 0))
              (let* ((c  (text-ref txt2 (+ i start2)))
                     (cp (char->integer c))
                     (j  (remainder cp 128)))
                (vector-set! table j i)))
            (let loop ((i (- end1 n2)))
              (if (<= i start1)
                  (if (and (= i start1)
                           (textual-prefix? txt2 txt1 start2 end2 i end1))
                      i
                      #f)
                  (let* ((c  (text-ref txt1 i))
                         (cp (char->integer c))
                         (j  (remainder cp 128)))
                    (cond ((not (char=? c firstchar))
                           (loop (- i (vector-ref table j))))
                          ((textual-prefix? txt2 txt1 start2 end2 i end1)
                           i)
                          (else
                           (loop (- i (vector-ref table firstj)))))))))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Case conversion

    ;;; Two special cases:
    ;;;     the given text can be returned as is
    ;;;     the given text is entirely ASCII
    ;;;
    ;;; For all other cases, calls the corresponding procedures for strings.

    (define (textual-upcase txt)
      (cond ((string? txt)
             (string->text (string-upcase txt)))
            ((text? txt)
             (%text-upcase txt))
            (else
             (complain 'textual-upcase txt))))

    (define (textual-downcase txt)
      (cond ((string? txt)
             (string->text (string-downcase txt)))
            ((text? txt)
             (%text-downcase txt string-downcase))
            (else
             (complain 'textual-downcase txt))))

    (define (textual-foldcase txt)
      (cond ((string? txt)
             (string->text (string-foldcase txt)))
            ((text? txt)
             (%text-downcase txt string-foldcase))
            (else
             (complain 'textual-foldcase txt))))

    (define (textual-titlecase txt)
      (cond ((string? txt)
             (string->text (string-titlecase txt)))
            ((text? txt)
             (string->text
              (string-titlecase (textual->string txt))))
            (else
             (complain 'textual-titlecase txt))))

    (define (%text-upcase txt)
      (let* ((n (%text-length txt)))

        ;; So far, no conversion has been necessary.

        (define (fastest i)
          (if (= i n)
              txt
              (let ((c (%text-ref txt i)))
                (cond ((char>? c #\delete)
                       (textual-upcase (textual->string txt)))
                      ((char<=? #\a c #\z)
                       (fast i (list (subtext txt 0 i)) '()))
                      (else
                       (fastest (+ i 1)))))))

        ;; Conversions are necessary but it's been all-ASCII so far.
        ;; The upcased text for characters with index < i is
        ;;     (text-concatenate (reverse (cons (list->text (reverse chars))
        ;;                                      texts)))

        (define (fast i texts chars)
          (cond ((= i n)
                 (if (null? chars)
                     (textual-concatenate-reverse texts)
                     (textual-concatenate-reverse texts
                                                  (reverse-list->text chars))))
                ((and (= 0 (remainder i N))
                      (not (null? chars)))
                 (fast i (cons (reverse-list->text chars) texts) '()))
                (else
                 (let ((c (%text-ref txt i)))
                   (cond ((char>? c #\delete)
                          (textual-append (textual-concatenate-reverse texts)
                                          (reverse-list->text chars)
                                          (string->text
                                           (string-upcase (subtext txt i n)))))
                         ((char<=? #\a c #\z)
                          (fast (+ i 1) texts (cons (char-upcase c) chars)))
                         (else
                          (fast (+ i 1) texts (cons c chars))))))))

        (fastest 0)))

    ;;; The string-caser is either string-downcase or string-foldcase.
    ;;; For ASCII, down-casing and fold-casing are the same.

    (define (%text-downcase txt string-caser)
      (let* ((n (%text-length txt)))

        ;; So far, no conversion has been necessary.

        (define (fastest i)
          (if (= i n)
              txt
              (let ((c (%text-ref txt i)))
                (cond ((char>? c #\delete)
                       (textual-downcase (textual->string txt)))
                      ((char<=? #\A c #\Z)
                       (fast i (list (subtext txt 0 i)) '()))
                      (else
                       (fastest (+ i 1)))))))

        ;; Conversions are necessary but it's been all-ASCII so far.
        ;; The downcased text for characters with index < i is
        ;;     (textual-concatenate (reverse (cons (list->text (reverse chars))
        ;;                                         texts)))

        (define (fast i texts chars)
          (cond ((= i n)
                 (if (null? chars)
                     (textual-concatenate-reverse texts)
                     (textual-concatenate-reverse texts
                                                  (reverse-list->text chars))))
                ((and (= 0 (remainder i N))
                      (not (null? chars)))
                 (fast i (cons (reverse-list->text chars) texts) '()))
                (else
                 (let ((c (%text-ref txt i)))
                   (cond ((char>? c #\delete)
                          (textual-append (textual-concatenate-reverse texts)
                                          (reverse-list->text chars)
                                          (string->text
                                           (string-caser (subtext txt i n)))))
                         ((char<=? #\A c #\Z)
                          (fast (+ i 1) texts (cons (char-downcase c) chars)))
                         (else
                          (fast (+ i 1) texts (cons c chars))))))))

        (fastest 0)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Concatenation
    ;;;
    ;;; textual-concatenate is defined by the kernel

    (define (textual-append . texts)
      (textual-concatenate texts))

    (define textual-concatenate-reverse
      (case-lambda
       ((texts)
        (textual-concatenate (reverse texts)))
       ((texts final-textual)
        (textual-concatenate-reverse (cons final-textual texts)))
       ((texts final-textual end)
        (textual-concatenate-reverse texts
                                     (subtext
                                      (%textual->text final-textual
                                                      'textual-concatenate-reverse
                                                      texts final-textual end)
                                      0 end)))))

    (define textual-join
      (case-lambda
       ((textuals)
        (textual-join textuals " " 'infix))
       ((textuals delimiter)
        (textual-join textuals delimiter 'infix))
       ((textuals delimiter grammar)
        (let* ((texts (map (lambda (t) (%textual->text t 'textual-join textuals))
                           textuals))
               (delimiter (%textual->text delimiter
                                          'textual-join textuals delimiter)))
          (if (memq grammar '(infix strict-infix prefix suffix))
              (if (null? texts)
                  (case grammar
                    ((strict-infix)
                     (complain 'textual-join textuals delimiter grammar))
                    (else (text)))
                  (let loop ((rtxts (reverse texts))
                             (texts (if (eq? grammar 'suffix)
                                        (list delimiter)
                                        '())))
                    (cond ((null? rtxts)
                           (let ((texts (if (eq? grammar 'prefix)
                                            texts
                                            (cdr texts))))
                             (textual-concatenate texts)))
                          (else
                           (loop (cdr rtxts)
                                 (cons delimiter (cons (car rtxts) texts)))))))
              (complain 'textual-join textuals delimiter grammar))))))                

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Fold & map & friends

    (define-textual-start-end (textual-fold txt start end kons knil)
      (if (procedure? kons)
          (let loop ((knil knil)
                     (i start))
            (if (< i end)
                (loop (kons (%text-ref txt i) knil)
                      (+ i 1))
                knil))
          (complain 'textual-fold kons knil txt start end)))

    (define-textual-start-end (textual-fold-right txt start end kons knil)
      (if (procedure? kons)
          (let loop ((knil knil)
                     (i (- end 1)))
            (if (>= i start)
                (loop (kons (%text-ref txt i) knil)
                      (- i 1))
                knil))
          (complain 'textual-fold-right kons knil txt start end)))

    (define textual-map
      (case-lambda
        ((proc txt)              (%textual-map1 proc txt))
        ((proc txt1 txt2 . rest) (%textual-mapn proc (cons txt1 (cons txt2 rest))))))

    (define (%textual-map1 proc txt)
      (let ((txt (%textual->text txt 'textual-map proc txt)))
        (if (procedure? proc)
            (let ((n (%text-length txt)))
              (let loop ((i 0)
                         (pieces '())
                         (chars '())
                         (k 0))
                (cond ((= i n)
                        (textual-concatenate (reverse (%text-map-pieces pieces chars))))
                      ((>= k N)
                        (loop i (%text-map-pieces pieces chars) '() (remainder k N)))
                      (else
                        (let ((x (proc (%text-ref txt i))))
                          (loop (+ i 1)
                                pieces
                                (cons x chars)
                                (+ k (cond ((char? x)   1)
                                           ((string? x) (string-length x))
                                           ((text? x)   (%text-length x))
                                           (else        (%textual-map-bad-result proc x))))))))))
            (complain 'textual-map proc txt))))

    (define (%textual-mapn proc textuals)
      (if (procedure? proc)
          (let* ((texts (map (lambda (txt)
                               (%textual->text txt 'textual-map textuals))
                             textuals))
                 (n (apply min (map %text-length texts))))
            (let loop ((i 0)
                       (pieces '())
                       (chars '())
                       (k 0))
              (cond ((= i n)
                     (textual-concatenate
                      (reverse (%text-map-pieces pieces chars))))
                    ((>= k N)
                     (loop i
                           (%text-map-pieces pieces chars)
                           '()
                           (remainder k N)))
                    (else
                     (let ((x (apply proc (%fetch-all texts i))))
                       (loop (+ i 1)
                             pieces
                             (cons x chars)
                             (+ k (cond ((char? x) 1)
                                        ((string? x) (string-length x))
                                        ((text? x) (%text-length x))
                                        (else
                                         (%textual-map-bad-result proc x))))))))))
          (complain 'textual-map proc textuals)))

    (define (%textual-map-bad-result proc x)
      (error "textual-map: proc returned non-character" x))

    ;;; Given a list of texts and a list of mixed characters/strings/texts,
    ;;; in reverse order, converts the second argument into a text and
    ;;; returns that text consed onto the first argument.

    (define (%text-map-pieces texts stuff)
      (let loop ((revstuff stuff)
                 (stuff '())
                 (n 0))
        (if (null? revstuff)
            (let ((s (make-string n))) ; probably short
              (let inner-loop ((stuff stuff)
                               (i 0))
                (if (null? stuff)
                    (cons (string->text s) texts)
                    (let ((x (car stuff)))
                      (cond ((char? x)
                              (string-set! s i x)
                              (inner-loop (cdr stuff) (+ i 1)))
                            ((string? x)
                              (string-copy! s i x)
                              (inner-loop (cdr stuff) (+ i (string-length x))))
                            (else
                              (string-copy! s i (textual->string x))
                              (inner-loop (cdr stuff) (+ i (text-length x)))))))))
            (let* ((x (car revstuff))
                   (revstuff (cdr revstuff))
                   (stuff (cons x stuff)))
              (loop revstuff
                    stuff
                    (+ n (cond ((char? x)   1)
                               ((string? x) (string-length x))
                               (else        (text-length x)))))))))

    (define textual-for-each
      (case-lambda
       ((proc txt)
        (%textual-for-each1 proc txt))
       ((proc txt1 txt2 . rest)
        (%textual-for-eachn proc (cons txt1 (cons txt2 rest))))))

    (define (%textual-for-each1 proc txt)
      (let ((txt (%textual->text txt 'textual-for-each proc txt)))
        (if (procedure? proc)
            (let ((n (%text-length txt)))
              (let loop ((i 0))
                (if (< i n)
                    (begin (proc (%text-ref txt i))
                           (loop (+ i 1))))))
            (complain 'textual-for-each proc txt))))

    (define (%textual-for-eachn proc textuals)
      (if (procedure? proc)
          (let* ((texts (map (lambda (txt)
                               (%textual->text txt 'textual-map textuals))
                             textuals))
                 (n (apply min (map %text-length texts))))
            (let loop ((i 0))
              (if (< i n)
                  (begin (apply proc (%fetch-all texts i))
                         (loop (+ i 1))))))
          (complain 'textual-for-each proc textuals)))

    (define (%fetch-all texts i)
      (if (null? texts)
          '()
          (cons (%text-ref (car texts) i)
                (%fetch-all (cdr texts) i))))

    ;;; FIXME: there's no reason to convert a string to a text here

    (define-textual-start-end (textual-map-index txt start end proc)
      (if (procedure? proc)
          (let ((n end))
            (let loop ((i start)
                       (pieces '())
                       (chars '())
                       (k 0))
              (cond ((= i n)
                     (textual-concatenate
                      (reverse (%text-map-pieces pieces chars))))
                    ((>= k N)
                     (loop i
                           (%text-map-pieces pieces chars)
                           '()
                           (remainder k N)))
                    (else
                     (let ((x (proc i)))
                       (loop (+ i 1)
                             pieces
                             (cons x chars)
                             (+ k (cond ((char? x) 1)
                                        ((string? x) (string-length x))
                                        ((text? x) (%text-length x))
                                        (else
                                         (%textual-map-bad-result proc x))))))))))
          (complain 'textual-map-index proc txt)))

    ;;; FIXME: there's no reason to convert a string to a text here

    (define-textual-start-end (textual-for-each-index txt start end proc)
      (if (procedure? proc)
          (let ((n end))
            (let loop ((i start))
              (if (< i n)
                  (begin (proc i)
                         (loop (+ i 1))))))
          (complain 'textual-for-each-index proc txt)))

    (define-textual (textual-count txt pred . rest)
      (let ((start (if (null? rest) 0 (car rest)))
            (end (if (or (null? rest) (null? (cdr rest)))
                     (%text-length txt)
                     (car (cdr rest)))))
        (if (and (procedure? pred)
                 (or (null? rest) (null? (cdr rest)) (null? (cdr (cdr rest))))
                 (exact-integer? start)
                 (exact-integer? end)
                 (<= 0 start end (%text-length txt)))
            (textual-fold (lambda (c n)
                            (if (pred c)
                                (+ n 1)
                                n))
                          0 txt start end)
            (complain 'textual-count txt pred start end))))

    (define-textual-start-end (textual-filter txt start end pred)
      (if (procedure? pred)
          (textual-map (lambda (c) (if (pred c) c ""))
                       (subtext txt start end))
          (complain 'textual-filter pred txt start end)))

    ;;; FIXME: checks arguments twice

    (define-textual-start-end (textual-remove txt start end pred)
      (textual-filter (lambda (c) (not (pred c))) txt start end))

    ;;; FIXME: not linear-time unless string-set! is O(1)
    ;;; (but this is a pretty useless procedure anyway)

    (define-textual-start-end (textual-reverse txt start end)
      (let* ((n (- end start))
             (s (make-string n)))
        (do ((i start (+ i 1)))
            ((= i end)
             (string->text s))
          (string-set! s (- n (- i start) 1) (%text-ref txt i)))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; Replication & splitting

    (define textual-replicate
      (case-lambda
       ((s from to start end)
        (let ((s (%textual->text s 'textual-replicate s from to start end)))
          (textual-replicate (subtext s start end) from to)))
       ((s from to start)
        (let ((s (%textual->text s 'textual-replicate s from to start)))
          (textual-replicate (subtext s start (textual-length s)) from to)))
       ((s0 from to)
        (let* ((s (%textual->text s0 'textual-replicate s0 from to))
               (n (- to from))
               (len (%text-length s)))
          (cond ((= n 0)
                 "")
                ((or (< n 0)
                     (= len 0))
                 (complain 'textual-replicate s from to))
                (else
                 (let* ((from (modulo from len)) ; make from non-negative
                        (to (+ from n)))
                   (do ((replicates '() (cons s replicates))
                        (replicates-length 0 (+ replicates-length len)))
                       ((>= replicates-length to)
                        (subtext (apply textual-append replicates)
                                 from to))))))))))

    (define textual-split
      (case-lambda
       ((s delimiter grammar limit start end)
        (textual-split (subtextual s start end) delimiter grammar limit))
       ((s delimiter grammar limit start)
        (textual-split (subtextual s start (textual-length s))
                       delimiter grammar limit))
       ((s delimiter)
        (textual-split s delimiter 'infix #f))
       ((s delimiter grammar)
        (textual-split s delimiter grammar #f))
       ((s0 delimiter grammar limit)
        (let* ((bad-arguments
                 (lambda () (complain 'textual-split s0 delimiter grammar limit)))
               (s (%textual->text s0 'textual-split s0 delimiter grammar limit))
               (delimiter
                (%textual->text delimiter
                                'textual-split s0 delimiter grammar limit))
               (limit (or limit (%text-length s)))
               (splits
                (cond ((= 0 (%text-length delimiter))
                       (%text-split-into-characters s limit))
                      (else
                       (%text-split-using-word s delimiter limit)))))
          (case grammar
            ((infix strict-infix)
             (if (= 0 (%text-length s))
                 (if (eq? grammar 'infix)
                     '()
                     (bad-arguments))
                 splits))
            ((prefix)
             (if (and (pair? splits)
                      (= 0 (%text-length (car splits))))
                 (cdr splits)
                 splits))
            ((suffix)
             (if (and (pair? splits)
                      (= 0 (%text-length (car (last-pair splits)))))
                 (reverse (cdr (reverse splits)))
                 splits))
            (else
             (bad-arguments)))))))

    (define (%text-split-into-characters s limit)
      (let ((n (%text-length s)))
        (cond ((> n (+ limit 1))
               (append (%text-split-into-characters (subtext s 0 limit) limit)
                       (list (subtext s limit n))))
              (else
               (map text (textual->list s))))))

    ;;; FIXME: inefficient

    (define (%text-split-using-word txt sep limit)
      (let loop ((i 0)
                 (limit limit)
                 (texts '()))
        (if (= 0 limit)
            (reverse (cons (subtext txt i (%text-length txt)) texts))
            (let ((i2 (textual-contains txt sep i)))
              (if i2
                  (loop (+ i2 (%text-length sep))
                        (- limit 1)
                        (cons (subtext txt i i2) texts))
                  (loop i 0 texts))))))
  )
)
;;; SRFI 137
;;; Minimal Unique Types
;;;
;;; This SRFI is intended to standardize a primitive run-time mechanism to create
;;; disjoint types. This mechanism provides a simple hook to create new data types at
;;; run time that are disjoint from all existing types. allowing portable libraries to
;;; implement SRFI 9, SRFI 99, SRFI 131, SRFI 135, R6RS records, Chicken records, CLOS,
;;; persistent databases, remote access to data on servers, and the like on top of it.
;;; It is also portably implementable and usable entirely separately from any of these.
;;;
;;; Note that there is no concept of a type object here: a type is simply a name for a
;;; group of closely linked procedures that allow the creation and manipulation of type
;;; instances (which are objects) and subtypes. This SRFI exposes no ambient authority,
;;; and relies entirely on module exports for access control.
;;;
;;; Author of spec: John Cowan, Marc Nieper-Wißkirchen
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 137)
  (export make-type)
  (import (rename (lispkit base)
                  (make-type native-make-type)))

  (begin
    (define (make-make-type mk-type)
      (lambda (payload)
        (let-values (((tpe constructor predicate accessor mk-subtype) (mk-type payload)))
          (values (lambda () payload)
                  constructor
                  predicate
                  accessor
                  (make-make-type mk-subtype)))))

    (define make-type (make-make-type native-make-type))
  )
)
;;; SRFI 14
;;;
;;; The ability to efficiently represent and manipulate sets of characters is an unglamorous
;;; but very useful capability for text-processing code -- one that tends to pop up in the
;;; definitions of other libraries. Hence it is useful to specify a general substrate for this
;;; functionality early. SRFI 14 defines a general library that provides this functionality.
;;;
;;; This implementation is LispKit-specific and is based on characters being UTF16 code units.
;;;
;;; Author of spec: Olin Shivers
;;;
;;; Copyright © 2019 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 14)

  (export char-set?
          char-set=
          char-set<=
          char-set-hash
          char-set-cursor
          char-set-ref
          char-set-cursor-next
          end-of-char-set?
          char-set-fold
          char-set-unfold
          char-set-unfold!
          char-set-for-each
          char-set-map
          char-set-copy
          char-set
          list->char-set
          string->char-set
          list->char-set!
          string->char-set!
          char-set-filter
          ucs-range->char-set
          ->char-set
          char-set-filter!
          ucs-range->char-set!
          char-set->list
          char-set->string
          char-set-size
          char-set-count
          char-set-contains?
          char-set-every
          char-set-any
          char-set-adjoin
          char-set-delete
          char-set-adjoin!
          char-set-delete!
          char-set-complement
          char-set-union
          char-set-intersection
          char-set-complement!
          char-set-union!
          char-set-intersection!
          char-set-difference
          char-set-xor
          char-set-diff+intersection
          char-set-difference!
          char-set-xor!
          char-set-diff+intersection!
          char-set:lower-case
          char-set:upper-case
          char-set:title-case
          char-set:letter
          char-set:digit
          char-set:letter+digit
          char-set:graphic
          char-set:printing
          char-set:whitespace
          char-set:iso-control
          char-set:punctuation
          char-set:symbol
          char-set:hex-digit
          char-set:blank
          char-set:ascii
          char-set:empty
          char-set:full)

  (import (lispkit base)
          (rename (lispkit char-set)
                  (char-set=? char-set=)
                  (char-set<=? char-set<=)
                  (char-set-every? char-set-every)
                  (char-set-any? char-set-any)))
)
;;; SRFI 141
;;; Integer Division Operators
;;; 
;;; Given a QUOTIENT and REMAINDER defined for nonnegative numerators
;;; and positive denominators implementing the truncated, floored, or
;;; Euclidean integer division, this SRFI implements a number of other
;;; integer division operators.
;;; 
;;; Copyright © 2010-2011 Taylor R. Campbell. All rights reserved.
;;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions
;;; are met:
;;; 
;;; 1. Redistributions of source code must retain the above copyright
;;;    notice, this list of conditions and the following disclaimer.
;;; 2. Redistributions in binary form must reproduce the above copyright
;;;    notice, this list of conditions and the following disclaimer in the
;;;    documentation and/or other materials provided with the distribution.
;;;
;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
;;; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
;;; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;;; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;;; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;;; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;;; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;;; SUCH DAMAGE.
;;;
;;; LispKit Port:
;;;   Copyright © 2022 Matthias Zenger. All rights reserved.

(define-library (srfi 141)

  (export ceiling/
          ceiling-quotient
          ceiling-remainder
          floor/
          floor-quotient
          floor-remainder
          truncate/
          truncate-quotient
          truncate-remainder
          round/
          round-quotient
          round-remainder
          euclidean/
          euclidean-quotient
          euclidean-remainder
          balanced/
          balanced-quotient
          balanced-remainder
          ceiling/
          ceiling-quotient
          ceiling-remainder)
  
  (import (lispkit base))
  
  (begin
    
    ;;;; Shims
    
    (define-syntax receive
      (syntax-rules ()
        ((receive formals expression body ...)
         (call-with-values (lambda () expression)
                           (lambda formals body ...)))))
    
    
    ;;;; Ceiling
    
    (define (ceiling/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d))
                 (ceiling-/- n d))
                ((negative? n)
                 (let ((n (- 0 n)))
                   (values (- 0 (quotient n d)) (- 0 (remainder n d)))))
                ((negative? d)
                 (let ((d (- 0 d)))
                   (values (- 0 (quotient n d)) (remainder n d))))
                (else
                 (ceiling+/+ n d)))
          (let ((q (ceiling (/ n d))))
            (values q (- n (* d q))))))
    
    (define (ceiling-/- n d)
      (let ((n (- 0 n)) (d (- 0 d)))
        (let ((q (quotient n d)) (r (remainder n d)))
          (if (zero? r)
              (values q r)
              (values (+ q 1) (- d r))))))
    
    (define (ceiling+/+ n d)
      (let ((q (quotient n d)) (r (remainder n d)))
        (if (zero? r)
            (values q r)
            (values (+ q 1) (- r d)))))
    
    (define (ceiling-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d))
                 (receive (q r) (ceiling-/- n d) r q))
                ((negative? n) (- 0 (quotient (- 0 n) d)))
                ((negative? d) (- 0 (quotient n (- 0 d))))
                (else (receive (q r) (ceiling+/+ n d) r q)))
          (ceiling (/ n d))))
    
    (define (ceiling-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d))
                 (receive (q r) (ceiling-/- n d) q r))
                ((negative? n) (- 0 (remainder (- 0 n) d)))
                ((negative? d) (remainder n (- 0 d)))
                (else (receive (q r) (ceiling+/+ n d) q r)))
          (- n (* d (ceiling (/ n d))))))
    
    ;;;; Euclidean Division
    
    ;;; 0 <= r < |d|
    
    (define (euclidean/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d)) (ceiling-/- n d))
                ((negative? n) (floor-/+ n d))
                ((negative? d)
                 (let ((d (- 0 d)))
                   (values (- 0 (quotient n d)) (remainder n d))))
                (else (values (quotient n d) (remainder n d))))
          (let ((q (if (negative? d) (ceiling (/ n d)) (floor (/ n d)))))
            (values q (- n (* d q))))))
    
    (define (euclidean-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d))
                 (receive (q r) (ceiling-/- n d) r q))
                ((negative? n) (receive (q r) (floor-/+ n d) r q))
                ((negative? d) (- 0 (quotient n (- 0 d))))
                (else (quotient n d)))
          (if (negative? d) (ceiling (/ n d)) (floor (/ n d)))))
    
    (define (euclidean-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d))
                 (receive (q r) (ceiling-/- n d) q r))
                ((negative? n) (receive (q r) (floor-/+ n d) q r))
                ((negative? d) (remainder n (- 0 d)))
                (else (remainder n d)))
          (- n (* d (if (negative? d) (ceiling (/ n d)) (floor (/ n d)))))))
    
    ;;;; Floor
    
    ; (define (floor/ n d)
    ;   (if (and (exact-integer? n) (exact-integer? d))
    ;       (cond ((and (negative? n) (negative? d))
    ;              (let ((n (- 0 n)) (d (- 0 d)))
    ;                (values (quotient n d) (- 0 (remainder n d)))))
    ;             ((negative? n) (floor-/+ n d))
    ;             ((negative? d) (floor+/- n d))
    ;             (else (values (quotient n d) (remainder n d))))
    ;       (let ((q (floor (/ n d))))
    ;         (values q (- n (* d q))))))
    
    (define (floor-/+ n d)
      (let ((n (- 0 n)))
        (let ((q (quotient n d)) (r (remainder n d)))
          (if (zero? r)
              (values (- 0 q) r)
              (values (- (- 0 q) 1) (- d r))))))
    
    (define (floor+/- n d)
      (let ((d (- 0 d)))
        (let ((q (quotient n d)) (r (remainder n d)))
          (if (zero? r)
              (values (- 0 q) r)
              (values (- (- 0 q) 1) (- r d))))))
    
    ; (define (floor-quotient n d)
    ;   (if (and (exact-integer? n) (exact-integer? d))
    ;       (cond ((and (negative? n) (negative? d)) (quotient (- 0 n) (- 0 d)))
    ;             ((negative? n) (receive (q r) (floor-/+ n d) r q))
    ;             ((negative? d) (receive (q r) (floor+/- n d) r q))
    ;             (else (quotient n d)))
    ;       (floor (/ n d))))
    ; 
    ; (define (floor-remainder n d)
    ;   (if (and (exact-integer? n) (exact-integer? d))
    ;       (cond ((and (negative? n) (negative? d))
    ;              (- 0 (remainder (- 0 n) (- 0 d))))
    ;             ((negative? n) (receive (q r) (floor-/+ n d) q r))
    ;             ((negative? d) (receive (q r) (floor+/- n d) q r))
    ;             (else (remainder n d)))
    ;       (- n (* d (floor (/ n d))))))
    
    ;;;; Round Ties to Even
    
    (define (round/ n d)
      (define (divide n d adjust leave)
        (let ((q (quotient n d)) (r (remainder n d)))
          (if (and (not (zero? r))
                   (or (and (odd? q) (even? d) (divisible? n (quotient d 2)))
                       (< d (* 2 r))))
              (adjust (+ q 1) (- r d))
              (leave q r))))
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d))
                 (divide (- 0 n) (- 0 d)
                   (lambda (q r) (values q (- 0 r)))
                   (lambda (q r) (values q (- 0 r)))))
                ((negative? n)
                 (divide (- 0 n) d
                   (lambda (q r) (values (- 0 q) (- 0 r)))
                   (lambda (q r) (values (- 0 q) (- 0 r)))))
                ((negative? d)
                 (divide n (- 0 d)
                   (lambda (q r) (values (- 0 q) r))
                   (lambda (q r) (values (- 0 q) r))))
                (else
                 (let ((return (lambda (q r) (values q r))))
                   (divide n d return return))))
          (let ((q (round (/ n d))))
            (values q (- n (* d q))))))
    
    (define (divisible? n d)
      ;; This operation admits a faster implementation than the one given
      ;; here.
      (zero? (remainder n d)))
    
    (define (round-quotient n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (receive (q r) (round/ n d)
            r                               ;ignore
            q)
          (round (/ n d))))
    
    (define (round-remainder n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (receive (q r) (round/ n d)
            q                               ;ignore
            r)
          (- n (* d (round (/ n d))))))
    
    ;;;; Truncate
    
    ; (define (truncate/ n d)
    ;   (if (and (exact-integer? n) (exact-integer? d))
    ;       (cond ((and (negative? n) (negative? d))
    ;              (let ((n (- 0 n)) (d (- 0 d)))
    ;                (values (quotient n d) (- 0 (remainder n d)))))
    ;             ((negative? n)
    ;              (let ((n (- 0 n)))
    ;                (values (- 0 (quotient n d)) (- 0 (remainder n d)))))
    ;             ((negative? d)
    ;              (let ((d (- 0 d)))
    ;                (values (- 0 (quotient n d)) (remainder n d))))
    ;             (else
    ;              (values (quotient n d) (remainder n d))))
    ;       (let ((q (truncate (/ n d))))
    ;         (values q (- n (* d q))))))
    ; 
    ; (define (truncate-quotient n d)
    ;   (if (and (exact-integer? n) (exact-integer? d))
    ;       (cond ((and (negative? n) (negative? d)) (quotient (- 0 n) (- 0 d)))
    ;             ((negative? n) (- 0 (quotient (- 0 n) d)))
    ;             ((negative? d) (- 0 (quotient n (- 0 d))))
    ;             (else (quotient n d)))
    ;       (truncate (/ n d))))
    ; 
    ; (define (truncate-remainder n d)
    ;   (if (and (exact-integer? n) (exact-integer? d))
    ;       (cond ((and (negative? n) (negative? d))
    ;              (- 0 (remainder (- 0 n) (- 0 d))))
    ;             ((negative? n) (- 0 (remainder (- 0 n) d)))
    ;             ((negative? d) (remainder n (- 0 d)))
    ;             (else (remainder n d)))
    ;       (- n (* d (truncate (/ n d))))))
    
    ;;; Copyright 2015 William D Clinger.
    ;;;
    ;;; Permission to copy this software, in whole or in part, to use this
    ;;; software for any lawful purpose, and to redistribute this software
    ;;; is granted subject to the restriction that all copies made of this
    ;;; software must include this copyright and permission notice in full.
    ;;;
    ;;; I also request that you send me a copy of any improvements that you
    ;;; make to this software so that they may be incorporated within it to
    ;;; the benefit of the Scheme community.
    
    (define (balanced/ x y)
      (call-with-values
       (lambda () (euclidean/ x y))
       (lambda (q r)
         (cond ((< r (abs (/ y 2)))
                (values q r))
               ((> y 0)
                (values (+ q 1) (- x (* (+ q 1) y))))
               (else
                (values (- q 1) (- x (* (- q 1) y))))))))
    
    (define (balanced-quotient x y)
      (call-with-values
       (lambda () (balanced/ x y))
       (lambda (q r) q)))
    
    (define (balanced-remainder x y)
      (call-with-values
       (lambda () (balanced/ x y))
       (lambda (q r) r)))
  )
)
;;; SRFI 142
;;; Bitwise Operations
;;; 
;;; This SRFI defines a coherent and comprehensive set of procedures for performing bitwise
;;; logical operations on integers. The code below is based on a reference implementation of
;;; the spec in terms of a set of seven core operators. The implementation is portable, as
;;; efficient as practical with pure Scheme arithmetic, and open source.
;;;
;;; Specification:
;;;   Copyright © 2016 John Cowan. All rights reserved.
;;;
;;;   Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;;   software and associated documentation files (the "Software"), to deal in the Software
;;;   without restriction, including without limitation the rights to use, copy, modify,
;;;   merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;;   permit persons to whom the Software is furnished to do so, subject to the following
;;;   conditions:
;;;
;;;   The above copyright notice and this permission notice shall be included in all copies
;;;   or substantial portions of the Software.
;;;
;;; Implementation:
;;;   Portions authored by Olin Shivers, who put the code into public domain. The code
;;;   was originally written for SRFI 33.
;;;
;;;   Portions Copyright (C) 1991, 1993, 2001, 2003, 2005 Aubrey Jaffer
;;;   This implementation of the seven core functions required by SRFI 33
;;;   (bitwise-not, bitwise-and, bitwise-ior, bitwise-xor, arithmetic-shift,
;;;   bit-count, integer-length) is drawn from the SRFI 60 implementation.
;;;   Here is Shivers's comment on this code in SRFI 33:
;;;
;;;     The [following] implementations of these functions use [only] R4RS
;;;     arithmetic, so a simple-minded implementation again doesn't need to
;;;     do much to support them -- however, [these] general implementations
;;;     are terribly inefficient relative to native support and should *not*
;;;     be used except in case of dire emergency. (It's quite clever code,
;;;     nonetheless, to provide the semantics with such little support.)
;;;
;;;     Permission to copy this software, to modify it, to redistribute it,
;;;     to distribute modified versions, and to use it for any purpose is
;;;     granted, subject to the following restrictions and understandings.
;;;
;;;     1.  Any copy made of this software must include this copyright notice in full.
;;;     2.  I have made no warranty or representation that the operation of this software
;;;         will be error-free, and I am under no obligation to provide any services, by
;;;         way of maintenance, update, or otherwise.
;;;     3.  In conjunction with products arising from the use of this material, there shall
;;;         be no use of my name in any advertising, promotional, or sales literature without
;;;         prior written consent in each case.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 142)

  (export bitwise-not
          bitwise-and
          bitwise-ior
          bitwise-xor
          bitwise-eqv
          bitwise-nand
          bitwise-nor
          bitwise-andc1
          bitwise-andc2
          bitwise-orc1
          bitwise-orc2)

  (export arithmetic-shift
          bit-count
          integer-length
          bitwise-if
          bit-set?
          copy-bit
          bit-swap
          any-bit-set?
          every-bit-set?
          first-set-bit)

  (export bit-field
          bit-field-any?
          bit-field-every?
          bit-field-clear
          bit-field-set
          bit-field-replace
          bit-field-replace-same
          bit-field-rotate
          bit-field-reverse)

  (export integer->list
          list->integer
          integer->vector
          vector->integer bits
          bitwise-fold
          bitwise-for-each
          bitwise-unfold
          make-bitwise-generator)

  (import (except (lispkit base) bitwise-not
                                 bitwise-and
                                 bitwise-ior
                                 bitwise-xor
                                 bitwise-if
                                 arithmetic-shift
                                 integer-length
                                 bit-count
                                 bit-set?
                                 copy-bit))

  (begin
    (define (bitwise-not n) (- -1 n))

    (define logical:boole-xor
     '#(#(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)
        #(1 0 3 2 5 4 7 6 9 8 11 10 13 12 15 14)
        #(2 3 0 1 6 7 4 5 10 11 8 9 14 15 12 13)
        #(3 2 1 0 7 6 5 4 11 10 9 8 15 14 13 12)
        #(4 5 6 7 0 1 2 3 12 13 14 15 8 9 10 11)
        #(5 4 7 6 1 0 3 2 13 12 15 14 9 8 11 10)
        #(6 7 4 5 2 3 0 1 14 15 12 13 10 11 8 9)
        #(7 6 5 4 3 2 1 0 15 14 13 12 11 10 9 8)
        #(8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7)
        #(9 8 11 10 13 12 15 14 1 0 3 2 5 4 7 6)
        #(10 11 8 9 14 15 12 13 2 3 0 1 6 7 4 5)
        #(11 10 9 8 15 14 13 12 3 2 1 0 7 6 5 4)
        #(12 13 14 15 8 9 10 11 4 5 6 7 0 1 2 3)
        #(13 12 15 14 9 8 11 10 5 4 7 6 1 0 3 2)
        #(14 15 12 13 10 11 8 9 6 7 4 5 2 3 0 1)
        #(15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0)))

    (define logical:boole-and
     '#(#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
        #(0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1)
        #(0 0 2 2 0 0 2 2 0 0 2 2 0 0 2 2)
        #(0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3)
        #(0 0 0 0 4 4 4 4 0 0 0 0 4 4 4 4)
        #(0 1 0 1 4 5 4 5 0 1 0 1 4 5 4 5)
        #(0 0 2 2 4 4 6 6 0 0 2 2 4 4 6 6)
        #(0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7)
        #(0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8)
        #(0 1 0 1 0 1 0 1 8 9 8 9 8 9 8 9)
        #(0 0 2 2 0 0 2 2 8 8 10 10 8 8 10 10)
        #(0 1 2 3 0 1 2 3 8 9 10 11 8 9 10 11)
        #(0 0 0 0 4 4 4 4 8 8 8 8 12 12 12 12)
        #(0 1 0 1 4 5 4 5 8 9 8 9 12 13 12 13)
        #(0 0 2 2 4 4 6 6 8 8 10 10 12 12 14 14)
        #(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)))

    (define (logical:ash-4 x)
      (if (negative? x)
          (+ -1 (quotient (+ 1 x) 16))
          (quotient x 16)))

    (define (logical:reduce op4 ident)
      (lambda args
        (do ((res ident (op4 res (car rgs) 1 0))
             (rgs args (cdr rgs)))
            ((null? rgs) res))))

    (define bitwise-and
      (letrec
          ((lgand
            (lambda (n2 n1 scl acc)
              (cond ((= n1 n2) (+ acc (* scl n1)))
                    ((zero? n2) acc)
                    ((zero? n1) acc)
                    (else (lgand (logical:ash-4 n2)
                                 (logical:ash-4 n1)
                                 (* 16 scl)
                                 (+ (* (vector-ref (vector-ref logical:boole-and (modulo n1 16))
                                                   (modulo n2 16))
                                       scl)
                                    acc)))))))
        (logical:reduce lgand -1)))

    (define bitwise-ior
      (letrec
          ((lgior
            (lambda (n2 n1 scl acc)
              (cond ((= n1 n2) (+ acc (* scl n1)))
                    ((zero? n2) (+ acc (* scl n1)))
                    ((zero? n1) (+ acc (* scl n2)))
                    (else (lgior (logical:ash-4 n2)
                                 (logical:ash-4 n1)
                                 (* 16 scl)
                                 (+ (* (- 15 (vector-ref
                                              (vector-ref logical:boole-and (- 15 (modulo n1 16)))
                                              (- 15 (modulo n2 16))))
                                       scl)
                                    acc)))))))
        (logical:reduce lgior 0)))

    (define bitwise-xor
      (letrec
          ((lgxor
            (lambda (n2 n1 scl acc)
              (cond ((= n1 n2) acc)
                    ((zero? n2) (+ acc (* scl n1)))
                    ((zero? n1) (+ acc (* scl n2)))
                    (else (lgxor (logical:ash-4 n2)
                                 (logical:ash-4 n1)
                                 (* 16 scl)
                                 (+ (* (vector-ref (vector-ref logical:boole-xor (modulo n1 16))
                                                   (modulo n2 16))
                                       scl)
                                    acc)))))))
        (logical:reduce lgxor 0)))

    (define (arithmetic-shift n count)
      (if (negative? count)
          (let ((k (expt 2 (- count))))
            (if (negative? n)
                (+ -1 (quotient (+ 1 n) k))
                (quotient n k)))
          (* (expt 2 count) n)))

    (define integer-length
      (letrec ((intlen (lambda (n tot)
                         (case n
                           ((0 -1) (+ 0 tot))
                           ((1 -2) (+ 1 tot))
                           ((2 3 -3 -4) (+ 2 tot))
                           ((4 5 6 7 -5 -6 -7 -8) (+ 3 tot))
                           (else (intlen (logical:ash-4 n) (+ 4 tot)))))))
        (lambda (n) (intlen n 0))))

    (define bit-count
      (letrec ((logcnt (lambda (n tot)
                         (if (zero? n)
                             tot
                             (logcnt (quotient n 16)
                                     (+ (vector-ref
                                         '#(0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4)
                                         (modulo n 16))
                                        tot))))))
        (lambda (n)
          (cond ((negative? n) (logcnt (bitwise-not n) 0))
                ((positive? n) (logcnt n 0))
                (else 0)))))
  )

  (begin
    (define (bitwise-nand  i j)  (bitwise-not (bitwise-and i j)))
    (define (bitwise-nor   i j)  (bitwise-not (bitwise-ior i j)))
    (define (bitwise-andc1 i j)  (bitwise-and (bitwise-not i) j))	
    (define (bitwise-andc2 i j)  (bitwise-and i (bitwise-not j)))	
    (define (bitwise-orc1  i j)  (bitwise-ior (bitwise-not i) j))
    (define (bitwise-orc2  i j)  (bitwise-ior i (bitwise-not j)))

    ;;; This is a general definition, but less than efficient.  It should also
    ;;; receive primitive compiler/interpreter support so that the expensive
    ;;; n-ary mechanism is not invoked in the standard cases -- that is,
    ;;; an application of BITWISE-EQV should be rewritten into an equivalent
    ;;; tree applying some two-argument primitive to the arguments, in the
    ;;; same manner that statically-known n-ary applications of associative
    ;;; operations such as + and * are handled efficiently:
    ;;;   (bitwise-eqv)         => -1
    ;;;   (bitwise-eqv i)       => i
    ;;;   (bitwise-eqv i j)     => (%bitwise-eqv i j)
    ;;;   (bitwise-eqv i j k)   => (%bitwise-eqv (%bitwise-eqv i j) k)
    ;;;   (bitwise-eqv i j k l) => (%bitwise-eqv (%bitwise-eqv (%bitwise-eqv i j) k) l)

    (define (bitwise-eqv . args)
      (let lp ((args args) (ans -1))
        (if (pair? args)
            (lp (cdr args) (bitwise-not (bitwise-xor ans (car args))))
            ans)))

    ;;; Helper function -- make a mask of SIZE 1-bits, e.g. (%MASK 3) = #b111.
    ;;; Suppose your Scheme's fixnums are N bits wide (counting the sign bit,
    ;;; not counting any tag bits). This version, due to Marc Feeley, will 
    ;;; handle SIZE in the range [0,N-1] without overflowing to bignums. 
    ;;; (For SIZE >= N, the correct bignum value is also produced.)

    (define (%mask size) (bitwise-not (arithmetic-shift -1 size)))

    ;;; This alternate, mathematically-equivalent expression
    ;;;     (- (arithmetic-shift 1 size) 1)
    ;;; is not as good -- it only handles SIZE in the range [0,N-2] without
    ;;; overflowing to bignums.
    ;;;
    ;;; Finally, note that even Feeley's expression can't build an N-bit mask
    ;;; without bignum help. This is fundamental, since the interpretation
    ;;; of fixed-size fixnum bit patterns as semi-infinite-bit-strings is that
    ;;; you replicate the high bit out to infinity. So you have to have a
    ;;; zero "stop bit" appearing after that highest one bit to turn off the
    ;;; replication of the ones.

    (define (bit-set? index n) 
      (not (zero? (bitwise-and (arithmetic-shift 1 index) n))))

    (define (any-bit-set? test-bits n) (not (zero? (bitwise-and test-bits n))))

    (define (every-bit-set? test-bits n) (= test-bits (bitwise-and test-bits n)))

    (define (bitwise-if mask n0 n1)
      (bitwise-ior (bitwise-and mask n1) (bitwise-and (bitwise-not mask) n0)))

    ;;; Bit-field ops

    (define (bit-field n start end)
      (bitwise-and (%mask (- end start)) (arithmetic-shift n (- start))))

    (define (bit-field-any? n start end)
      (not (zero? (bitwise-and (arithmetic-shift n (- start)) (%mask (- end start))))))

    ;; Part of Olin's late revsisions; code by John Cowan; public domain.
    (define (bit-field-every? n start end)
      (let ((m (%mask (- end start))))
        (eqv? m (bitwise-and (arithmetic-shift n (- start)) m))))

    ;; Integrating i-b-f reduces nicely.
    (define (bit-field-clear n start end)
      (bit-field-replace n 0 start end))

    ;; Counterpart to above, not in SRFI 33, written by John Cowan, public domain
    (define (bit-field-set n start end)
      (bit-field-replace n -1 start end))

    ;; This three-line version won't fixnum-overflow on fixnum args.
    (define (bit-field-replace n newfield start end)
      (let ((m (%mask (- end start))))
        (bitwise-ior (bitwise-and n (bitwise-not (arithmetic-shift m start)))
                     (arithmetic-shift (bitwise-and newfield m) start))))

    (define (bit-field-replace-same to from start end)
      (bitwise-if (arithmetic-shift (%mask (- end start)) start) to from))

    (define (first-set-bit i) (- (bit-count (bitwise-xor i (- i 1))) 1)))

  (begin
    (define (bit-field-rotate n count start end)
      (define width (- end start))
      (set! count (modulo count width))
      (let ((mask (bitwise-not (arithmetic-shift -1 width))))
        (define zn (bitwise-and mask (arithmetic-shift n (- start))))
        (bitwise-ior (arithmetic-shift
                       (bitwise-ior (bitwise-and mask (arithmetic-shift zn count))
                                    (arithmetic-shift zn (- count width)))
                       start)
                     (bitwise-and (bitwise-not (arithmetic-shift mask start)) n))))

    (define (bit-reverse k n)
      (do ((m (if (negative? n) (bitwise-not n) n) (arithmetic-shift m -1))
           (k (+ -1 k) (+ -1 k))
           (rvs 0 (bitwise-ior (arithmetic-shift rvs 1) (bitwise-and 1 m))))
          ((negative? k) (if (negative? n) (bitwise-not rvs) rvs))))
    
    (define (bit-field-reverse n start end)
      (define width (- end start))
      (let ((mask (bitwise-not (arithmetic-shift -1 width))))
        (define zn (bitwise-and mask (arithmetic-shift n (- start))))
        (bitwise-ior (arithmetic-shift (bit-reverse width zn) start)
                     (bitwise-and (bitwise-not (arithmetic-shift mask start)) n))))

    (define (copy-bit index to bool)
      (if bool
          (bitwise-ior to (arithmetic-shift 1 index))
          (bitwise-and to (bitwise-not (arithmetic-shift 1 index)))))

    (define (integer->list k . len)
      (if (null? len)
          (do ((k k (arithmetic-shift k -1))
               (lst '() (cons (odd? k) lst)))
              ((<= k 0) (reverse lst)))
          (do ((idx (+ -1 (car len)) (+ -1 idx))
               (k k (arithmetic-shift k -1))
               (lst '() (cons (odd? k) lst)))
              ((negative? idx) (reverse lst)))))

    (define (list->integer bools)
      (do ((bs (reverse bools) (cdr bs))
           (acc 0 (+ acc acc (if (car bs) 1 0))))
          ((null? bs) acc)))

    (define (bits . bools)
      (list->integer bools)))

  (begin
    ;;;; bitwise-other - functions not from SRFI 33 or SRFI 60
    ;;; Copyright John Cowan 2017

    (define integer->vector
      (case-lambda ((i)     (list->vector (integer->list i)))
                   ((i len) (list->vector (integer->list i len)))))

    (define (vector->integer vector)
      (list->integer (vector->list vector)))

    (define (bit-swap n1 n2 i)
      (let ((n1-bit (bit-set? n1 i))
            (n2-bit (bit-set? n2 i)))
        (copy-bit n2 (copy-bit n1 i n2-bit) n1-bit)))

    (define (bitwise-fold proc seed i)
      (let ((len (integer-length i)))
        (let loop ((n 0) (r seed))
          (if (= n len) r (loop (+ n 1) (proc (bit-set? n i) r))))))

    (define (bitwise-for-each proc i)
      (let ((len (integer-length i)))
        (let loop ((n 0))
          (when (< n len)
            (proc (bit-set? n i))
            (loop (+ n 1))))))

    (define (bitwise-unfold stop? mapper successor seed)
      (let loop ((n 0) (result 0) (state seed))
        (if (stop? state)
            result
            (loop (+ n 1)
                  (copy-bit n result (mapper state))
                  (successor state)))))

    (define (make-bitwise-generator i)
      (lambda ()
        (let ((bit (bit-set? 0 i)))
          (set! i (arithmetic-shift i -1))
          bit)))))
;;; SRFI 143
;;; Fixnums
;;;
;;; This SRFI describes arithmetic procedures applicable to a limited range of exact
;;; integers only. These procedures are semantically similar to the corresponding
;;; generic-arithmetic procedures, but allow more efficient implementations.
;;; 
;;; Fixnums are an implementation-defined subset of the exact integers. The fixnum range
;;; is defined as a closed interval [-2w-1, 2w-1-1], where w is an integer greater than or
;;; equal to 24. Every mathematical integer within an implementation's fixnum range must
;;; correspond to an exact integer that is representable within the implementation.
;;; A fixnum is an exact integer whose value lies within this fixnum range.
;;; 
;;; Fixnum operations perform integer arithmetic on their fixnum arguments. If any argument
;;; is not a fixnum, or if the mathematical result is not representable as a fixnum,
;;; it is an error: this is known as the fixnum rule. In particular, this means that fixnum
;;; operations may return a mathematically incorrect fixnum in these situations without
;;; raising an error. Consequently, when this SRFI says things like "fx+ is semantically
;;; equivalent to +", the phrase "except for the effects of the fixnum rule" is to be
;;; understood.
;;; 
;;; Author of spec: John Cowan
;;; 
;;; Copyright © 2021 Matthias Zenger. All rights reserved.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 143)
  
  (export fx-width
          fx-greatest
          fx-least
          fixnum?
          fx=?
          fx<?
          fx>?
          fx<=?
          fx>=?
          fxzero?
          fxpositive?
          fxnegative?
          fxodd?
          fxeven?
          fxmax
          fxmin
          fxneg
          fx+
          fx-
          fx*
          fxquotient
          fxremainder
          fxabs
          fxsquare
          fxsqrt
          fx+/carry
          fx-/carry
          fx*/carry
          fxnot
          fxand
          fxior
          fxxor
          fxarithmetic-shift
          fxarithmetic-shift-left
          fxarithmetic-shift-right
          fxbit-count
          fxlength
          fxif
          fxbit-set?
          fxcopy-bit
          fxfirst-set-bit
          fxbit-field
          fxbit-field-rotate
          fxbit-field-reverse)
  
  (import (rename (lispkit base)
            (fx= fx=?)
            (fx> fx>?)
            (fx< fx<?)
            (fx>= fx>=?)
            (fx<= fx<=?)
            (bit-count fxbit-count)
            (quotient fxquotient)
            (exact-integer-sqrt fxsqrt)
            (fxfirst-bit-set fxfirst-set-bit)
            (fxsqrt lispkit:fxsqrt)
            (fxbit-set? lispkit:fxbit-set?)
            (fxcopy-bit lispkit:fxcopy-bit)
            (fxbit-count lispkit:fxbit-count)))
  
  ;; Generic implementation of carry functions from the R6RS standard.
  ;; These implementations of fx+/carry, fx-/carry, and fx*/carry are very inefficient,
  ;; and should be replaced by proper-subset? assembly language operations if at all possible.
  (begin
    
    (define exp-width (expt 2 fx-width))
    
    (define (fx+/carry i j k)
      (let*-values (((s) (+ i j k))
                    ((q r) (balanced/ s exp-width)))
        (values r q)))
    
    (define (fx-/carry i j k)
      (let*-values (((d) (- i j k))
                    ((q r) (balanced/ d exp-width)))
        (values r q)))
    
    (define (fx*/carry i j k)
      (let*-values (((s) (+ (* i j) k))
                    ((q r) (balanced/ s exp-width)))
        (values r q)))
    
    ;;; Helper functions from SRFI 151
    
    (define (floor-/+ n d)
      (let ((n (- 0 n)))
        (let ((q (quotient n d)) (r (remainder n d)))
          (if (zero? r)
              (values (- 0 q) r)
              (values (- (- 0 q) 1) (- d r))))))
    
    (define (ceiling-/- n d)
      (let ((n (- 0 n)) (d (- 0 d)))
        (let ((q (quotient n d)) (r (remainder n d)))
          (if (zero? r)
              (values q r)
              (values (+ q 1) (- d r))))))
    
    (define (euclidean/ n d)
      (if (and (exact-integer? n) (exact-integer? d))
          (cond ((and (negative? n) (negative? d)) (ceiling-/- n d))
                ((negative? n) (floor-/+ n d))
                ((negative? d)
                  (let ((d (- 0 d)))
                    (values (- 0 (quotient n d)) (remainder n d))))
                (else (values (quotient n d) (remainder n d))))
          (let ((q (if (negative? d) (ceiling (/ n d)) (floor (/ n d)))))
            (values q (- n (* d q))))))
    
    (define (balanced/ x y)
      (call-with-values
        (lambda () (euclidean/ x y))
        (lambda (q r)
          (cond ((< r (abs (/ y 2)))
                  (values q r))
                ((> y 0)
                  (values (+ q 1) (- x (* (+ q 1) y))))
                (else
                  (values (- q 1) (- x (* (- q 1) y))))))))
  )
  
  ;; Implementation based on existing fixnum procedures provided by library
  ;; `(lispkit math)`.
  (begin
    
    (define (fxneg i)
      (fx- i))
    
    (define (fxsquare i)
      (fx* i i))
    
    (define (fxbit-set? i j)
      (bit-set? j i))
    
    (define (fxcopy-bit index to bool)
      (copy-bit to index (if (eq? bool #t) 1 (if (eq? bool #f) 0 bool))))
    
    (define (mask start end)
      (bitwise-not (arithmetic-shift -1 (- end start))))
    
    (define (fxbit-field n start end)
      (bitwise-and (mask start end) (arithmetic-shift n (- start))))
    
    (define (fxbit-field-rotate n count start end)
      (define width (- end start))
      (set! count (modulo count width))
      (let ((mask (bitwise-not (arithmetic-shift -1 width))))
        (define zn (bitwise-and mask (arithmetic-shift n (- start))))
        (bitwise-ior (arithmetic-shift
                       (bitwise-ior (bitwise-and mask (arithmetic-shift zn count))
                                    (arithmetic-shift zn (- count width)))
                       start)
                     (bitwise-and (bitwise-not (arithmetic-shift mask start)) n))))
    
    (define (bit-reverse k n)
      (do ((m (if (negative? n) (bitwise-not n) n) (arithmetic-shift m -1))
           (k (+ -1 k) (+ -1 k))
           (rvs 0 (bitwise-ior (arithmetic-shift rvs 1) (bitwise-and 1 m))))
        ((negative? k) (if (negative? n) (bitwise-not rvs) rvs))))
    
    (define (fxbit-field-reverse n start end)
      (define width (- end start))
      (let ((mask (bitwise-not (arithmetic-shift -1 width))))
        (define zn (bitwise-and mask (arithmetic-shift n (- start))))
        (bitwise-ior (arithmetic-shift (bit-reverse width zn) start)
                     (bitwise-and (bitwise-not (arithmetic-shift mask start)) n))))
  )
)
;;; SRFI 144
;;; Flonums
;;; 
;;; This SRFI describes numeric procedures applicable to flonums, a subset
;;; of the inexact real numbers provided by LispKit. Just like in most Schemes,
;;; the flonums and the inexact reals are the same in LispKit. The procedures
;;; of SRFI 144 are semantically equivalent to the corresponding generic
;;; procedures, but allow more efficient implementations.
;;; 
;;; Specification: John Cowan, Will Clinger
;;; 
;;; Original implementation:
;;; Copyright © 2016 William D Clinger. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of
;;; this software and associated documentation files (the "Software"), to deal in the
;;; Software without restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
;;; Software, and to permit persons to whom the Software is furnished to do so,
;;; subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all
;;; copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;;; FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
;;; COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
;;; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
;;; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;; 
;;; LispKit Port:
;;;   Copyright © 2022 Matthias Zenger. All rights reserved.

(define-library (srfi 144)

  (export ;; Mathematical Constants
          fl-e
          fl-1/e
          fl-e-2
          fl-e-pi/4
          fl-log2-e
          fl-log10-e
          fl-log-2
          fl-1/log-2
          fl-log-3
          fl-log-pi
          fl-log-10
          fl-1/log-10
          fl-pi
          fl-1/pi
          fl-2pi
          fl-pi/2
          fl-pi/4
          fl-2/sqrt-pi
          fl-pi-squared
          fl-degree
          fl-2/pi
          fl-sqrt-2
          fl-sqrt-3
          fl-sqrt-5
          fl-sqrt-10
          fl-1/sqrt-2
          fl-cbrt-2
          fl-cbrt-3
          fl-4thrt-2
          fl-phi
          fl-log-phi
          fl-1/log-phi
          fl-euler
          fl-e-euler
          fl-sin-1
          fl-cos-1
          fl-gamma-1/2
          fl-gamma-1/3
          fl-gamma-2/3
          ;; Implementation Constants
          fl-greatest
          fl-least
          fl-epsilon
          fl-fast-fl+*
          fl-integer-exponent-zero
          fl-integer-exponent-nan
          ;; Constructors
          flonum
          fladjacent
          flcopysign
          make-flonum
          ;; Accessors
          flinteger-fraction
          flexponent
          flinteger-exponent
          flnormalized-fraction-exponent
          flsign-bit
          ;; Predicates
          flonum?
          fl=?
          fl<?
          fl>?
          fl<=?
          fl>=?
          flunordered?
          flmax
          flmin
          flinteger?
          flzero?
          flpositive?
          flnegative?
          flodd?
          fleven?
          flfinite?
          flinfinite?
          flnan?
          flnormalized?
          fldenormalized?
          ;; Arithmetic
          fl+
          fl*
          fl+*
          fl-
          fl/
          flabs
          flabsdiff
          flposdiff
          flsgn
          flnumerator
          fldenominator
          flfloor
          flceiling
          flround
          fltruncate
          ;; Exponents and logarithsm
          flexp
          flexp2
          flexp-1
          flsquare
          flsqrt
          flcbrt
          flhypot
          flexpt
          fllog
          fllog1+
          fllog2
          fllog10
          make-fllog-base
          ;; Trigonometric functions
          flsin
          flcos
          fltan
          flasin
          flacos
          flatan
          flsinh
          flcosh
          fltanh
          flasinh
          flacosh
          flatanh
          ;; Integer division
          flquotient
          flremainder
          flremquo
          ;; Special functions
          flgamma
          flloggamma
          flfirst-bessel
          flsecond-bessel
          flerf
          flerfc)

  (import (rename (lispkit base)
            (infinite? flinfinite?)
            (fl> fl>?)
            (fl< fl<?)
            (fl>= fl>=?)
            (fl<= fl<=?)
            (fl= fl=?)
            (flexponent flinteger-exponent)
            (integer? flinteger?)
            (sqrt flsqrt)
            (floor flfloor)
            (log fllog)
            (truncate fltruncate)
            (nan? flnan?)
            (sin flsin)
            (exp flexp)
            (ceiling flceiling)
            (round flround)
            (even? fleven?)
            (asin flasin)
            (finite? flfinite?)
            (tan fltan)
            (expt flexpt)
            (cos flcos)
            (acos flacos)
            (odd? flodd?)
            (atan flatan)))
  
  ;; Flonum constants
  (begin
    (define fl-e          2.7182818284590452353602874713526624977572) ; e
    (define fl-1/e        0.3678794411714423215955237701614608674458) ; 1/e
    (define fl-e-2        7.3890560989306502272304274605750078131803) ; e^2
    (define fl-e-pi/4     2.1932800507380154565597696592787382234616) ; e^(pi/4)
    (define fl-log2-e     1.44269504088896340735992468100189214)      ; log_2(e)
    (define fl-log10-e    0.434294481903251827651128918916605082)     ; log_10(e)
    (define fl-log-2      0.6931471805599453094172321214581765680755) ; ln(2)
    (define fl-1/log-2    1.4426950408889634073599246810018921374266) ; 1/ln(2)
    (define fl-log-3      1.0986122886681096913952452369225257046475) ; ln(3)
    (define fl-log-pi     1.1447298858494001741434273513530587116473) ; ln(pi)
    (define fl-log-10     2.3025850929940456840179914546843642076011) ; ln(10)
    (define fl-1/log-10   0.4342944819032518276511289189166050822944) ; 1/ln(10)
    (define fl-pi         3.1415926535897932384626433832795028841972) ; pi
    (define fl-1/pi       0.3183098861837906715377675267450287240689) ; 1/pi
    (define fl-2pi        6.2831853071795862319959269370883703231812) ; pi * 2
    (define fl-pi/2       1.57079632679489661923132169163975144)      ; pi/2
    (define fl-2/pi       0.636619772367581343075535053490057448)     ; 2/pi
    (define fl-pi/4       0.785398163397448309615660845819875721)     ; pi/4
    (define fl-2/sqrt-pi  1.12837916709551257389615890312154517)      ; 2/sqrt(pi)
    (define fl-sqrt-pi    1.7724538509055160272981674833411451827975) ; sqrt(pi)
    (define fl-pi-squared 9.8696044010893586188344909998761511353137) ; pi^2
    (define fl-degree     0.0174532925199432957692369076848861271344) ; pi/180
    (define fl-gamma-1/2  1.7724538509055160272981674833411451827975) ; gamma(1/2)
    (define fl-gamma-1/3  2.6789385347077476336556929409746776441287) ; gamma(1/3)
    (define fl-gamma-2/3  1.3541179394264004169452880281545137855193) ; gamma(2/3)
    (define fl-sqrt-2     1.4142135623730950488016887242096980785697) ; sqrt(2)
    (define fl-sqrt-3     1.7320508075688772935274463415058723669428) ; sqrt(3)
    (define fl-sqrt-5     2.2360679774997896964091736687312762354406) ; sqrt(5)
    (define fl-sqrt-10    3.1622776601683793319988935444327185337196) ; sqrt(10)
    (define fl-cbrt-2     1.2599210498948731647672106072782283505703) ; cubert(2)
    (define fl-cbrt-3     1.4422495703074083823216383107801095883919) ; cubert(3)
    (define fl-4thrt-2    1.1892071150027210667174999705604759152930) ; fourthrt(2)
    (define fl-1/sqrt-2   0.7071067811865475244008443621048490392848) ; 1/sqrt(2)
    (define fl-phi        1.6180339887498948482045868343656381177203) ; phi
    (define fl-log-phi    0.4812118250596034474977589134243684231352) ; ln(phi)
    (define fl-1/log-phi  2.0780869212350275376013226061177957677422) ; 1/ln(phi)
    (define fl-euler      0.5772156649015328606065120900824024310422) ; euler
    (define fl-e-euler    1.7810724179901979852365041031071795491696) ; e^euler
    (define fl-sin-1      0.8414709848078965066525023216302989996226) ; sin(1)
    (define fl-cos-1      0.5403023058681397174009366074429766037323) ; cos(1)
  )
  
  ;; Preserve usage of original functions; for now, these are just synonyms
  (begin
    (define expt flexpt)
    (define finite? flfinite?)
    (define log fllog)
    (define even? fleven?)
    (define integer? flinteger?)
    (define round flround)
  )
  
  ;; Support procedures
  (begin
    (define precision-bits    ; IEEE double has 53 bits of precision
      (let loop ((bits 0)
                 (x 1.0))
        (if (= x (+ x 1.0))
            bits
            (loop (+ bits 1)
                  (* 2.0 x)))))
    
    (define (check-flonum! name x)
      (if (not (flonum? x))
          (error (string-append "non-flonum argument passed to "
                                (symbol->string name))
                 x)))
    
    ;;; Given a symbol naming a flonum procedure and a generic operation,
    ;;; returns a flonum procedure that restricts the generic operation
    ;;; to flonum arguments and result.
    (define (flop1 name op)
      (lambda (x)
        (check-flonum! name x)
        (let ((result (op x)))
          (if (not (flonum? result))
              (error (string-append "non-flonum result from "
                                    (symbol->string name))
                     result))
          result)))
    
    (define (flop2 name op)
      (lambda (x y)
        (check-flonum! name x)
        (check-flonum! name y)
        (let ((result (op x y)))
          (if (not (flonum? result))
              (error (string-append "non-flonum result from "
                                    (symbol->string name))
                     result))
          result)))
    
    (define (flop3 name op)
      (lambda (x y z)
        (check-flonum! name x)
        (check-flonum! name y)
        (check-flonum! name z)
        (let ((result (op x y z)))
          (if (not (flonum? result))
              (error (string-append "non-flonum result from "
                                    (symbol->string name))
                     result))
          result)))
        
    ;;; Given a flonum x and a list of flonum coefficients for a polynomial,
    ;;; in order of increasing degree, returns the value of the polynomial at x.
    (define (polynomial-at x coefs)
      (if (null? coefs)
          0.0
          (fl+ (car coefs)
               (fl* x (polynomial-at x (cdr coefs))))))
    
    ;;; This uses Simpson's rule.
    (define (definite-integral lower upper f . rest)
      (let* ((range (fl- upper lower))
             (kmax (if (or (null? rest)
                           (not (and (exact-integer? (car rest))
                                     (even? (car rest))
                                     (positive? (car rest)))))
                       1024 ; FIXME: must be even, should be power of 2
                       (car rest)))
             (n2 (inexact kmax))
             (h (fl/ range n2)))
        (define (loop k n sum)    ; n = (inexact k)
          (cond ((= k 0)
                 (loop 1 1.0 (f lower)))
                ((= k kmax)
                 (fl+ sum (f upper)))
                (else
                 (let ((fn (f (+ lower (fl/ (fl* n range) n2)))))
                   (loop (+ k 1)
                         (fl+ n 1.0)
                         (fl+ sum (fl* (if (even? k) 2.0 4.0) fn)))))))
        (fl/ (fl* h (loop 0 0.0 0.0))
             3.0)))
    
    ;;; Given x between x0 and x1, interpolates between f0 and f1.
    ;;; Can also extrapolate.
    (define (interpolate x x0 x1 f0 f1)
      (let ((delta (fl- x1 x0)))
        (fl+ (fl* (fl/ (fl- x1 x) delta) f0)
             (fl* (fl/ (fl- x x0) delta) f1))))
    
    ;;; Given a exact non-negative integer, returns its factorial.
    (define (fact x)
      (if (zero? x)
          1
          (* x (fact (- x 1)))))
    
    ;;; Given a non-negative integral flonum x, returns its factorial.
    (define (factorial x)
      (if (flzero? x)
          1.0
          (fl* x (factorial (fl- x 1.0)))))
    
  )
  
  ;;; References
  ;;;
  ;;; Milton Abramowitz and Irene A Stegun [editors].
  ;;; Handbook of Mathematical Functions With Formulas, Graphs, and
  ;;; Mathematical Tables.  United States Department of Commerce.
  ;;; National Bureau of Standards Applied Mathematics Series, 55,
  ;;; June 1964.  Fifth Printing, August 1966, with corrections.
  ;;;
  ;;; R W Hamming.  Numerical Methods for Scientists and Engineers.
  ;;; McGraw-Hill, 1962.
  ;;;
  ;;; Donald E Knuth.  The Art of Computer Programming, Volume 2,
  ;;; Seminumerical Algorithms, Second Edition.  Addison-Wesley, 1981.
  ;;;
  ;;; J N Newman.  Approximations for the Bessel and Struve Functions.
  ;;; Mathematics of Computation, 43(168), October 1984, pages 551-556.
  
  ;;; I have deliberately avoided recent references, and have also
  ;;; avoided looking at any code or pseudocode for these or similar
  ;;; functions.
  
  ;;; Quick-and-dirty implementation of a draft of SRFI 144 (flonums),
  ;;; as specified at http://vrici.lojban.org/~cowan/temp/srfi-144.html
  ;;; as of 4 June 2017.
  ;;;
  ;;; FIXME: not as accurate as it should be
  ;;; FIXME: not as fast as it should be
  ;;; FIXME: assumes IEEE arithmetic or similar
  ;;; FIXME: assumes all inexact reals are flonums
  ;;; FIXME: assumes (scheme inexact)
  (begin
  
    ;; Implementation Constants
    
    (define fl-fast-fl+* #f)
    
    (define fl-integer-exponent-zero                ; arbitrary
      (exact (- (log fl-least 2.0) 1.0)))
    
    (define fl-integer-exponent-nan                 ; arbitrary
      (- fl-integer-exponent-zero 1))
    
    ;;; Constructors
    
    ; Implements post-finalization note 1
    (define (flonum x)
      (if (real? x)
          (inexact x)
          +nan.0))
    
    (define fladjacent
      (flop2 'fladjacent
             (lambda (x y)
               (define (loop y)
                 (let* ((y3 (fl+ (fl* 0.999755859375 x) (fl* 0.000244140625 y))))
                   (cond ((fl<? x y3 y)
                          (loop y3))
                         ((fl<? y y3 x)
                          (loop y3))
                         (else
                          (loop2 y)))))
               (define (loop2 y)
                 (let* ((y2 (fl/ (fl+ x y) 2.0))
                        (y2 (if (flinfinite? y2)
                                (fl+ (fl* 0.5 x) (fl* 0.5 y))
                                y2)))
                   (cond ((fl=? x y2)
                          y)
                         ((fl=? y y2)
                          y)
                         (else
                          (loop2 y2)))))
               (cond ((flinfinite? x)
                      (cond ((fl<? x y) (fl- fl-greatest))
                            ((fl>? x y) fl-greatest)
                            (else x)))
                     ((fl=? x y)
                      x)
                     ((flzero? x)
                      (if (flpositive? y)
                          fl-least
                          (fl- fl-least)))
                     ((fl<? x y)
                      (loop (flmin y
                                   fl-greatest
                                   (flmax (* 2.0 x)
                                          (* 0.5 x)))))
                     ((fl>? x y)
                      (loop (flmax y
                                   (fl- fl-greatest)
                                   (flmin (* 2.0 x)
                                          (* 0.5 x)))))
                     (else    ; x or y is a NaN
                      x)))))
    
    (define flcopysign
      (flop2 'flcopysign
             (lambda (x y)
               (if (= (flsign-bit x) (flsign-bit y))
                   x
                   (fl- x)))))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;;; Accessors
    
    (define (flexponent x)
      (inexact (flinteger-exponent x)))
    
    (define (flinteger-fraction x)
      (check-flonum! 'flinteger-fraction x)
      (let* ((result1 (fltruncate x))
             (result2 (fl- x result1)))
        (values result1 result2)))
    
    (define (flnormalized-fraction-exponent x)
      (define (return result1 result2)
        (cond ((fl<? result1 0.5)
               (values (fl* 2.0 result1) (- result2 1)))
              ((fl>=? result1 1.0)
               (values (fl* 0.5 result1) (+ result2 1)))
              (else
               (values result1 result2))))
      (check-flonum! 'flnormalized-fraction-exponent x)
      (cond ((flnan? x)    ; unspecified for NaN
             (values x 0))
            ((fl<? x 0.0)
             (call-with-values
              (lambda () (flnormalized-fraction-exponent (fl- x)))
              (lambda (y n)
                (values (fl- y) n))))
            ((fl=? x 0.0)    ; unspecified for 0.0
             (values 0.0 0))
            ((flinfinite? x)
             (values 0.5 (+ 3 (exact (round (fllog2 fl-greatest))))))
            ((flnormalized? x)
             (let* ((result2 (exact (flround (fllog2 x))))
                    (result2 (if (integer? result2)
                                 result2
                                 (round result2)))
                    (two^result2 (inexact (expt 2.0 result2))))
               (if (flinfinite? two^result2)
                   (call-with-values
                    (lambda () (flnormalized-fraction-exponent (fl/ x 4.0)))
                    (lambda (y n)
                      (values y (+ n 2))))
                   (return (fl/ x two^result2) result2))))
            (else
             (let* ((k (+ 2 precision-bits))
                    (two^k (expt 2 k)))
               (call-with-values
                (lambda ()
                  (flnormalized-fraction-exponent (fl* x (inexact two^k))))
                (lambda (y n)
                  (return y (- n k))))))))
    
    (define (flsign-bit x)
      (check-flonum! 'flsign-bit x)
      (cond ((fl<? x 0.0)
             1)
            ((eqv? x -0.0)
             1)
            (else
             0)))
    
    
    ;;; Predicates
    
    (define (flunordered? x y)
      (or (flnan? x) (flnan? y)))
    
    (define (flnormalized? x)
      (check-flonum! 'flnormalized? x)
      (let ((x (flabs x)))
        (and (flfinite? x)
             (fl<? (fl/ fl-greatest) x))))
    
    (define (fldenormalized? x)
      (check-flonum! 'fldenormalized? x)
      (let ((x (flabs x)))
        (and (flfinite? x)
             (fl<? 0.0 x)
             (fl<=? x (fl/ fl-greatest)))))
    
    ;;; Arithmetic
    
    ;;; Spec says "as if to infinite precision and rounded only once".
    
    (define fl+*
      (flop3 'fl+*
             (lambda (x y z)
               (cond ((and (flfinite? x) (flfinite? y))
                      (if (flfinite? z)
                          (let ((x (exact x))
                                (y (exact y))
                                (z (exact z)))
                            (flonum (+ (* x y) z)))
                          z))
                     (else
                      (fl+ (fl* x y) z))))))
    
    (define (flabsdiff x y)
      (flabs (fl- x y)))
    
    (define (flposdiff x y)
      (let ((diff (fl- x y)))
        (if (flnegative? diff)
            0.0
            diff)))
    
    (define (flsgn x)
      (flcopysign 1.0 x))
    
    (define flnumerator
      (flop1 'flnumerator
             (lambda (x)
               (cond ((flnan? x) x)
                     ((flinfinite? x) x)
                     (else (inexact (numerator (exact x))))))))
    
    (define fldenominator
      (flop1 'fldenominator
             (lambda (x)
               (cond ((flnan? x) x)
                     ((flinfinite? x) 1.0)
                     ((flzero? x) 1.0)
                     (else (inexact (denominator (exact x))))))))
    
    ;;; Exponents and logarithms
    
    (define flexp2 (flop1 'flexp2 (lambda (x) (flexpt 2.0 x))))
    
    ;;; e^x = \sum_n (z^n / (n!))
    ;;;
    ;;; FIXME: the number of terms and the constant 0.5 seem reasonable
    ;;; for IEEE double precision, but the number of terms might need
    ;;; to be increased for higher precisions.
    
    (define flexp-1
      (flop1 'flexp-1
             (let ((coefs (cons 0.0
                                (map fl/
                                     (map factorial
                                          '(1.0 2.0 3.0 4.0 5.0
                                            6.0 7.0 8.0 9.0 10.0
                                            11.0 12.0 13.0 14.0 15.0))))))
               (lambda (x)
                 (cond ((fl<? (flabs x) 0.5)    ; FIXME
                        (polynomial-at x coefs))
                       (else
                        (fl- (flexp x) 1.0)))))))
    
    (define flsquare (flop1 'flsquare (lambda (x) (fl* x x))))
    
    (define flcbrt
      (flop1 'flcbrt
             (lambda (x)
               (cond ((flnegative? x)
                      (fl- (flcbrt (fl- x))))
                     (else
                      (flexpt x (fl/ 3.0)))))))
    
    (define flhypot
      (flop2 'flhypot
             (lambda (x y)
               (cond ((flzero? x) (flabs y))
                     ((flzero? y) (flabs x))
                     ((or (flinfinite? x) (flinfinite? y)) +inf.0)
                     ((flnan? x) x)
                     ((flnan? y) y)
                     ((fl>? y x) (flhypot y x))
                     (else
                      (let* ((y/x (fl/ y x))
                             (root (flsqrt (fl+ 1.0 (fl* y/x y/x)))))
                        (fl* (flabs x) root)))))))
    
    ;;; Returns log(x+1), as in C99 log1p.
    
    ;;; See https://stat.ethz.ch/pipermail/r-devel/2003-August/027396.html
    ;;; https://books.google.com/books?id=OjUyDwAAQBAJ&pg=PA290&lpg=PA290&dq=beebe+log1p&source=bl&ots=VLxmiSk1fA&sig=ACfU3U0_8tqKemomSjKW73iJ0zUO1u3p3Q&hl=en&sa=X&ved=2ahUKEwjfxZbE8LvhAhVNm-AKHWScB7w4ChDoATAAegQICRAB#v=onepage&q=beebe%20log1p&f=false
    
    ;;; for justification
    
    (define fllog1+
      (flop1 'fllog1+
             (lambda (x)
               (let ((u (fl+ 1.0 x)))
                 (cond ((fl=? u 1.0)
                        x) ;; gets sign of zero result correct
                       ((fl=? u x)
                        (fllog u)) ;; large arguments and infinities
                       (else
                        (fl* (fllog u) (fl/ x (fl- u 1.0)))))))))
    
    
    (define fllog2 (flop1 'fllog2 (lambda (x) (log x 2.0))))
    
    (define fllog10 (flop1 'fllog10 (lambda (x) (log x 10.0))))
    
    (define (make-fllog-base base)
      (check-flonum! 'make-fllog-base base)
      (if (fl>? base 1.0)
          (flop1 'procedure-created-by-make-fllog-base
                 (lambda (x) (log x base)))
          (error "argument to make-fllog-base must be greater than 1.0" base)))
    
    ;;; Trigonometric functions
    
    (define flsinh
      (flop1 'flsinh
             (lambda (x)
               (cond ((not (flfinite? x)) x)
                     ((fl<? (flabs x) 0.75)
                      (fl/ (fl- (flexp-1 x) (flexp-1 (fl- x))) 2.0))
                     (else
                      (fl/ (fl- (flexp x) (flexp (fl- x))) 2.0))))))
    
    (define flcosh
      (flop1 'flcosh
             (lambda (x)
               (cond ((not (flfinite? x)) (flabs x))
                     ((fl<? (flabs x) 0.75)
                      (fl+ 1.0 (fl/ (fl+ (flexp-1 x) (flexp-1 (fl- x))) 2.0)))
                     (else
                      (fl/ (fl+ (flexp x) (flexp (fl- x))) 2.0))))))
    
    (define fltanh
      (flop1 'fltanh
             (lambda (x)
               (cond ((flinfinite? x) (flcopysign 1.0 x))
                     ((flnan? x) x)
                     (else
                      (let ((a (flsinh x))
                            (b (flcosh x)))
                        (cond ((fl=? a b)
                               1.0)
                              ((fl=? a (fl- b))
                               -1.0)
                              (else
                               (fl/ (flsinh x) (flcosh x))))))))))
    
    ;;; inverse hyperbolic functions
    
    (define flasinh
      (flop1 'flasinh
             (lambda (x)
               (cond ((or (flinfinite? x)
                          (flnan? x))
                      x)
                     ((flnegative? x)
                      (fl- (flasinh (fl- x))))
                     ((fl<? x 3.725290298461914e-9)   ;; (flexpt 2. -28.)
                      x)
                     ((fl<? x 2.)
                      ;; the naive formula is
                      ;; (log (+ x (sqrt (+ (square x) 1))))
    
                      ;; We want to
                      ;; 1.  Use exact operations when possible (no roundoff)
                      ;; 2.  Add or subtract things of differing magnitudes,
                      ;;     so for most arguments at most one roundoff error.
    
                      ;; Biggeset possible problem near x=0, so we write
                      ;; (sqrt (+ 1 (square x)))
                      ;; as
                      ;; (+ 1 (- (sqrt (+ 1 (square x))) 1))
                      ;; and then multiply the second part in
                      ;; numerator and denominator by
                      ;; (+ (sqrt (+ 1 (square x))) 1)
    
                      (let ((x^2 (flsquare x)))
                        (fllog1+ (fl+ x
                                      (fl/ x^2
                                           (fl+ 1.
                                                (flsqrt (fl+ 1.0 x^2))))))))
                     ((fl<? x 268435456.) ;; (flexpt 2. 28.)
                      (let ((x^2 (flsquare x)))
                        (fllog (fl+ (fl* 2. x) ;; exact
                                    ;; the rest is small
                                    (fl/ 1.
                                         (fl+ x
                                              (flsqrt (fl+ 1.0 x^2))))))))
                     (else
                      (fl+ (fllog x) fl-log-2))))))
    
    (define flacosh
      (flop1 'flacosh
             (lambda (x)
               (cond ((flnan? x) x)
                     ((fl<? x 1.0) +nan.0)
                     ((fl<? x 2.0)
                      ;; the naive formula is
                      ;; (log (+ x (sqrt (- (square x) 1))))
    
                      ;; We want to
                      ;; 1.  Use exact operations when possible (no roundoff)
                      ;; 2.  Add or subtract things of differing magnitudes,
                      ;;     so for most arguments at most one roundoff error.
    
                      (let ((x-1 (fl- x 1.))) ;; exact
                        (fllog1+ (fl+ x-1 ;; smaller than next expression
                                      (flsqrt (fl+ (fl* 2. x-1) ;; exact
                                                   ;; relatively small
                                                   (flsquare x-1)))))))
                     ((fl<? x 268435456.) ;; (flexpt 2. 28.)
                      (fllog (fl- (fl* 2. x) ;; exact
                                  ;; next is smaller
                                  (fl/ (fl+ x (flsqrt (fl* (fl- x 1.) ;; exact
                                                           (fl+ x 1.) ;; exact
                                                           )))))))
                     (else
                      (fl+ (fllog x) fl-log-2))))))
    
    (define flatanh
      (flop1 'flatanh
             (lambda (x)
               (cond ((fl<? x 0.)
                      (fl- (flatanh (fl- x))))
                     ;; we rewrite
                     ;; (/ (+ 1 x) (- 1 x))
                     ;; as
                     ;; (+ 1 (* 2 (/ x (- 1 x))))
                     ;; and call fllog1+ instead of fllog
                     (else
                      (fl* +0.5                                    ;; exact
                           (fllog1+ (fl* +2.0                      ;; exact
                                         (fl/ x
                                              (fl- 1.0 x)))))))))) ;; exact
    
    ;;; Integer division
    
    (define flquotient
      (flop2 'flquotient
             (lambda (x y)
               (fltruncate (fl/ x y)))))
    
    ;;; FIXME: should probably implement the following part of the C spec:
    ;;; "If the returned value is 0, it will have the same sign as x."
    
    (define flremainder
      (flop2 'flremainder
             (lambda (x y)
               (fl- x (fl* y (flquotient x y))))))
    
    (define (flremquo x y)
      (check-flonum! 'flremquo x)
      (check-flonum! 'flremquo y)
      (let* ((quo (flround (fl/ x y)))
             (rem (fl- x (fl* y quo))))
        (values rem
                (exact quo))))
  )
  
  ;;; References
  ;;;
  ;;; Milton Abramowitz and Irene A Stegun [editors].
  ;;; Handbook of Mathematical Functions With Formulas, Graphs, and
  ;;; Mathematical Tables.  United States Department of Commerce.
  ;;; National Bureau of Standards Applied Mathematics Series, 55,
  ;;; June 1964.  Fifth Printing, August 1966, with corrections.
  ;;;
  ;;; R W Hamming.  Numerical Methods for Scientists and Engineers.
  ;;; McGraw-Hill, 1962.
  ;;;
  ;;; Donald E Knuth.  The Art of Computer Programming, Volume 2,
  ;;; Seminumerical Algorithms, Second Edition.  Addison-Wesley, 1981.
  ;;;
  ;;; J N Newman.  Approximations for the Bessel and Struve Functions.
  ;;; Mathematics of Computation, 43(168), October 1984, pages 551-556.
  
  ;;; I have deliberately avoided recent references, and have also
  ;;; avoided looking at any code or pseudocode for these or similar
  ;;; functions.
  (begin
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; Gamma function
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;;; Abramowitz and Stegun 6.1.5 ::  z! = Gamma(z+1)
    ;;; Abramowitz and Stegun 6.1.15 :  Gamma(z+1) = z Gamma(z)
    ;;;
    ;;; Gamma(x+2) = (x+1) Gamma(x+1) = (x+1) x Gamma(x)
    ;;; Gamma(x) = Gamma(x+2) / (x (x + 1))
    ;;;
    ;;; Those equations reduce the computation of Gamma(x) to the range
    ;;;     1.0 <= x <= 2.0
    ;;;
    ;;; The following definition is more accurate than C99 tgamma
    ;;; with gcc, Linux, and double precision.  The alarmingly large
    ;;; absolute errors near 16.0 and -2.0e-16 are small relative
    ;;; errors.  At x=16.0, tgamma returns a non-integer result,
    ;;; but flgamma returns the correct integer result.
    
    (define (flgamma x)
      (check-flonum! 'flgamma x)
      (cond ((fl>=? x flgamma:upper-cutoff)
             +inf.0)
            ((fl<=? x flgamma:lower-cutoff)
             (cond ((= x -inf.0)
                    +nan.0)
                   ((flinteger? x)    ; pole error
                    +nan.0)
                   ((flodd? (fltruncate x)) 0.0)
                   (else -0.0)))
            (else (Gamma x))))
    
    (define (Gamma x)
      (cond ((fl>? x 2.0)
             (let ((x (fl- x 2.0)))
               (fl* x (fl+ x 1.0) (Gamma x))))
            ((fl=? x 2.0)
             1.0)
            ((fl>? x 1.0)
             (let ((x (fl- x 1.0)))
               (fl* x (Gamma x))))
            ((fl=? x 1.0)
             1.0)
            ((fl=? x 0.0)
             +inf.0)
            ((fl<? x 0.0)
             (if (flinteger? x)    ; pole error
                 +nan.0
                 (fl/ (Gamma (fl+ x 2.0)) x (fl+ x 1.0))))
            (else
             (fl/ (polynomial-at x gamma-coefs)))))
    
    ;;; Series expansion for 1/Gamma(x), from Abramowitz and Stegun 6.1.34
    
    (define gamma-coefs
      '(0.0
        1.0
        +0.5772156649015329
        -0.6558780715202538
        -0.0420026350340952
        +0.1665386113822915 ; x^5
        -0.0421977345555443
        -0.0096219715278770
        +0.0072189432466630
        -0.0011651675918591
        -0.0002152416741149 ; x^10
        +0.0001280502823882
        -0.0000201348547807
        -0.0000012504934821
        +0.0000011330272320
        -0.0000002056338417 ; x^15
        +0.0000000061160950
        +0.0000000050020075
        -0.0000000011812746
        +0.0000000001043427
        +0.0000000000077823 ; x^20
        -0.0000000000036968
        +0.0000000000005100
        -0.0000000000000206
        -0.0000000000000054
        +0.0000000000000014 ; x^25
        +0.0000000000000001
        ))
    
    ;;; If x >= flgamma:upper-cutoff, then (Gamma x) is +inf.0
    
    (define flgamma:upper-cutoff
      (do ((x 2.0 (+ x 1.0)))
          ((flinfinite? (Gamma x))
           x)))
    
    ;;; If x <= flgamma:lower-cutoff, then (Gamma x) is a zero or NaN
    
    (define flgamma:lower-cutoff
      (do ((x -2.0 (- x 1.0)))
          ((flzero?
            (Gamma (fladjacent x 0.0)))
           x)))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; log (Gamma (x))
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;;; Returns two values:
    ;;;     log ( |Gamma(x)| )
    ;;;     sgn (Gamma(x))
    ;;;
    ;;; The draft spec is unclear concerning sgn (Gamma(x)),
    ;;; but (flsgn x) returns (flcopysign 1.0 x) so I'm assuming
    ;;; sgn (Gamma(x)) is +1.0 for positive and -1.0 for negative.
    ;;; For real x, Gamma(x) is never actually zero, but it is
    ;;; undefined if x is zero or a negative integer.
    
    ;;; For small absolute values, this is trivial.
    ;;; Abramowitz and Stegun give several asymptotic formulas
    ;;; that might be good enough for large values of x.
    ;;;
    ;;; 6.1.41 :  As x goes to positive infinity, log (Gamma (x)) goes to
    ;;;
    ;;;     (x - 1/2) log x - x + 1/2 log (2 pi)
    ;;;         + 1/(12x) - 1/(360x^3) + 1/(1260x^5) - 1/(1680x^7) + ...
    ;;;
    ;;; 6.1.48 states a continued fraction.
    
    (define (flloggamma x)
      (check-flonum! 'flloggamma x)
      (cond ((flinfinite? x)
             (if (flpositive? x)
                 (values x 1.0)
                 (values +inf.0 +nan.0)))
            ((fl>=? x flloggamma:upper-threshold)
             (values (eqn6.1.48 x) 1.0))
            ((fl>? x 0.0)
             (let ((g (flgamma x)))
               (values (log g) 1.0)))
            (else
             (let ((g (flgamma x)))
               (values (log (flabs g))
                       (flcopysign 1.0 g))))))
    
    ;;; This doesn't seem to be as accurate as the continued fraction
    ;;; of equation 6.1.48, so it's commented out for now.
    
    #;
    (define (eqn6.1.41 x)
      (let* ((x^2 (fl* x x))
             (x^3 (fl* x x^2))
             (x^5 (fl* x^2 x^3))
             (x^7 (fl* x^2 x^5)))
        (fl+ (fl* (fl- x 0.5) (fllog x))
             (fl- x)
             (fl* 0.5 (fllog fl-2pi))
             (fl/ (fl* 12.0 x))
             (fl/ (fl* 360.0 x^3))
             (fl/ (fl* 1260.0 x^5))
             (fl/ (fl* 1680.0 x^7)))))
    
    (define (eqn6.1.48 x)
      (let ((+ fl+)
            (/ fl/))
        (+ (fl* (fl- x 0.5) (fllog x))
           (fl- x)
           (fl* 0.5 (fllog fl-2pi))
           (/ #i1/12
              (+ x
                 (/ #i1/30
                    (+ x
                       (/ #i53/210
                          (+ x
                             (/ #i195/371
                                (+ x
                                   (/ #i22999/22737
                                      (+ x
                                         (/ #i29944523/19733142
                                            (+ x
                                               (/ #i109535241009/48264275462
                                                  (+ x)))))))))))))))))
    
    ;;; With IEEE double precision, eqn6.1.48 is at least as accurate as
    ;;; (log (flgamma x)) starting around x = 20.0
    
    (define flloggamma:upper-threshold 20.0)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; Bessel functions
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;;; FIXME: This isn't as accurate as it should be, it's hard to test
    ;;; because it combines so many different algorithms and intervals,
    ;;; and it underflows to zero too soon.
    ;;;
    ;;; FIXME: To reduce discontinuities at the boundaries, results
    ;;; near boundaries should be computed as weighted averages of
    ;;; the results returned by algorithms used on the two sides of
    ;;; the boundary.
    ;;;
    ;;; FIXME: Several numerical constants, flagged by FIXME comments,
    ;;; seem to work for Larceny's double precision but might need to
    ;;; be changed for other precisions.  They are unlikely to be
    ;;; optimal even for double precision.
    
    (define (flfirst-bessel n x)
      (define (nan-protected y)
        (if (flfinite? y) y 0.0))
      (check-flonum! 'flfirst-bessel x)
      (cond ((< n 0)
             (let ((result (flfirst-bessel (- n) x)))
               (if (even? n) result (- result))))
    
            ((< x 0)
             (let ((result (flfirst-bessel n (- x))))
               (if (even? n) result (- result))))
    
            ((= x +inf.0)
             0.0)
    
            (else
             (case n
              ((0)    (cond ((fl<? x 4.5)     ; FIXME
                             (eqn9.1.10 n x))
                            ((fl<? x 93.0)    ; FIXME
                             (eqn9.1.18 n x))
                            (else
                             (eqn9.2.5 n x))))
              ((1)    (cond ((fl<? x 11.0)    ; FIXME
                             (eqn9.1.10-fast n x))
                            ((fl<? x 300.0)   ; FIXME
                             (eqn9.1.75 n x))
                            ((fl<? x 1e12)    ; FIXME
                             (eqn9.2.5 n x))
                            (else
                             (eqn9.2.1 n x))))
              ((2)    (cond ((fl<? x 10.0)    ; FIXME
                             (eqn9.1.10-fast n x))
                            ((fl<? x 1e19)    ; FIXME
                             (eqn9.1.27-first-bessel n x))
                            (else
                             ;; FIXME
                             0.0)))
              ((3)    (cond ((fl<? x 10.0)    ; FIXME
                             (eqn9.1.10-fast n x))
                            ((fl<? x 1e6)     ; FIXME
                             (eqn9.1.27-first-bessel n x))
                            (else
                             (nan-protected (eqn9.2.5 n x)))))
              (else   (cond ((fl<? x 12.0)    ; FIXME
                             (nan-protected (eqn9.1.10-fast n x)))
                            ((fl<? x 150.0)   ; FIXME
                             (nan-protected (if (fl>? (inexact n) x)
                                                (method9.12ex1 n x)
                                                (eqn9.1.75 n x))))
                            ((fl<? x 1e18)    ; FIXME
                             (nan-protected (eqn9.1.27-first-bessel n x)))
                            (else
                             ;; FIXME
                             0.0)))))))
    
    (define (flsecond-bessel n x)
      (check-flonum! 'flsecond-bessel x)
      (cond ((< n 0)
             (let ((result (flsecond-bessel (- n) x)))
               (if (even? n) result (- result))))
    
            ((fl<? x 0.0)
             +nan.0)
    
            ((fl=? x 0.0)
             -inf.0)
    
            ((fl=? x +inf.0)
             0.0)
    
            (else
             (case n
              ((0)    (cond ((fl<? x 14.5)        ; FIXME
                             (eqn9.1.13 0 x))
                            (else
                             (eqn9.2.6 0 x))))
              ((1)    (cond ((fl<? x 1e12)        ; FIXME
                             (eqn9.1.16 n x))
                            (else
                             (eqn9.2.6 n x))))
              ((2 3)  (cond (else
                             (eqn9.1.27-second-bessel n x))))
              (else   (let ((ynx (eqn9.1.27-second-bessel n x)))
                        (if (flnan? ynx)
                            -inf.0
                            ynx)))))))
    
    ;;; For multiples of 1/16:
    ;;;
    ;;; For n = 0, this agrees with C99 jn for 0 <= x <= 1.5
    ;;; and disagrees by no more than 1 bit for 0 <= x <= 2.0.
    ;;; For n = 1, this disagrees by no more than 1 bit for 0 <= x <= 2.5.
    ;;;
    ;;;     n    0 <= x <= xmax    bits
    ;;;
    ;;;     0    0 <= x <= 1.5      0
    ;;;     0    0 <= x <= 2.0      1
    ;;;     1    0 <= x <= 2.5      1
    ;;;     2    0 <= x <= 3.0      2
    ;;;     3    0 <= x <= 2.5      4
    ;;;     4    0 <= x <= 2.5      4
    ;;;     5    0 <= x <= 3.0      3
    ;;;     6    0 <= x <= 4.0      3
    ;;;     7    0 <= x <= 6.5      4
    ;;;     8    0 <= x <= 2.0      3
    ;;;     9    0 <= x <= 1.5      4
    ;;;    10    0 <= x <= 4.5      4
    ;;;    20    0 <= x <= 3.5      6
    ;;;    20    0 <= x <= 6.0      8
    ;;;    30    0 <= x <= 1.0      6
    ;;;    40    0 <= x <= 1.5      6
    ;;;    50    0 <= x <= 1.0      6
    
    
    ;;; It should become more accurate for larger n but less accurate for
    ;;; larger x.  Should be okay if n > x.
    
    (define (eqn9.1.10 n x)
      (fl* (inexact (expt (* 0.5 x) n))
           (polynomial-at (flsquare x)
                          (cond ((= n 0)
                                 eqn9.1.10-coefficients-0)
                                ((= n 1)
                                 eqn9.1.10-coefficients-1)
                                (else
                                 (eqn9.1.10-coefficients n))))))
    
    (define (eqn9.1.10-coefficients n)
      (define (loop k prev)
        (if (flzero? (inexact prev))
            '()
            (let ((c (/ (* -1/4 prev) k (+ n k))))
              (cons c (loop (+ k 1) c)))))
      (let ((c (/ (fact n))))
        (map inexact (cons c (loop 1 c)))))
    
    (define eqn9.1.10-coefficients-0
      (eqn9.1.10-coefficients 0))
    
    (define eqn9.1.10-coefficients-1
      (eqn9.1.10-coefficients 1))
    
    ;;; This is faster than using exact arithmetic to compute coefficients
    ;;; at call time, and it seems to be about as accurate.
    
    (define (eqn9.1.10-fast n x)
      (let* ((y (fl* 0.5 x))
             (y2 (fl- (fl* y y)))
             (bound (+ 25.0 (inexact n))))
        (define (loop k n+k)
          (if (fl>? n+k bound)
              1.0
              (fl+ 1.0
                   (fl* (fl/ y2 (fl* k n+k))
                        (loop (fl+ 1.0 k) (fl+ 1.0 n+k))))))
        (fl/ (fl* (inexact (expt y n))
                  (loop 1.0 (fl+ 1.0 (inexact n))))
             (factorial (inexact n)))))
    
    ;;; Equation 9.1.11 :
    ;;;
    ;;;     Y_n(x) = - (1 / (pi (x/2)^n))
    ;;;                  \sum_{k=0}^{n-1} ((n - k - 1)!/(k!)) (x^2/4)^k
    ;;;              + (2/pi) log (x/2) J_n(x)
    ;;;              - ((x/2)^n / pi)
    ;;;                  \sum_{k=0}^\infty ((psi(k+1) + psi(n+k+1)) / (k! (n+k)!))
    ;;;                                    (x^/4)^k
    ;;; where
    ;;;
    ;;;     psi (1) = - gamma
    ;;;     psi (n) = - gamma + \sum_{k=1}^{n-1} (1/k)
    
    ;;; Equation 9.1.13 is the special case for Y_0(x) :
    ;;;
    ;;;     Y_0(x) = (2/pi) (log (x/2) + gamma) J_0(x)
    ;;;            + (2/pi) ((x^2/4)^1 / (1!)^2
    ;;;                          - (1 + 1/2) (x^2/4)^2 / (2!)^2
    ;;;                          + (1 + 1/2 + 1/3) (x^2/4)^3 / (3!)^2
    ;;;                          - ...)
    
    (define (eqn9.1.13 n x)
      (if (not (= n 0)) (error "eqn9.1.13 requires n=0"))
      (fl* 2.0
           fl-1/pi
           (fl+ (fl* (fl+ (fllog (fl/ x 2.0)) fl-euler)
                     (flfirst-bessel 0 x))
                (polynomial-at (fl* 0.25 x x)
                               eqn9.1.13-coefficients))))
    
    (define eqn9.1.13-coefficients
      (map (lambda (k)
             (cond ((= k 0) 0.0)
                   ((= k 1) 1.0)
                   (else
                    ;; (1 + 1/2 + 1/3 + ... + 1/k) / (k!)^2
                    (let ((c (/ (apply + (map / (cdr (iota (+ k 1)))))
                                (let ((k! (fact k)))
                                  (* k! k!)))))
                      (inexact (if (even? k) (- c) c))))))
           (iota 25))) ; FIXME
    
    ;;; Equation 9.1.16 :
    ;;;
    ;;;     J_{n+1}(x) Y_n(x) - J_n(x) Y_{n+1}(x) = 2 / (pi x)
    ;;; so
    ;;;     Y_{n+1}(x) = (J_{n+1}(x) Y_n(x) - (2 / (pi x))) / J_n(x)
    
    (define (eqn9.1.16 n+1 x)
      (if (= 0 n+1)
          (flsecond-bessel 0 x)
          (let ((n (- n+1 1)))
            (fl/ (fl- (fl* (flfirst-bessel n+1 x) (flsecond-bessel n x))
                      (fl/ 2.0 (fl* fl-pi x)))
                 (flfirst-bessel n x)))))
    
    ;;; Equation 9.1.18 :
    ;;;
    ;;;     J_0(x) = (1 / \pi) \int_0^\pi cos (x sin \theta) d\theta
    ;;;            = (1 / \pi) \int_0^\pi cos (x cos \theta) d\theta
    
    (define (eqn9.1.18 n x)
      (if (> n 0)
          (flfirst-bessel n x)
          (fl* fl-1/pi
               (definite-integral 0.0
                                  fl-pi
                                  (lambda (theta)
                                    (flcos (fl* x (flsin theta))))
                                  128))))
    
    ;;; Equation 9.1.27 says
    ;;;
    ;;; J_{n-1}(x) + J_{n+1}(x) = (2n/x) J_n(x)
    ;;;
    ;;; J_{n+1}(x) = (2n/x) J_n(x) - J_{n-1}(x)
    ;;;
    ;;; J_{n-1}(x) = (2n/x) J_n(x) - J_{n+1}(x)
    ;;;
    ;;; Y_{n-1}(x) + Y_{n+1}(x) = (2n/x) Y_n(x)
    ;;;
    ;;; Y_{n+1}(x) = (2n/x) Y_n(x) - Y_{n-1}(x)
    ;;;
    ;;; Y_{n-1}(x) = (2n/x) Y_n(x) - Y_{n+1}(x)
    ;;;
    ;;; This has too much roundoff error if n > x or if x and n have
    ;;; the same magnitude.
    
    (define (eqn9.1.27-first-bessel n x)
      (eqn9.1.27 flfirst-bessel n x))
    
    (define (eqn9.1.27-second-bessel n x)
      (eqn9.1.27 flsecond-bessel n x))
    
    (define (eqn9.1.27 f n0 x)
      (define (loop n jn jn-1)
        (cond ((= n n0)
               jn)
              (else
               (loop (+ n 1)
                     (fl- (fl* (fl/ (inexact (+ n n)) x) jn)
                          jn-1)
                     jn))))
      (if (<= n0 1)
          (f n0 x)
          (loop 1 (f 1 x) (f 0 x))))
    
    ;;; For x < n, Abramowitz and Stegun 9.12 Example 1 suggests this method:
    ;;;
    ;;;     1.  Choose odd N large enough so J_N(x) is essentially zero.
    ;;;     2.  Choose an arbitrary trial value, say 1.0, for J_{N-1}(x).
    ;;;     3.  Use equation 9.1.27 to estimate the relative values
    ;;;         of J_{N-2}(x), J_{N-3}(x), ...
    ;;;     4.  Normalize using equation 9.1.46 :
    ;;;
    ;;;             1 = J_0(x) + 2 J_2(x) + 2 J_4(x) + 2 J_6(x) + ...
    
    (define (method9.12ex1 n0 x)
      (define (loop n jn jn+1 jn0 sumEvens)
        (if (= n 0)
            (fl/ jn0 (+ jn sumEvens sumEvens))
            (let ((jn-1 (fl- (fl/ (fl* 2.0 (inexact n) jn) x) jn+1)))
              (loop (- n 1)
                    jn-1
                    jn
                    (if (= n n0) jn jn0)
                    (if (even? n) (fl+ jn sumEvens) sumEvens)))))
      (let* ((n (min 200 (+ n0 20))) ; FIXME
             (jn+1 (fl/ x (fl* 2.0 (inexact n))))
             (jn 1.0))
        (loop (- n 1) jn jn+1 0.0 0.0)))
    
    ;;; Equation 9.1.75 states an equality between J_n(x)/J_{n-1}(x)
    ;;; and a continued fraction.
    ;;;
    ;;; Precondition: |x| > 0
    ;;;
    ;;; This works very well provided (flfirst-bessel x 0) is accurate
    ;;; and x is small enough for it to run in reasonable time.
    
    (define (eqn9.1.75 n x)
      (define k (max 10 (* 2 (exact (flceiling x)))))
      (define (loop x2 m i)
        (if (> i k)
            (fl/ 1.0 (fl* m x2))
            (fl/ 1.0
                 (fl- (fl* m x2)
                      (loop x2 (+ m 1.0) (+ i 1))))))
      (if (and (> n 0)
               (flpositive? x)
               (fl<? x 1e3))
    ; (if (and (> n 3) (flpositive? x))
          (fl* (eqn9.1.75 (- n 1) x)
               (loop (fl/ 2.0 x) (inexact n) 0))
          (flfirst-bessel n x)))
    
    ;;; Equation 9.1.89 :
    ;;;
    ;;;     Y_0(x) = 2/pi (log (x/2) + gamma) J_0(x)
    ;;;                 - 4/pi \sum_{k=1}^\infty (-1)^k J_{2k}(x)/k
    ;;;
    ;;; To reduce roundoff error, the infinite sum is computed
    ;;; non-tail-recursively.
    ;;;
    ;;; FIXME: not used at present, so I've commented it out.
    
    #;
    (define (eqn9.1.89 n x)
      (define (sum k)
        (let* ((k2 (+ k k))
               (j2k (flfirst-bessel k2 x))
               (y (if (even? k) j2k (fl- j2k))))
          (if (flzero? y)
              y
              (fl+ y (sum (+ k 1))))))
      (if (not (= n 0)) (error "eqn9.1.89 requires n=0"))
      (fl- (fl* 2.0
                fl-1/pi
                (fl+ (fllog (fl/ x 2.0)) fl-euler)
                (flfirst-bessel 0 x))
           (fl* 4.0 fl-1/pi (sum 1))))
                
                
    
    ;;; Equation 9.2.1 states an asymptotic approximation that agrees
    ;;; with C99 jn to 6 decimal places for n = 0 and x = 1e6.
    
    (define (eqn9.2.1 n x)
      (fl* (flsqrt (/ 2.0 (fl* fl-pi x)))
           (flcos (fl- x (fl* fl-pi (fl+ (fl* 0.5 (inexact n)) 0.25))))))
    
    ;;; Equation 9.2.2 states an asymptotic approximation for Y_n.
    ;;;
    ;;; FIXME: not used at present, so I've commented it out.
    
    #;
    (define (eqn9.2.2 n x)
      (fl* (flsqrt (/ 2.0 (fl* fl-pi x)))
           (flsin (fl- x (fl* fl-pi (fl+ (fl* 0.5 (inexact n)) 0.25))))))
    
    ;;; Equation 9.2.5 : For large x,
    ;;;
    ;;;     J_n(x) = sqrt (2/(pi x)) [ P(n, x) cos theta - Q (n, x) sin theta ]
    ;;;
    ;;; where
    ;;;
    ;;;     theta = x - (n/2 + 1/4) pi
    ;;;
    ;;; and P(n, x) and Q(n, x) are defined by equations 9.2.9 and 9.2.10.
    
    (define (eqn9.2.5 n x)
      (let ((theta (fl- x (fl* (fl+ (/ n 2.0) 0.25) fl-pi))))
        (fl* (flsqrt (fl/ 2.0 (fl* fl-pi x)))
             (fl- (fl* (eqn9.2.9 n x) (flcos theta))
                  (fl* (eqn9.2.10 n x) (flsin theta))))))
    
    ;;; Equation 9.2.6 : For large x,
    ;;;
    ;;;     Y_n(x) = sqrt (2/(pi x)) [ P(n, x) sin theta + Q (n, x) cos theta ]
    ;;;
    ;;; where
    ;;;
    ;;;     theta = x - (n/2 + 1/4) pi
    ;;;
    ;;; and P(n, x) and Q(n, x) are defined by equations 9.2.9 and 9.2.10.
    
    (define (eqn9.2.6 n x)
      (let ((theta (fl- x (fl* (fl+ (/ n 2.0) 0.25) fl-pi))))
        (fl* (flsqrt (fl/ 2.0 (fl* fl-pi x)))
             (fl+ (fl* (eqn9.2.9 n x) (flsin theta))
                  (fl* (eqn9.2.10 n x) (flcos theta))))))
    
    (define (eqn9.2.9 n x) ; returns P(n, x)
      (define mu (fl* 4.0 (flsquare (inexact n))))
      (define (coefficients k2 p fact2k)
        (let ((c (fl/ p fact2k)))
          (if (fl>? k2 20.0) ; FIXME
              (list c)
              (cons c (coefficients (fl+ k2 2.0)
                                    (fl* p
                                         (fl- mu (flsquare (fl+ k2 1.0)))
                                         (fl- mu (flsquare (fl+ k2 3.0))))
                                    (fl* fact2k
                                         (fl+ k2 1.0)
                                         (fl+ k2 2.0)))))))
      (polynomial-at (fl- (fl/ (flsquare (fl* 8.0 x))))
                     (coefficients 0.0 1.0 1.0)))
    
    (define (eqn9.2.10 n x) ; returns Q(n, x)
      (define mu (fl* 4.0 (flsquare (inexact n))))
      (define (coefficients k2+1 p fact2k+1)
        (let ((c (fl/ p fact2k+1)))
          (if (fl>? k2+1 20.0) ; FIXME
              (list c)
              (cons c (coefficients (fl+ k2+1 2.0)
                                    (fl* p
                                         (fl- mu (flsquare (fl+ k2+1 2.0)))
                                         (fl- mu (flsquare (fl+ k2+1 4.0))))
                                    (fl* fact2k+1
                                         (fl+ k2+1 1.0)
                                         (fl+ k2+1 2.0)))))))
      (fl* (fl/ (fl* 8.0 x))
           (polynomial-at (fl- (fl/ (flsquare (fl* 8.0 x))))
                          (coefficients 1.0 (fl- mu 1.0) 1.0))))
    
    ;;; Equation 9.4.3 is a polynomial approximation attributed to
    ;;; E E Allen, Analytical approximations, Math. Tables Aids Comp. 8,
    ;;; 240-241 (1954), and Polynomial approximations to some modified
    ;;; Bessel functions, Math. Tables Aids Comp. 10, 162-164 (156)
    ;;; (with permission).
    ;;;
    ;;; This is commented out because Newman's similar polynomial
    ;;; approximation is simpler and has better error bounds.
    
    #;
    (define (eqn9.4.3 n x)
      (if (> n 0)
          (flfirst-bessel n x)
          (fl* (fl/ (flsqrt x))                              ; modulus
               (polynomial-at (fl/ 3.0 x)
                              '(+0.79788456
                                -0.00000077
                                -0.00552740
                                -0.00009512
                                +0.00137237
                                -0.00072805
                                +0.00014476))
               (flcos (fl+ x                                 ; phase
                           (polynomial-at (fl/ 3.0 x)
                                          '(-0.78539816
                                            -0.04166397
                                            -0.00003954
                                            +0.00262573
                                            -0.00054125
                                            -0.00029333
                                            +0.00013558)))))))
    
    ;;; J N Newman's polynomial approximation for x >= 3, from Table 4.
    
    #;
    (define (newman-table4 n x)
      (if (> n 0)
          (flfirst-bessel n x)
          (fl* (fl/ (flsqrt x))
               (polynomial-at (flsquare (fl/ 3.0 x))
                              '(+0.79788454
                                -0.00553897
                                +0.00099336
                                -0.00044346
                                +0.00020445
                                -0.00004959))
               (flcos (fl+ x
                           (fl- fl-pi/4)
                           (fl* (fl/ 3.0 x)
                                (polynomial-at (flsquare (fl/ 3.0 x))
                                               '(-0.04166592
                                                 +0.00239399
                                                 +0.00073984
                                                 -0.00031099
                                                 -0.00007605))))))))
    
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;; Error functions
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    (define (flerf x)
      (check-flonum! 'flerf x)
      (cond ((flnegative? x)
             (fl- (flerf (fl- x))))
            ((fl<? x 2.0)
             (eqn7.1.6 x))
            ((fl<? x +inf.0)
             (- 1.0 (eqn7.1.14 x)))
            ((fl=? x +inf.0)
             1.0)
            (else x)))
    
    (define (flerfc x)
      (check-flonum! 'flerfc x)
      (cond ((flnegative? x)
             (fl- 2.0 (flerfc (fl- x))))
            ((fl<? x 2.0)
             (eqn7.1.2 x))
            ((fl<? x +inf.0)
             (eqn7.1.14 x))
            ((fl=? x +inf.0)
             0.0)
            (else x)))
    
    ;;; Equation numbers are from Abramowitz and Stegun.
    
    ;;; If the step size is small enough for good accuracy,
    ;;; the integration is pretty slow.
    ;;;
    ;;; FIXME: not used at present, so I've commented it out.
    
    #;
    (define (eqn7.1.1 x)
      (fl* fl-2/sqrt-pi
           (definite-integral 0.0 x (lambda (t) (flexp (fl- (flsquare t)))))))
    
    (define (eqn7.1.2 x)
      (fl- 1.0 (flerf x)))
    
    ;;; Equation 7.1.6 :
    ;;;
    ;;;     erf x = (2 / sqrt(pi))
    ;;;             exp(-x^2)
    ;;;             \sum_{n=0}^\infty (2^n / (1 * 3 * ... * (2n+1))) x^(2n+1)
    ;;;
    ;;;           = (2 / sqrt(pi))
    ;;;             exp(-x^2)
    ;;;             x
    ;;;             \sum_{n=0}^\infty (2^n / (1 * 3 * ... * (2n+1))) (x^2)^n
    
    (define (eqn7.1.6 x)
      (let ((x^2 (flsquare x)))
        (fl* fl-2/sqrt-pi
             (flexp (fl- x^2))
             x
             (polynomial-at x^2 eqn7.1.6-coefficients))))
    
    (define eqn7.1.6-coefficients
      (let ()
        (define (loop n p)
          (if (> n 32) ; FIXME
              '()
              (let ((p (fl* p (inexact (+ (* 2 n) 1)))))
                (cons (fl/ (inexact (expt 2.0 n)) p)
                      (loop (+ n 1) p)))))
        (loop 0 1.0)))
    
    ;;; Equation 7.1.14 :
    ;;;
    ;;;     2 e^(x^2) \int_x^\infty e^(-t^2) dt
    ;;;   = 1 / (x + (1/2 / (x + (1 / (x + (3/2 / (x + (2 / (x + ...
    ;;;   = x (1/x) (1 / (x + (1/2 / (x + (1 / (x + (3/2 / (x + (2 / (x + ...
    ;;;   = x (1 / (x (x + (1/2 / (x + (1 / (x + (3/2 / (x + (2 / (x + ...
    ;;;   = x (1 / (x^2 + (1/2 / (1 + (1 / (x^2 + (3/2 / (1 + (2 / (x^2 + ...
    ;;;
    ;;;     erfc(x) = (2 / sqrt(pi)) \int_x^\infty e^(-t^2) dt
    ;;; so
    ;;;     erfc(x) = (1 / (sqrt(pi) e^(x^2)))
    ;;;                   times the continued fraction
    
    (define (eqn7.1.14 x)
      (define (continued-fraction x)
        (fl/ 1.0 (fl+ x (loop 1 0.5))))
      (define (loop k frac)
        (if (> k 70) ; FIXME
            1.0
            (fl/ frac (fl+ x (loop (+ k 1) (fl+ frac 0.5))))))
      (fl/ (continued-fraction x)
           (fl* (flsqrt fl-pi)
                (flexp (flsquare x)))))
  )
)
;;; SRFI 145
;;; Assumptions
;;;
;;; This SRFI specifies a means to denote the invalidity of certain code paths in a
;;; Scheme program. It allows Scheme code to turn the evaluation into a user-defined
;;; error that need not be signalled by the implementation. Optimizing compilers may
;;; use these denotations to produce better code and to issue better warnings about
;;; dead code.
;;;
;;; Author of spec: Marc Nieper-Wißkirchen
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 145)
  (export assume)
  (import (lispkit base))

  (begin
    (define-syntax assume
      (syntax-rules ()
        ((_ expression message ...)
          (unless expression (error "invalid assumption" (quote expression) message ...)))))
  )
)
;;; SRFI 146
;;; Mappings
;;;
;;; Mappings are finite sets of associations, where each association is a pair consisting
;;; of a key and an arbitrary Scheme value. The keys are elements of a suitable domain.
;;; Each mapping holds no more than one association with the same key. The fundamental
;;; mapping operation is retrieving the value of an association stored in the mapping
;;; when the key is given.
;;;
;;; Author of spec: Arthur A. Gleckler, Marc Nieper-Wißkirchen
;;;
;;; Copyright © 2016, 2017 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify,
;;; merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;; permit persons to whom the Software is furnished to do so, subject to the following
;;; conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies
;;; or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
;;; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
;;; OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2019 Matthias Zenger. All rights reserved.

(define-library (srfi 146)

  (export mapping
      	  mapping/ordered
      	  mapping?
      	  mapping-contains?
      	  mapping-empty?
      	  mapping-disjoint?
      	  mapping-ref
      	  mapping-ref/default
      	  mapping-key-comparator
      	  mapping-adjoin
      	  mapping-adjoin!
      	  mapping-set
      	  mapping-set!
      	  mapping-replace
      	  mapping-replace!
      	  mapping-delete
      	  mapping-delete!
      	  mapping-delete-all
      	  mapping-delete-all!
      	  mapping-intern
      	  mapping-intern!
      	  mapping-update
      	  mapping-update!
      	  mapping-update/default
      	  mapping-update!/default
      	  mapping-pop
      	  mapping-pop!
      	  mapping-search
      	  mapping-search!
      	  mapping-size
      	  mapping-find
      	  mapping-count
      	  mapping-any?
      	  mapping-every?
      	  mapping-keys
      	  mapping-values
      	  mapping-entries
      	  mapping-map
      	  mapping-map->list
      	  mapping-for-each
      	  mapping-fold
      	  mapping-unfold
      	  mapping-unfold/ordered
      	  mapping-filter
      	  mapping-filter!
      	  mapping-remove
      	  mapping-remove!
      	  mapping-partition
      	  mapping-partition!
      	  mapping-copy
      	  mapping->alist
      	  alist->mapping
      	  alist->mapping!
      	  alist->mapping/ordered
      	  alist->mapping/ordered!
      	  mapping=?
      	  mapping<?
      	  mapping>?
      	  mapping<=?
      	  mapping>=?
      	  mapping-union
      	  mapping-intersection
      	  mapping-difference
      	  mapping-xor
      	  mapping-union!
      	  mapping-intersection!
      	  mapping-difference!
      	  mapping-xor!
      	  mapping-min-key
      	  mapping-max-key
      	  mapping-min-value
      	  mapping-max-value
      	  mapping-key-predecessor
      	  mapping-key-successor
      	  mapping-range=
      	  mapping-range<
      	  mapping-range>
      	  mapping-range<=
      	  mapping-range>=
      	  mapping-range=!
      	  mapping-range<!
      	  mapping-range>!
      	  mapping-range<=!
      	  mapping-range>=!
      	  mapping-split
      	  mapping-catenate
      	  mapping-catenate!
      	  mapping-map/monotone
      	  mapping-map/monotone!
      	  mapping-fold/reverse
      	  comparator?
      	  mapping-comparator
      	  make-mapping-comparator)

  (import (lispkit base)
      	  (srfi 1)
      	  (srfi 8)
      	  (srfi 128)
      	  (srfi 145)
      	  (srfi 146 rbtree))

  (begin
    ;;; New types

    (define-record-type <mapping>
      (%make-mapping comparator tree)
      mapping?
      (comparator mapping-key-comparator)
      (tree mapping-tree))

    (define (make-empty-mapping comparator)
      (assume (comparator? comparator))
      (%make-mapping comparator (make-tree)))

    ;;; Exported procedures

    ;; Constructors

    (define (mapping comparator . args)
      (assume (comparator? comparator))
      (mapping-unfold null?
    	      (lambda (args)
    		(values (car args)
    			(cadr args)))
    	      cddr
    	      args
    	      comparator))

    (define (mapping-unfold stop? mapper successor seed comparator)
      (assume (procedure? stop?))
      (assume (procedure? mapper))
      (assume (procedure? successor))
      (assume (comparator? comparator))
      (let loop ((mapping (make-empty-mapping comparator))
    	     (seed seed))
        (if (stop? seed)
    	mapping
    	(receive (key value)
    	    (mapper seed)
    	  (loop (mapping-adjoin mapping key value)
    		(successor seed))))))

    (define mapping/ordered mapping)
    (define mapping-unfold/ordered mapping-unfold)

    ;; Predicates

    (define (mapping-empty? mapping)
      (assume (mapping? mapping))
      (not (mapping-any? (lambda (key value) #t) mapping)))

    (define (mapping-contains? mapping key)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-search mapping
    		 key
    		 (lambda (insert ignore)
    		   (return #f))
    		 (lambda (key value update remove)
    		   (return #t))))))

    (define (mapping-disjoint? mapping1 mapping2)
      (assume (mapping? mapping1))
      (assume (mapping? mapping2))
      (call/cc
       (lambda (return)
         (mapping-for-each (lambda (key value)
    		     (when (mapping-contains? mapping2 key)
    		       (return #f)))
    		   mapping1)
         #t)))

    ;; Accessors

    (define mapping-ref
      (case-lambda
        ((mapping key)
         (assume (mapping? mapping))
         (mapping-ref mapping key (lambda ()
    			(error "mapping-ref: key not in mapping" key))))
        ((mapping key failure)
         (assume (mapping? mapping))
         (assume (procedure? failure))
         (mapping-ref mapping key failure (lambda (value)
    				value)))
        ((mapping key failure success)
         (assume (mapping? mapping))
         (assume (procedure? failure))
         (assume (procedure? success))
         ((call/cc
           (lambda (return-thunk)
    	 (mapping-search mapping
    			 key
    			 (lambda (insert ignore)
    			   (return-thunk failure))
    			 (lambda (key value update remove)
    			   (return-thunk (lambda () (success value)))))))))))

    (define (mapping-ref/default mapping key default)
      (assume (mapping? mapping))
      (mapping-ref mapping key (lambda () default)))

    ;; Updaters

    (define (mapping-adjoin mapping . args)
      (assume (mapping? mapping))
      (let loop ((args args)
    	     (mapping mapping))
        (if (null? args)
    	mapping
    	(receive (mapping value)
    	    (mapping-intern mapping (car args) (lambda () (cadr args)))
    	  (loop (cddr args) mapping)))))

    (define mapping-adjoin! mapping-adjoin)

    (define (mapping-set mapping . args)
      (assume (mapping? mapping))
      (let loop ((args args)
    	     (mapping mapping))
        (if (null? args)
    	mapping
    	(receive (mapping)
    	    (mapping-update mapping (car args) (lambda (value) (cadr args)) (lambda () #f))
    	  (loop (cddr args)
    		mapping)))))

    (define mapping-set! mapping-set)

    (define (mapping-replace mapping key value)
      (assume (mapping? mapping))
      (receive (mapping obj)
          (mapping-search mapping
    		  key
    		  (lambda (insert ignore)
    		    (ignore #f))
    		  (lambda (old-key old-value update remove)
    		    (update key value #f)))
        mapping))

    (define mapping-replace! mapping-replace)

    (define (mapping-delete mapping . keys)
      (assume (mapping? mapping))
      (mapping-delete-all mapping keys))

    (define mapping-delete! mapping-delete)

    (define (mapping-delete-all mapping keys)
      (assume (mapping? mapping))
      (assume (list? keys))
      (fold (lambda (key mapping)
    	  (receive (mapping obj)
    	      (mapping-search mapping
    			  key
    			  (lambda (insert ignore)
    			    (ignore #f))
    			  (lambda (old-key old-value update remove)
    			    (remove #f)))
    	    mapping))
    	mapping keys))

    (define mapping-delete-all! mapping-delete-all)

    (define (mapping-intern mapping key failure)
      (assume (mapping? mapping))
      (assume (procedure? failure))
      (call/cc
       (lambda (return)
         (mapping-search mapping
    		 key
    		 (lambda (insert ignore)
    		   (receive (value)
    		       (failure)
    		     (insert value value)))
    		 (lambda (old-key old-value update remove)
    		   (return mapping old-value))))))

    (define mapping-intern! mapping-intern)

    (define mapping-update
      (case-lambda
       ((mapping key updater)
        (mapping-update mapping key updater (lambda ()
    				  (error "mapping-update: key not found in mapping" key))))
       ((mapping key updater failure)
        (mapping-update mapping key updater failure (lambda (value)
    					  value)))
       ((mapping key updater failure success)
        (assume (mapping? mapping))
        (assume (procedure? updater))
        (assume (procedure? failure))
        (assume (procedure? success))
        (receive (mapping obj)
    	(mapping-search mapping
    		    key
    		    (lambda (insert ignore)
    		      (insert (updater (failure)) #f))
    		    (lambda (old-key old-value update remove)
    		      (update key (updater (success old-value)) #f)))
          mapping))))

    (define mapping-update! mapping-update)

    (define (mapping-update/default mapping key updater default)
      (mapping-update mapping key updater (lambda () default)))

    (define mapping-update!/default mapping-update/default)

    (define mapping-pop
      (case-lambda
        ((mapping)
         (mapping-pop mapping (lambda ()
    			    (error "mapping-pop: mapping has no association"))))
        ((mapping failure)
         (assume (mapping? mapping))
         (assume (procedure? failure))
         ((call/cc
           (lambda (return-thunk)
    	 (receive (key value)
    	     (mapping-find (lambda (key value) #t) mapping (lambda () (return-thunk failure)))
    	   (lambda ()
    	     (values (mapping-delete mapping key) key value)))))))))

    (define mapping-pop! mapping-pop)

    (define (mapping-search mapping key failure success)
      (assume (mapping? mapping))
      (assume (procedure? failure))
      (assume (procedure? success))
      (call/cc
       (lambda (return)
         (let*-values
    	 (((comparator)
    	   (mapping-key-comparator mapping))
    	  ((tree obj)
    	   (tree-search comparator
    			(mapping-tree mapping)
    			key
    			(lambda (insert ignore)
    			  (failure (lambda (value obj)
    				     (insert key value obj))
    				   (lambda (obj)
    				     (return mapping obj))))
    			success)))
           (values (%make-mapping comparator tree)
    	       obj)))))

    (define mapping-search! mapping-search)

    ;; The whole mapping

    (define (mapping-size mapping)
      (assume (mapping? mapping))
      (mapping-count (lambda (key value)
    	       #t)
    	     mapping))

    (define (mapping-find predicate mapping failure)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (assume (procedure? failure))
      (call/cc
       (lambda (return)
         (mapping-for-each (lambda (key value)
    		     (when (predicate key value)
    		       (return key value)))
    		   mapping)
         (failure))))

    (define (mapping-count predicate mapping)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (mapping-fold (lambda (key value count)
    	      (if (predicate key value)
    		  (+ 1 count)
    		  count))
    	    0 mapping))

    (define (mapping-any? predicate mapping)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-for-each (lambda (key value)
    		     (when (predicate key value)
    		       (return #t)))
    		   mapping)
         #f)))

    (define (mapping-every? predicate mapping)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (not (mapping-any? (lambda (key value)
    		   (not (predicate key value)))
    		 mapping)))

    (define (mapping-keys mapping)
      (assume (mapping? mapping))
      (mapping-fold/reverse (lambda (key value keys)
    			  (cons key keys))
    			'() mapping))

    (define (mapping-values mapping)
      (assume (mapping? mapping))
      (mapping-fold/reverse (lambda (key value values)
    			  (cons value values))
    			'() mapping))

    (define (mapping-entries mapping)
      (assume (mapping? mapping))
      (values (mapping-keys mapping)
    	  (mapping-values mapping)))

    ;; Mapping and folding

    (define (mapping-map proc comparator mapping)
      (assume (procedure? proc))
      (assume (comparator? comparator))
      (assume (mapping? mapping))
      (mapping-fold (lambda (key value mapping)
    	      (receive (key value)
    		  (proc key value)
    		(mapping-set mapping key value)))
    	    (make-empty-mapping comparator)
    	    mapping))

    (define (mapping-for-each proc mapping)
      (assume (procedure? proc))
      (assume (mapping? mapping))
      (tree-for-each proc (mapping-tree mapping)))

    (define (mapping-fold proc acc mapping)
      (assume (procedure? proc))
      (assume (mapping? mapping))
      (tree-fold proc acc (mapping-tree mapping)))

    (define (mapping-map->list proc mapping)
      (assume (procedure? proc))
      (assume (mapping? mapping))
      (mapping-fold/reverse (lambda (key value lst)
    			  (cons (proc key value) lst))
    			'()
    			mapping))

    (define (mapping-filter predicate mapping)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (mapping-fold (lambda (key value mapping)
    	      (if (predicate key value)
    		  (mapping-set mapping key value)
    		  mapping))
    	    (make-empty-mapping (mapping-key-comparator mapping))
    	    mapping))

    (define mapping-filter! mapping-filter)

    (define (mapping-remove predicate mapping)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (mapping-filter (lambda (key value)
    		(not (predicate key value)))
    	      mapping))

    (define mapping-remove! mapping-remove)

    (define (mapping-partition predicate mapping)
      (assume (procedure? predicate))
      (assume (mapping? mapping))
      (values (mapping-filter predicate mapping)
    	  (mapping-remove predicate mapping)))

    (define mapping-partition! mapping-partition)

    ;; Copying and conversion

    (define (mapping-copy mapping)
      (assume (mapping? mapping))
      mapping)

    (define (mapping->alist mapping)
      (assume (mapping? mapping))
      (reverse
       (mapping-fold (lambda (key value alist)
    		   (cons (cons key value) alist))
    		 '() mapping)))

    (define (alist->mapping comparator alist)
      (assume (comparator? comparator))
      (assume (list? alist))
      (mapping-unfold null?
    	      (lambda (alist)
    		(let ((key (caar alist))
    		      (value (cdar alist)))
    		  (values key value)))
    	      cdr
    	      alist
    	      comparator))

    (define (alist->mapping! mapping alist)
      (assume (mapping? mapping))
      (assume (list? alist))
      (fold (lambda (association mapping)
    	  (let ((key (car association))
    		(value (cdr association)))
    	    (mapping-set mapping key value)))
    	mapping
    	alist))

    (define alist->mapping/ordered alist->mapping)
    (define alist->mapping/ordered! alist->mapping!)

    ;; Submappings

    (define mapping=?
      (case-lambda
        ((comparator mapping)
         (assume (mapping? mapping))
         #t)
        ((comparator mapping1 mapping2) (%mapping=? comparator mapping1 mapping2))
        ((comparator mapping1 mapping2 . mappings)
         (and (%mapping=? comparator mapping1 mapping2)
              (apply mapping=? comparator mapping2 mappings)))))
    (define (%mapping=? comparator mapping1 mapping2)
      (and (eq? (mapping-key-comparator mapping1) (mapping-key-comparator mapping2))
           (%mapping<=? comparator mapping1 mapping2)
           (%mapping<=? comparator mapping2 mapping1)))

    (define mapping<=?
      (case-lambda
        ((comparator mapping)
         (assume (mapping? mapping))
         #t)
        ((comparator mapping1 mapping2)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping<=? comparator mapping1 mapping2))
        ((comparator mapping1 mapping2 . mappings)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (and (%mapping<=? comparator mapping1 mapping2)
              (apply mapping<=? comparator mapping2 mappings)))))

    (define (%mapping<=? comparator mapping1 mapping2)
      (assume (comparator? comparator))
      (assume (mapping? mapping1))
      (assume (mapping? mapping2))
      (let ((less? (comparator-ordering-predicate (mapping-key-comparator mapping1)))
    	(equality-predicate (comparator-equality-predicate comparator))
    	(gen1 (tree-generator (mapping-tree mapping1)))
    	(gen2 (tree-generator (mapping-tree mapping2))))
        (let loop ((item1 (gen1))
    	       (item2 (gen2)))
          (cond
           ((eof-object? item1)
    	#t)
           ((eof-object? item2)
    	#f)
           (else
    	(let ((key1 (car item1)) (value1 (cadr item1))
    	      (key2 (car item2)) (value2 (cadr item2)))
    	  (cond
    	   ((less? key1 key2)
    	    #f)
    	   ((less? key2 key1)
    	    (loop item1 (gen2)))
    	   ((equality-predicate value1 value2)
    	    (loop (gen1) (gen2)))
    	   (else
    	    #f))))))))

    (define mapping>?
      (case-lambda
        ((comparator mapping)
         (assume (mapping? mapping))
         #t)
        ((comparator mapping1 mapping2)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping>? comparator mapping1 mapping2))
        ((comparator mapping1 mapping2 . mappings)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (and (%mapping>? comparator  mapping1 mapping2)
              (apply mapping>? comparator mapping2 mappings)))))

    (define (%mapping>? comparator mapping1 mapping2)
      (assume (comparator? comparator))
      (assume (mapping? mapping1))
      (assume (mapping? mapping2))
      (not (%mapping<=? comparator mapping1 mapping2)))

    (define mapping<?
      (case-lambda
        ((comparator mapping)
         (assume (mapping? mapping))
         #t)
        ((comparator mapping1 mapping2)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping<? comparator mapping1 mapping2))
        ((comparator mapping1 mapping2 . mappings)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (and (%mapping<? comparator  mapping1 mapping2)
              (apply mapping<? comparator mapping2 mappings)))))

    (define (%mapping<? comparator mapping1 mapping2)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping>? comparator mapping2 mapping1))

    (define mapping>=?
      (case-lambda
        ((comparator mapping)
         (assume (mapping? mapping))
         #t)
        ((comparator mapping1 mapping2)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping>=? comparator mapping1 mapping2))
        ((comparator mapping1 mapping2 . mappings)
         (assume (comparator? comparator))
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (and (%mapping>=? comparator mapping1 mapping2)
              (apply mapping>=? comparator mapping2 mappings)))))

    (define (%mapping>=? comparator mapping1 mapping2)
      (assume (comparator? comparator))
      (assume (mapping? mapping1))
      (assume (mapping? mapping2))
      (not (%mapping<? comparator mapping1 mapping2)))

    ;; Set theory operations

    (define (%mapping-union mapping1 mapping2)
      (mapping-fold (lambda (key2 value2 mapping)
    		  (receive (mapping obj)
    		      (mapping-search mapping
    				      key2
    				      (lambda (insert ignore)
    					(insert value2 #f))
    				      (lambda (key1 value1 update remove)
    					(update key1 value1 #f)))
    		    mapping))
    		mapping1 mapping2))

    (define (%mapping-intersection mapping1 mapping2)
      (mapping-filter (lambda (key1 value1)
    		(mapping-contains? mapping2 key1))
    	      mapping1))

    (define (%mapping-difference mapping1 mapping2)
      (mapping-fold (lambda (key2 value2 mapping)
    	      (receive (mapping obj)
    		  (mapping-search mapping
    			      key2
    			      (lambda (insert ignore)
    				(ignore #f))
    			      (lambda (key1 value1 update remove)
    				(remove #f)))
    		mapping))
    	    mapping1 mapping2))

    (define (%mapping-xor mapping1 mapping2)
      (mapping-fold (lambda (key2 value2 mapping)
    	      (receive (mapping obj)
    		  (mapping-search mapping
    			      key2
    			      (lambda (insert ignore)
    				(insert value2 #f))
    			      (lambda (key1 value1 update remove)
    				(remove #f)))
    		mapping))
    	    mapping1 mapping2))

    (define mapping-union
      (case-lambda
        ((mapping)
         (assume (mapping? mapping))
         mapping)
        ((mapping1 mapping2)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping-union mapping1 mapping2))
        ((mapping1 mapping2 . mappings)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (apply mapping-union (%mapping-union mapping1 mapping2) mappings))))
    (define mapping-union! mapping-union)

    (define mapping-intersection
      (case-lambda
        ((mapping)
         (assume (mapping? mapping))
         mapping)
        ((mapping1 mapping2)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping-intersection mapping1 mapping2))
        ((mapping1 mapping2 . mappings)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (apply mapping-intersection (%mapping-intersection mapping1 mapping2) mappings))))
    (define mapping-intersection! mapping-intersection)

    (define mapping-difference
      (case-lambda
        ((mapping)
         (assume (mapping? mapping))
         mapping)
        ((mapping1 mapping2)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping-difference mapping1 mapping2))
        ((mapping1 mapping2 . mappings)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (apply mapping-difference (%mapping-difference mapping1 mapping2) mappings))))
    (define mapping-difference! mapping-difference)

    (define mapping-xor
      (case-lambda
        ((mapping)
         (assume (mapping? mapping))
         mapping)
        ((mapping1 mapping2)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (%mapping-xor mapping1 mapping2))
        ((mapping1 mapping2 . mappings)
         (assume (mapping? mapping1))
         (assume (mapping? mapping2))
         (apply mapping-xor (%mapping-xor mapping1 mapping2) mappings))))
    (define mapping-xor! mapping-xor)

    ;; Additional procedures for mappings with ordererd keys

    (define (mapping-min-key mapping)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-fold (lambda (key value acc)
    		     (return key))
    		   #f mapping)
         (error "mapping-min-key: empty map"))))

    (define (mapping-max-key mapping)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-fold/reverse (lambda (key value acc)
    			     (return key))
    			   #f mapping)
         (error "mapping-max-key: empty map"))))

    (define (mapping-min-value mapping)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-fold (lambda (key value acc)
    		     (return value))
    		   #f mapping)
         (error "mapping-min-value: empty map"))))

    (define (mapping-max-value mapping)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-fold/reverse (lambda (key value acc)
    			     (return value))
    			   #f mapping)
         (error "mapping-max-value: empty map"))))

    (define (mapping-min-entry mapping)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-fold (lambda (key value acc)
    		     (return key value))
    		   #f mapping)
         (error "mapping-min-key: empty map"))))

    (define (mapping-max-entry mapping)
      (assume (mapping? mapping))
      (call/cc
       (lambda (return)
         (mapping-fold/reverse (lambda (key value acc)
    			     (return key value))
    			   #f mapping)
         (error "mapping-max-key: empty map"))))

    (define (mapping-key-predecessor mapping obj failure)
      (assume (mapping? mapping))
      (assume (procedure? failure))
      (tree-key-predecessor (mapping-key-comparator mapping) (mapping-tree mapping) obj failure))

    (define (mapping-key-successor mapping obj failure)
      (assume (mapping? mapping))
      (assume (procedure? failure))
      (tree-key-successor (mapping-key-comparator mapping) (mapping-tree mapping) obj failure))

    (define (mapping-range= mapping obj)
      (assume (mapping? mapping))
      (let ((comparator (mapping-key-comparator mapping)))
        (receive (tree< tree<= tree= tree>= tree>)
    	(tree-split comparator (mapping-tree mapping) obj)
          (%make-mapping comparator tree=))))

    (define (mapping-range< mapping obj)
      (assume (mapping? mapping))
      (let ((comparator (mapping-key-comparator mapping)))
        (receive (tree< tree<= tree= tree>= tree>)
    	(tree-split comparator (mapping-tree mapping) obj)
          (%make-mapping comparator tree<))))

    (define (mapping-range<= mapping obj)
      (assume (mapping? mapping))
      (let ((comparator (mapping-key-comparator mapping)))
        (receive (tree< tree<= tree= tree>= tree>)
    	(tree-split comparator (mapping-tree mapping) obj)
          (%make-mapping comparator tree<=))))

    (define (mapping-range> mapping obj)
      (assume (mapping? mapping))
      (let ((comparator (mapping-key-comparator mapping)))
        (receive (tree< tree<= tree= tree>= tree>)
    	(tree-split comparator (mapping-tree mapping) obj)
          (%make-mapping comparator tree>))))

    (define (mapping-range>= mapping obj)
      (assume (mapping? mapping))
      (assume (mapping? mapping))
      (let ((comparator (mapping-key-comparator mapping)))
        (receive (tree< tree<= tree= tree>= tree>)
    	(tree-split comparator (mapping-tree mapping) obj)
          (%make-mapping comparator tree>=))))

    (define mapping-range=! mapping-range=)
    (define mapping-range<! mapping-range<)
    (define mapping-range>! mapping-range>)
    (define mapping-range<=! mapping-range<=)
    (define mapping-range>=! mapping-range>=)

    (define (mapping-split mapping obj)
      (assume (mapping? mapping))
      (let ((comparator (mapping-key-comparator mapping)))
        (receive (tree< tree<= tree= tree>= tree>)
    	(tree-split comparator (mapping-tree mapping) obj)
          (values (%make-mapping comparator tree<)
    	      (%make-mapping comparator tree<=)
    	      (%make-mapping comparator tree=)
    	      (%make-mapping comparator tree>=)
    	      (%make-mapping comparator tree>)))))

    (define mapping-split! mapping-split)

    (define (mapping-catenate comparator mapping1 pivot-key pivot-value mapping2)
      (assume (comparator? comparator))
      (assume (mapping? mapping1))
      (assume (mapping? mapping2))
      (%make-mapping comparator (tree-catenate (mapping-tree mapping1)
    					   pivot-key
    					   pivot-value
    					   (mapping-tree mapping2))))

    (define mapping-catenate! mapping-catenate)

    (define (mapping-map/monotone proc comparator mapping)
      (assume (procedure? proc))
      (assume (comparator? comparator))
      (assume (mapping? mapping))
      (%make-mapping comparator (tree-map proc (mapping-tree mapping))))

    (define mapping-map/monotone! mapping-map/monotone)

    (define (mapping-fold/reverse proc acc mapping)
      (assume (procedure? proc))
      (assume (mapping? mapping))
      (tree-fold/reverse proc acc (mapping-tree mapping)))

    ;; Comparators

    (define (mapping-equality comparator)
      (assume (comparator? comparator))
      (lambda (mapping1 mapping2)
        (mapping=? comparator mapping1 mapping2)))

    (define (mapping-ordering comparator)
      (assume (comparator? comparator))
      (let ((value-equality (comparator-equality-predicate comparator))
    	(value-ordering (comparator-ordering-predicate comparator)))
        (lambda (mapping1 mapping2)
          (let* ((key-comparator (mapping-key-comparator mapping1))
    	     (equality (comparator-equality-predicate key-comparator))
    	     (ordering (comparator-ordering-predicate key-comparator))
    	     (gen1 (tree-generator (mapping-tree mapping1)))
    	     (gen2 (tree-generator (mapping-tree mapping2))))
    	(let loop ()
    	  (let ((item1 (gen1)) (item2 (gen2)))
    	    (cond
    	     ((eof-object? item1)
    	      (not (eof-object? item2)))
    	     ((eof-object? item2)
    	      #f)
    	     (else
    	      (let ((key1 (car item1)) (value1 (cadr item1))
    		    (key2 (car item2)) (value2 (cadr item2)))
    		(cond
    		 ((equality key1 key2)
    		  (if (value-equality value1 value2)
    		      (loop)
    		      (value-ordering value1 value2)))
    		 (else
    		  (ordering key1 key2))))))))))))

    (define (make-mapping-comparator comparator)
      (make-comparator mapping? (mapping-equality comparator) (mapping-ordering comparator) #f))

    (define mapping-comparator (make-mapping-comparator (make-default-comparator)))

    (comparator-register-default! mapping-comparator)
  )
)
;;; SRFI 149
;;; Basic syntax-rules template extensions
;;;
;;; The rules for valid `<template>`s of `<syntax rules>` are slightly softened
;;; to allow for more than one consecutive `<ellipsis>` in subtemplates, and to
;;; allow pattern variables in subtemplates to be followed by more instances of
;;; the identifier `<ellipsis>` than they are followed in the subpattern in which
;;; they occur.
;;;
;;; Author of spec: Marc Nieper-Wißkirchen
;;;
;;; Copyright © 2022 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use
;;; this file except in compliance with the License. You may obtain a copy of the
;;; License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed
;;; under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
;;; CONDITIONS OF ANY KIND, either express or implied. See the License for the
;;; specific language governing permissions and limitations under the License.

(define-library (srfi 149)

  (export syntax-rules)

  (import (lispkit core))

  ;; `syntax-rules` is implemented natively already in LispKit with the extensions of
  ;; SRFI 149.
)
;;; SRFI 151
;;; Bitwise Operations
;;;
;;; This SRFI proposes a coherent and comprehensive set of procedures for performing bitwise
;;; logical operations on integers; it is accompanied by a reference implementation of the
;;; spec in terms of a set of seven core operators. The sample implementation is portable,
;;; as efficient as practical with pure Scheme arithmetic (it is much more efficient to
;;; replace the core operators with C or assembly language if possible), and open source.
;;;
;;; The precise semantics of these operators is almost never an issue. A consistent, portable
;;; set of names and parameter conventions, however, is. Hence this SRFI, which is based
;;; mainly on SRFI 33, with some changes and additions from Olin's late revisions to SRFI 33
;;; (which were never consummated). SRFI 60 (based on SLIB) is smaller but has a few procedures
;;; of its own; some of its procedures have both native (often Common Lisp) and SRFI 33 names.
;;; They have been incorporated into this SRFI. R6RS is a subset of SRFI 60, except that all
;;; procedure names begin with a bitwise- prefix. A few procedures have been added from the
;;; general vector SRFI 133.
;;;
;;; This SRFI differs from SRFI 142 in only three ways:
;;;    1. The bitwise-if function has the argument ordering of SLIB, SRFI 60, and R6RS rather
;;;       than the ordering of SRFI 33.
;;;    2. The order in which bits are processed by the procedures listed in the "Bits conversion"
;;;       section has been clarified and some of the procedures' names have been changed.
;;;    3. The LispKit port for SRFI 151 is using native bitwise operations for fixnums and
;;;       bignums. Its performance is significantly better than the one of SRFI 142.
;;; 
;;; Specification:
;;;   Copyright © 2016 John Cowan. All rights reserved.
;;;
;;;   Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;;   software and associated documentation files (the "Software"), to deal in the Software
;;;   without restriction, including without limitation the rights to use, copy, modify,
;;;   merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;;   permit persons to whom the Software is furnished to do so, subject to the following
;;;   conditions:
;;;
;;;   The above copyright notice and this permission notice shall be included in all copies
;;;   or substantial portions of the Software.
;;;
;;; Implementation:
;;;   Olin Shivers (SRFI 33)
;;;   Aubrey Jaffer (SRFI 60)
;;;   John Cowan (SRFI 151)
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 151)

  (export bitwise-not
          bitwise-and
          bitwise-ior
          bitwise-xor
          bitwise-eqv
          bitwise-nand
          bitwise-nor
          bitwise-andc1
          bitwise-andc2
          bitwise-orc1
          bitwise-orc2)

  (export arithmetic-shift
          bit-count
          integer-length
          bitwise-if
          bit-set?
          copy-bit
          bit-swap
          any-bit-set?
          every-bit-set?
          first-set-bit)

  (export bit-field
          bit-field-any?
          bit-field-every?
          bit-field-clear
          bit-field-set
          bit-field-replace
          bit-field-replace-same
          bit-field-rotate
          bit-field-reverse)

  (export bits->list
          list->bits
          bits->vector
          vector->bits
          bits
          bitwise-fold
          bitwise-for-each
          bitwise-unfold
          make-bitwise-generator)

  (import (scheme base))

  (import (scheme case-lambda))

  (import (rename (only (lispkit base) bitwise-not
                                       bitwise-and
                                       bitwise-ior
                                       bitwise-xor
                                       bitwise-if
                                       bit-count
                                       integer-length
                                       first-bit-set
                                       bit-set?
                                       copy-bit
                                       arithmetic-shift
                                       arithmetic-shift-left
                                       arithmetic-shift-right)
                  (bit-set? native-bit-set?)
                  (copy-bit native-copy-bit)))

  (begin

    ;;; Olin Shivers's code from SRFI-33 with modified names
    ;;;
    ;;; Olin Shivers is the sole author of this code, and he has placed it in
    ;;; the public domain.
    ;;;
    ;;; A good implementation might choose to provide direct compiler/interpreter
    ;;; support for these derived functions, or might simply define them to be
    ;;; integrable -- i.e., inline-expanded.
    ;;;
    ;;; The seven non-trivial boolean functions in terms of not, and, or & xor.

    (define (bitwise-nand  i j)
      (bitwise-not (bitwise-and i j)))

    (define (bitwise-nor   i j)
      (bitwise-not (bitwise-ior i j)))

    (define (bitwise-andc1 i j)
      (bitwise-and (bitwise-not i) j))

    (define (bitwise-andc2 i j)
      (bitwise-and i (bitwise-not j)))

    (define (bitwise-orc1  i j)
      (bitwise-ior (bitwise-not i) j))

    (define (bitwise-orc2  i j)
      (bitwise-ior i (bitwise-not j)))

    ;;; This is a general definition, but less than efficient.  It should also
    ;;; receive primitive compiler/interpreter support so that the expensive
    ;;; n-ary mechanism is not invoked in the standard cases -- that is,
    ;;; an application of BITWISE-EQV should be rewritten into an equivalent
    ;;; tree applying some two-argument primitive to the arguments, in the
    ;;; same manner that statically-known n-ary applications of associative
    ;;; operations such as + and * are handled efficiently:
    ;;;   (bitwise-eqv)         => -1
    ;;;   (bitwise-eqv i)       => i
    ;;;   (bitwise-eqv i j)     => (%bitwise-eqv i j)
    ;;;   (bitwise-eqv i j k)   => (%bitwise-eqv (%bitwise-eqv i j) k)
    ;;;   (bitwise-eqv i j k l) => (%bitwise-eqv (%bitwise-eqv (%bitwise-eqv i j) k) l)

    (define (bitwise-eqv . args)
      (let lp ((args args) (ans -1))
        (if (pair? args)
            (lp (cdr args) (bitwise-not (bitwise-xor ans (car args)))) ans)))

    ;;; Helper function -- make a mask of SIZE 1-bits, e.g. (%MASK 3) = #b111.
    ;;; Suppose your Scheme's fixnums are N bits wide (counting the sign bit,
    ;;; not counting any tag bits). This version, due to Marc Feeley, will
    ;;; handle SIZE in the range [0,N-1] without overflowing to bignums.
    ;;; (For SIZE >= N, the correct bignum value is also produced.)

    (define (mask start end)
      (bitwise-not (arithmetic-shift -1 (- end start))))

    ;;; This alternate, mathematically-equivalent expression
    ;;;     (- (arithmetic-shift 1 size) 1)
    ;;; is not as good -- it only handles SIZE in the range [0,N-2] without
    ;;; overflowing to bignums.
    ;;;
    ;;; Finally, note that even Feeley's expression can't build an N-bit mask
    ;;; without bignum help. This is fundamental, since the interpretation
    ;;; of fixed-size fixnum bit patterns as semi-infinite-bit-strings is that
    ;;; you replicate the high bit out to infinity. So you have to have a
    ;;; zero "stop bit" appearing after that highest one bit to turn off the
    ;;; replication of the ones.

    (define (bit-set? index n)
      (native-bit-set? n index))

    (define (any-bit-set? test-bits n) (not (zero? (bitwise-and test-bits n))))

    (define (every-bit-set? test-bits n) (= test-bits (bitwise-and test-bits n)))

    ;;; Bit-field ops

    (define (bit-field n start end)
      (bitwise-and (mask start end) (arithmetic-shift n (- start))))

    (define (bit-field-any? n start end)
      (not (zero? (bitwise-and (arithmetic-shift n (- start)) (mask start end)))))

    ;; Part of Olin's late revisions; code by John Cowan; public domain.
    (define (bit-field-every? n start end)
      (let ((m (mask start end)))
        (eqv? m (bitwise-and (arithmetic-shift n (- start)) m))))

    ;; Integrating i-b-f reduces nicely.
    (define (bit-field-clear n start end)
      (bit-field-replace n 0 start end))

    ;; Counterpart to above, not in SRFI 33, written by John Cowan, public domain
    (define (bit-field-set n start end)
      (bit-field-replace n -1 start end))

    ;;; This three-line version won't fixnum-overflow on fixnum args.
    (define (bit-field-replace n newfield start end)
      (let ((m (mask start end)))
        (bitwise-ior (bitwise-and n (bitwise-not (arithmetic-shift m start)))
    		 (arithmetic-shift (bitwise-and newfield m) start))))

    (define (bit-field-replace-same to from start end)
      (bitwise-if (arithmetic-shift (mask start end) start) from to))

    (define first-set-bit first-bit-set)
  )

  (begin
    ;; bitwise-60 - SRFI-60 procedures without SRFI-33 analogues, renamed
    ;; Copyright (C) 1991, 1993, 2001, 2003, 2005 Aubrey Jaffer
    ;;
    ;; Permission to copy this software, to modify it, to redistribute it,
    ;; to distribute modified versions, and to use it for any purpose is
    ;; granted, subject to the following restrictions and understandings.
    ;;
    ;; 1.  Any copy made of this software must include this copyright notice
    ;;     in full.
    ;; 2.  I have made no warranty or representation that the operation of
    ;;     this software will be error-free, and I am under no obligation to
    ;;     provide any services, by way of maintenance, update, or otherwise.
    ;; 3.  In conjunction with products arising from the use of this
    ;;     material, there shall be no use of my name in any advertising,
    ;;     promotional, or sales literature without prior written consent in
    ;;     each case.

    (define (bit-field-rotate n count start end)
      (define width (- end start))
      (set! count (modulo count width))
      (let ((mask (bitwise-not (arithmetic-shift -1 width))))
        (define zn (bitwise-and mask (arithmetic-shift n (- start))))
        (bitwise-ior (arithmetic-shift
                 (bitwise-ior (bitwise-and mask (arithmetic-shift zn count))
                         (arithmetic-shift zn (- count width)))
                 start)
                (bitwise-and (bitwise-not (arithmetic-shift mask start)) n))))

    (define (bit-reverse k n)
      (do ((m (if (negative? n) (bitwise-not n) n) (arithmetic-shift m -1))
           (k (+ -1 k) (+ -1 k))
           (rvs 0 (bitwise-ior (arithmetic-shift rvs 1) (bitwise-and 1 m))))
          ((negative? k) (if (negative? n) (bitwise-not rvs) rvs))))


    (define (bit-field-reverse n start end)
      (define width (- end start))
      (let ((mask (bitwise-not (arithmetic-shift -1 width))))
        (define zn (bitwise-and mask (arithmetic-shift n (- start))))
        (bitwise-ior (arithmetic-shift (bit-reverse width zn) start)
                (bitwise-and (bitwise-not (arithmetic-shift mask start)) n))))

    (define (copy-bit index to bool)
      (native-copy-bit to index (if (eq? bool #t) 1 (if (eq? bool #f) 0 bool))))

    (define (bits->list k . len)
      (if (null? len)
          (do ((k k (arithmetic-shift k -1))
               (lst '() (cons (odd? k) lst)))
              ((<= k 0) (reverse lst)))
          (do ((idx (+ -1 (car len)) (+ -1 idx))
               (k k (arithmetic-shift k -1))
               (lst '() (cons (odd? k) lst)))
              ((negative? idx) (reverse lst)))))

    (define (list->bits bools)
      (do ((bs (reverse bools) (cdr bs))
           (acc 0 (+ acc acc (if (car bs) 1 0))))
          ((null? bs) acc)))

    (define (bits . bools)
      (list->bits bools))
  )

  (begin
    ;; bitwise-other - functions not from SRFI 33 or SRFI 60
    ;; Copyright John Cowan 2017

    (define bits->vector
      (case-lambda
        ((i) (list->vector (bits->list i)))
        ((i len) (list->vector (bits->list i len)))))

    (define (vector->bits vector) (list->bits (vector->list vector)))

    (define (bit-swap n1 n2 i)
      (let ((n1-bit (bit-set? n1 i))
            (n2-bit (bit-set? n2 i)))
        (copy-bit n2 (copy-bit n1 i n2-bit) n1-bit)))

    (define (bitwise-fold proc seed i)
      (let ((len (integer-length i)))
        (let loop ((n 0) (r seed))
          (if (= n len)
            r
            (loop (+ n 1) (proc (bit-set? n i) r))))))

    (define (bitwise-for-each proc i)
      (let ((len (integer-length i)))
        (let loop ((n 0))
          (when (< n len)
            (proc (bit-set? n i))
            (loop (+ n 1))))))

    (define (bitwise-unfold stop? mapper successor seed)
      (let loop ((n 0) (result 0) (state seed))
        (if (stop? state)
          result
            (loop (+ n 1)
                  (copy-bit n result (mapper state))
                  (successor state)))))

    (define (make-bitwise-generator i)
      (lambda ()
        (let ((bit (bit-set? 0 i)))
           (set! i (arithmetic-shift i -1))
           bit)))
  )
)
;;; SRFI 152
;;; String Library (reduced)
;;; 
;;; Scheme has an impoverished set of string-processing utilities, which is a problem for
;;; authors of portable code. This SRFI proposes a coherent and comprehensive set of
;;; string-processing procedures. It is a reduced version of SRFI 13 that has been aligned
;;; with SRFI 135, Immutable Texts. Unlike SRFI 13, it has been made consistent with the
;;; R5RS, R6RS, and R7RS-small string procedures.
;;; 
;;; Specification:
;;;   Copyright © 2017 John Cowan. All Rights Reserved.
;;;   
;;;   Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;;   software and associated documentation files (the "Software"), to deal in the Software
;;;   without restriction, including without limitation the rights to use, copy, modify,
;;;   merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;;   permit persons to whom the Software is furnished to do so, subject to the following
;;;   conditions:
;;;  
;;;   The above copyright notice and this permission notice shall be included in all copies
;;;   or substantial portions of the Software.
;;; 
;;; Implementation:
;;;   SRFI 130 string library reference implementation
;;;   Olin Shivers 7/2000
;;;   John Cowan 4/2016
;;;   
;;;   Copyright © 1988-1994 Massachusetts Institute of Technology.
;;;   Copyright © 1998, 1999, 2000 Olin Shivers.
;;;   Copyright © 2016 John Cowan.
;;;     The details of the copyrights appear at the end of the file. Short summary:
;;;     BSD-style open source.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 152)
  
  (export string-null?
          string-every
          string-any
          string-tabulate
          string-unfold
          string-unfold-right
          reverse-list->string
          string-take
          string-drop
          string-take-right
          string-drop-right
          string-pad
          string-pad-right
          string-trim
          string-trim-right
          string-trim-both
          string-replace
          string-prefix-length
          string-suffix-length
          string-prefix?
          string-suffix?
          string-index
          string-index-right
          string-skip
          string-skip-right
          string-contains
          string-contains-right
          string-take-while
          string-take-while-right
          string-drop-while
          string-drop-while-right
          string-break string-span
          string-append
          string-concatenate
          string-concatenate-reverse
          string-join
          string-fold
          string-fold-right
          string-count
          string-filter
          string-remove
          string-replicate
          string-segment
          string-split)

  (import (except (lispkit base) string-pad-left
                                 string-pad-right
                                 string-trim
                                 string-split
                                 string-prefix?
                                 string-suffix?
                                 string-contains
                                 string-map
                                 string->vector
                                 string-concatenate)
          (srfi 8))
  
  ;;; UTILITIES
  
  (begin
    (define (check-arg pred val proc) 
      (if (pred val) val (error "Bad arg" val pred proc)))
      
    (define-syntax let-optionals*
      (syntax-rules ()
        ((let-optionals* arg (opt-clause ...) body ...)
         (let ((rest arg))
           (%let-optionals* rest (opt-clause ...) body ...)))))
    
    (define-syntax %let-optionals*
      (syntax-rules ()
        ((%let-optionals* arg (((var ...) xparser) opt-clause ...) body ...)
         (call-with-values (lambda () (xparser arg))
           (lambda (rest var ...)
             (%let-optionals* rest (opt-clause ...) body ...))))
        ((%let-optionals* arg ((var default) opt-clause ...) body ...)
         (call-with-values (lambda () (if (null? arg) (values default '())
    				      (values (car arg) (cdr arg))))
           (lambda (var rest)
    	 (%let-optionals* rest (opt-clause ...) body ...))))
        ((%let-optionals* arg ((var default test) opt-clause ...) body ...)
         (call-with-values (lambda ()
    			 (if (null? arg) (values default '())
    			     (let ((var (car arg)))
    			       (if test (values var (cdr arg))
    				   (error "arg failed LET-OPT test" var)))))
           (lambda (var rest)
    	 (%let-optionals* rest (opt-clause ...) body ...))))
        ((%let-optionals* arg ((var default test supplied?) opt-clause ...) body ...)
         (call-with-values (lambda ()
    			 (if (null? arg) (values default #f '())
    			     (let ((var (car arg)))
    			       (if test (values var #t (cdr arg))
    				   (error "arg failed LET-OPT test" var)))))
           (lambda (var supplied? rest)
    	 (%let-optionals* rest (opt-clause ...) body ...))))
        ((%let-optionals* arg (rest) body ...)
         (let ((rest arg)) body ...))
        ((%let-optionals* arg () body ...)
         (if (null? arg) (begin body ...)
    	 (error "Too many arguments in let-opt" arg)))))
    
    ;; Support for START/END substring specs
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; This macro parses optional start/end arguments from arg lists, defaulting
    ;; them to 0/(string-length s), and checks them for correctness.
    
    (define-syntax let-string-start+end
      (syntax-rules ()
        ((let-string-start+end (start end) proc s-exp args-exp body ...)
          (receive (start end) (string-parse-final-start+end proc s-exp args-exp)
            body ...))
        ((let-string-start+end (start end rest) proc s-exp args-exp body ...)
          (receive (rest start end) (string-parse-start+end proc s-exp args-exp)
            body ...))))
    
    ;; This one parses out a *pair* of final start/end indices. 
    ;; Not exported; for internal use.
    (define-syntax let-string-start+end2
      (syntax-rules ()
        ((l-s-s+e2 (start1 end1 start2 end2) proc s1 s2 args body ...)
         (let ((procv proc)) ; Make sure PROC is only evaluated once.
           (let-string-start+end (start1 end1 rest) procv s1 args
             (let-string-start+end (start2 end2) procv s2 rest
               body ...))))))
    
    ;; Returns three values: rest start end
    (define (string-parse-start+end proc s args)
      (if (not (string? s)) (error "Non-string value" proc s))
      (let ((slen (string-length s)))
        (if (pair? args)
        	(let ((start (car args))
        	      (args (cdr args)))
        	  (if (and (integer? start) (exact? start) (>= start 0))
        	      (receive (end args)
        		  (if (pair? args)
        		      (let ((end (car args))
        			    (args (cdr args)))
        			(if (and (integer? end) (exact? end) (<= end slen))
        			    (values end args)
        			    (error "Illegal substring END spec" proc end s)))
        		      (values slen args))
        		(if (<= start end) (values args start end)
        		    (error "Illegal substring START/END spec"
        			   proc start end s)))
        	      (error "Illegal substring START spec" proc start s)))
        	(values '() 0 slen))))
       
    (define (string-parse-final-start+end proc s args)
      (receive (rest start end) (string-parse-start+end proc s args)
        (if (pair? rest) (error "Extra arguments to procedure" proc rest)
    	(values start end))))
    
    (define (substring-spec-ok? s start end)
      (and (string? s)
           (integer? start)
           (exact? start)
           (integer? end)
           (exact? end)
           (<= 0 start)
           (<= start end)
           (<= end (string-length s))))
    
    (define (check-substring-spec proc s start end)
      (if (not (substring-spec-ok? s start end))
          (error "Illegal substring spec." proc s start end)))
       
    ;; Split out so that other routines in this library can avoid arg-parsing
    ;; overhead for END parameter.
    (define (%substring s start end)
      (if (and (zero? start) (= end (string-length s))) s
          (substring s start end)))
  )
  
  ;;; EXTERNAL
  
  (begin
    ;; Basic iterators and other higher-order abstractions
    ;; (string-map proc s [start end])
    ;; (string-fold kons knil s [start end])
    ;; (string-fold-right kons knil s [start end])
    ;; (string-unfold       p f g seed [base make-final])
    ;; (string-unfold-right p f g seed [base make-final])
    ;; (string-for-each proc s [start end])
    ;; (string-every char/pred s [start end])
    ;; (string-any   char/pred s [start end])
    ;; (string-tabulate proc len)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; You want compiler support for high-level transforms on fold and unfold ops.
    ;; You'd at least like a lot of inlining for clients of these procedures.
    ;; Don't hold your breath.
    
    (define (string-map proc s . maybe-start+end)
      (check-arg procedure? proc string-map)
      (let-string-start+end (start end) string-map s maybe-start+end
        (%string-map proc s start end)))
    
    (define (%string-map proc s start end)	; Internal utility
      (let* ((len (- end start))
    	 (ans (make-string len)))
        (do ((i (- end 1) (- i 1))
    	 (j (- len 1) (- j 1)))
    	((< j 0))
          (string-set! ans j (proc (string-ref s i))))
        ans))
    
    (define (string-fold kons knil s . maybe-start+end)
      (check-arg procedure? kons string-fold)
      (let-string-start+end (start end) string-fold s maybe-start+end
        (let lp ((v knil) (i start))
          (if (< i end) (lp (kons (string-ref s i) v) (+ i 1))
    	  v))))
    
    (define (string-fold-right kons knil s . maybe-start+end)
      (check-arg procedure? kons string-fold-right)
      (let-string-start+end (start end) string-fold-right s maybe-start+end
        (let lp ((v knil) (i (- end 1)))
          (if (>= i start) (lp (kons (string-ref s i) v) (- i 1))
    	  v))))
    
    ;; (string-unfold p f g seed [base make-final])
    ;; This is the fundamental constructor for strings. 
    ;; - G is used to generate a series of "seed" values from the initial seed:
    ;;     SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...
    ;; - P tells us when to stop -- when it returns true when applied to one 
    ;;   of these seed values.
    ;; - F maps each seed value to the corresponding character 
    ;;   in the result string. These chars are assembled into the
    ;;   string in a left-to-right order.
    ;; - BASE is the optional initial/leftmost portion of the constructed string;
    ;;   it defaults to the empty string "".
    ;; - MAKE-FINAL is applied to the terminal seed value (on which P returns
    ;;   true) to produce the final/rightmost portion of the constructed string.
    ;;   It defaults to (LAMBDA (X) "").
    ;;
    ;; In other words, the following (simple, inefficient) definition holds:
    ;; (define (string-unfold p f g seed base make-final)
    ;;   (string-append base
    ;;                  (let recur ((seed seed))
    ;;                    (if (p seed) (make-final seed)
    ;;                        (string-append (string (f seed))
    ;;                                       (recur (g seed)))))))
    ;; 
    ;; STRING-UNFOLD is a fairly powerful constructor -- you can use it to
    ;; reverse a string, copy a string, convert a list to a string, read
    ;; a port into a string, and so forth. Examples:
    ;; (port->string port) =
    ;;   (string-unfold (compose eof-object? peek-char)
    ;;                  read-char values port)
    ;;
    ;; (list->string lis) = (string-unfold null? car cdr lis)
    ;; 
    ;; (tabulate-string f size) = (string-unfold (lambda (i) (= i size)) f fx1+ 0)
    
    ;; A problem with the following simple formulation is that it pushes one
    ;; stack frame for every char in the result string -- an issue if you are
    ;; using it to read a 100kchar string. So we don't use it -- but I include
    ;; it to give a clear, straightforward description of what the function
    ;; does.
        
    ;(define (string-unfold p f g seed base make-final)
    ;  (let ((ans (let recur ((seed seed) (i (string-length base)))
    ;               (if (p seed)
    ;                   (let* ((final (make-final seed))
    ;                          (ans (make-string (+ i (string-length final)))))
    ;                     (string-copy! ans i final)
    ;                     ans)
    ;
    ;                   (let* ((c (f seed))
    ;                          (s (recur (g seed) (+ i 1))))
    ;                     (string-set! s i c)
    ;                     s)))))
    ;    (string-copy! ans 0 base)
    ;    ans))
    
    ;; The strategy is to allocate a series of chunks into which we stash the
    ;; chars as we generate them. Chunk size goes up in powers of two starting
    ;; with 40 and levelling out at 4k, i.e.
    ;;     40 40 80 160 320 640 1280 2560 4096 4096 4096 4096 4096...
    ;; This should work pretty well for short strings, 1-line (80 char) strings,
    ;; and longer ones. When done, we allocate an answer string and copy the
    ;; chars over from the chunk buffers.
    
    (define (string-unfold p f g seed . base+make-final)
      (check-arg procedure? p string-unfold)
      (check-arg procedure? f string-unfold)
      (check-arg procedure? g string-unfold)
      (let-optionals* base+make-final
                      ((base       ""              (string? base))
    		   (make-final (lambda (x) "") (procedure? make-final)))
        (let lp ((chunks '())		; Previously filled chunks
    	     (nchars 0)			; Number of chars in CHUNKS
    	     (chunk (make-string 40))	; Current chunk into which we write
    	     (chunk-len 40)
    	     (i 0)			; Number of chars written into CHUNK
    	     (seed seed))
          (let lp2 ((i i) (seed seed))
    	(if (not (p seed))
    	    (let ((c (f seed))
    		  (seed (g seed)))
    	      (if (< i chunk-len)
    		  (begin (string-set! chunk i c)
    			 (lp2 (+ i 1) seed))
    
    		  (let* ((nchars2 (+ chunk-len nchars))
    			 (chunk-len2 (min 4096 nchars2))
    			 (new-chunk (make-string chunk-len2)))
    		    (string-set! new-chunk 0 c)
    		    (lp (cons chunk chunks) (+ nchars chunk-len)
    			new-chunk chunk-len2 1 seed))))
    
    	    ;; We're done. Make the answer string & install the bits.
    	    (let* ((final (make-final seed))
    		   (flen (string-length final))
    		   (base-len (string-length base))
    		   (j (+ base-len nchars i))
    		   (ans (make-string (+ j flen))))
    	      (%string-copy! ans j final 0 flen)	; Install FINAL.
    	      (let ((j (- j i)))
    		(%string-copy! ans j chunk 0 i)		; Install CHUNK[0,I).
    		(let lp ((j j) (chunks chunks))		; Install CHUNKS.
    		  (if (pair? chunks)
    		      (let* ((chunk  (car chunks))
    			     (chunks (cdr chunks))
    			     (chunk-len (string-length chunk))
    			     (j (- j chunk-len)))
    			(%string-copy! ans j chunk 0 chunk-len)
    			(lp j chunks)))))
    	      (%string-copy! ans 0 base 0 base-len)	; Install BASE.
    	      ans))))))
    
    (define (string-unfold-right p f g seed . base+make-final)
      (let-optionals* base+make-final
                      ((base "" (string? base))
    		   (make-final (lambda (x) "") (procedure? make-final)))
        (let lp ((chunks '())		; Previously filled chunks
    	     (nchars 0)			; Number of chars in CHUNKS
    	     (chunk (make-string 40))	; Current chunk into which we write
    	     (chunk-len 40)
    	     (i 40)			; Number of chars available in CHUNK
    	     (seed seed))
          (let lp2 ((i i) (seed seed))	; Fill up CHUNK from right
    	(if (not (p seed))		; to left.
    	    (let ((c (f seed))
    		  (seed (g seed)))
    	      (if (> i 0)
    		  (let ((i (- i 1)))
    		    (string-set! chunk i c)
    		    (lp2 i seed))
    
    		  (let* ((nchars2 (+ chunk-len nchars))
    			 (chunk-len2 (min 4096 nchars2))
    			 (new-chunk (make-string chunk-len2))
    			 (i (- chunk-len2 1)))
    		    (string-set! new-chunk i c)
    		    (lp (cons chunk chunks) (+ nchars chunk-len)
    			new-chunk chunk-len2 i seed))))
    	    ;; We're done. Make the answer string & install the bits.
    	    (let* ((final (make-final seed))
    		   (flen (string-length final))
    		   (base-len (string-length base))
    		   (chunk-used (- chunk-len i))
    		   (j (+ base-len nchars chunk-used))
    		   (ans (make-string (+ j flen))))
    	      (%string-copy! ans 0 final 0 flen)	; Install FINAL.
    	      (%string-copy! ans flen chunk i chunk-len); Install CHUNK[I,).
    	      (let lp ((j (+ flen chunk-used))		; Install CHUNKS.
    		       (chunks chunks))		
    		  (if (pair? chunks)
    		      (let* ((chunk  (car chunks))
    			     (chunks (cdr chunks))
    			     (chunk-len (string-length chunk)))
    			(%string-copy! ans j chunk 0 chunk-len)
    			(lp (+ j chunk-len) chunks))
    		      (%string-copy! ans j base 0 base-len))); Install BASE.
    	      ans))))))
    
    (define (string-every criterion s . maybe-start+end)
      (let-string-start+end (start end) string-every s maybe-start+end
    	   (or (= start end)			; final (PRED S[END-1]) call
    	       (let lp ((i start))		; is a tail call.
    		 (let ((c (string-ref s i))
    		       (i1 (+ i 1)))
    		   (if (= i1 end) (criterion c)	; Tail call.
    		       (and (criterion c) (lp i1))))))))
    
    (define (string-any criterion s . maybe-start+end)
      (let-string-start+end (start end) string-any s maybe-start+end
    	   (and (< start end)			; final (PRED S[END-1]) call
    		(let lp ((i start))		; is a tail call.
    		  (let ((c (string-ref s i))
    			(i1 (+ i 1)))
    		    (if (= i1 end) (criterion c)	; Tail call
    			(or (criterion c) (lp i1))))))))
    
    (define (string-tabulate proc len)
      (check-arg procedure? proc string-tabulate)
      (check-arg (lambda (val) (and (integer? val) (exact? val) (<= 0 val)))
    	     len string-tabulate)
      (let ((s (make-string len)))
        (do ((i (- len 1) (- i 1)))
    	((< i 0))
          (string-set! s i (proc i)))
        s))
    
    ;; string-prefix-length s1 s2 [start1 end1 start2 end2]
    ;; string-suffix-length s1 s2 [start1 end1 start2 end2]
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Find the length of the common prefix/suffix.
    ;; It is not required that the two substrings passed be of equal length.
    ;; This was microcode in MIT Scheme -- a very tightly bummed primitive.
    ;; %STRING-PREFIX-LENGTH is the core routine of all string-comparisons,
    ;; so should be as tense as possible.
    
    (define (%string-prefix-length s1 start1 end1 s2 start2 end2)
      (let* ((delta (min (- end1 start1) (- end2 start2)))
    	 (end1 (+ start1 delta)))
    
        (if (and (eq? s1 s2) (= start1 start2))	; EQ fast path
    	delta
    
    	(let lp ((i start1) (j start2))		; Regular path
    	  (if (or (>= i end1)
    		  (not (char=? (string-ref s1 i)
    			       (string-ref s2 j))))
    	      (- i start1)
    	      (lp (+ i 1) (+ j 1)))))))
    
    (define (%string-suffix-length s1 start1 end1 s2 start2 end2)
      (let* ((delta (min (- end1 start1) (- end2 start2)))
    	 (start1 (- end1 delta)))
    
        (if (and (eq? s1 s2) (= end1 end2))		; EQ fast path
    	delta
    
    	(let lp ((i (- end1 1)) (j (- end2 1)))	; Regular path
    	  (if (or (< i start1)
    		  (not (char=? (string-ref s1 i)
    			       (string-ref s2 j))))
    	      (- (- end1 i) 1)
    	      (lp (- i 1) (- j 1)))))))
    
    (define (string-prefix-length s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) 
    			 string-prefix-length s1 s2 maybe-starts+ends
        (%string-prefix-length s1 start1 end1 s2 start2 end2)))
    
    (define (string-suffix-length s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) 
    			 string-suffix-length s1 s2 maybe-starts+ends
        (%string-suffix-length s1 start1 end1 s2 start2 end2)))
    
    ;; string-prefix?    s1 s2 [start1 end1 start2 end2]
    ;; string-suffix?    s1 s2 [start1 end1 start2 end2]
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; These are all simple derivatives of the previous counting funs.
    
    (define (string-prefix? s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) 
    			 string-prefix? s1 s2 maybe-starts+ends
        (%string-prefix? s1 start1 end1 s2 start2 end2)))
    
    (define (string-suffix? s1 s2 . maybe-starts+ends)
      (let-string-start+end2 (start1 end1 start2 end2) 
    			 string-suffix? s1 s2 maybe-starts+ends
        (%string-suffix? s1 start1 end1 s2 start2 end2)))
    
    ;; Here are the internal routines that do the real work.
    
    (define (%string-prefix? s1 start1 end1 s2 start2 end2)
      (let ((len1 (- end1 start1)))
        (and (<= len1 (- end2 start2))	; Quick check
    	 (= (%string-prefix-length s1 start1 end1
    				   s2 start2 end2)
    	    len1))))
    
    (define (%string-suffix? s1 start1 end1 s2 start2 end2)
      (let ((len1 (- end1 start1)))
        (and (<= len1 (- end2 start2))	; Quick check
    	 (= len1 (%string-suffix-length s1 start1 end1
    					s2 start2 end2)))))
    
    ;; Cutting & pasting strings
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; string-take string nchars
    ;; string-drop string nchars
    ;;
    ;; string-take-right string nchars
    ;; string-drop-right string nchars
    ;;
    ;; string-pad string k [char start end] 
    ;; string-pad-right string k [char start end] 
    ;; 
    ;; string-trim       string [char/char-set/pred start end] 
    ;; string-trim-right string [char/char-set/pred start end] 
    ;; string-trim-both  string [char/char-set/pred start end] 
    ;;
    ;; These trimmers invert the char-set meaning from MIT Scheme -- you
    ;; say what you want to trim.
    
    (define (string-take s n)
      (check-arg string? s string-take)
      (check-arg (lambda (val) (and (integer? n) (exact? n)
    				(<= 0 n (string-length s))))
    	     n string-take)
      (%substring s 0 n))
    
    (define (string-take-right s n)
      (check-arg string? s string-take-right)
      (let ((len (string-length s)))
        (check-arg (lambda (val) (and (integer? n) (exact? n) (<= 0 n len)))
    	       n string-take-right)
        (%substring s (- len n) len)))
    
    (define (string-drop s n)
      (check-arg string? s string-drop)
      (let ((len (string-length s)))
        (check-arg (lambda (val) (and (integer? n) (exact? n) (<= 0 n len)))
    	       n string-drop)
      (%substring s n len)))
    
    (define (string-drop-right s n)
      (check-arg string? s string-drop-right)
      (let ((len (string-length s)))
        (check-arg (lambda (val) (and (integer? n) (exact? n) (<= 0 n len)))
    	       n string-drop-right)
        (%substring s 0 (- len n))))
    
    
    (define (string-trim s . criterion+start+end)
      (let-optionals* criterion+start+end ((criterion char-whitespace?) rest)
        (let-string-start+end (start end) string-trim s rest
          (cond ((string-skip s criterion start end) =>
    	     (lambda (i) (%substring s i end)))
    	    (else "")))))
    
    (define (string-trim-right s . criterion+start+end)
      (let-optionals* criterion+start+end ((criterion char-whitespace?) rest)
        (let-string-start+end (start end) string-trim-right s rest
          (cond ((string-skip-right s criterion start end) =>
    	     (lambda (i) (%substring s start (+ 1 i))))
    	    (else "")))))
    
    (define (string-trim-both s . criterion+start+end)
      (let-optionals* criterion+start+end ((criterion char-whitespace?) rest)
        (let-string-start+end (start end) string-trim-both s rest
          (cond ((string-skip s criterion start end) =>
    	     (lambda (i)
    	       (%substring s i (+ 1 (string-skip-right s criterion i end)))))
    	    (else "")))))
    
    
    (define (string-pad-right s n . char+start+end)
      (let-optionals* char+start+end ((char #\space (char? char)) rest)
        (let-string-start+end (start end) string-pad-right s rest
          (check-arg (lambda (n) (and (integer? n) (exact? n) (<= 0 n)))
    		 n string-pad-right)
          (let ((len (- end start)))
    	(if (<= n len)
    	    (%substring s start (+ start n))
    	    (let ((ans (make-string n char)))
    	      (%string-copy! ans 0 s start end)
    	      ans))))))
    
    (define (string-pad s n . char+start+end)
      (let-optionals* char+start+end ((char #\space (char? char)) rest)
        (let-string-start+end (start end) string-pad s rest
          (check-arg (lambda (n) (and (integer? n) (exact? n) (<= 0 n)))
    		 n string-pad)
          (let ((len (- end start)))
    	(if (<= n len)
    	    (%substring s (- end n) end)
    	    (let ((ans (make-string n char)))
    	      (%string-copy! ans (- n len) s start end)
    	      ans))))))
    
    ;; Filtering strings
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; string-remove char/pred string [start end]
    ;; string-filter char/pred string [start end]
    ;;
    ;; If the criterion is a predicate, we don't do this double-scan strategy, 
    ;;   because the predicate might have side-effects or be very expensive to
    ;;   compute. So we preallocate a temp buffer pessimistically, and only do
    ;;   one scan over S. This is likely to be faster and more space-efficient
    ;;   than consing a list.
    
    (define (string-remove criterion s . maybe-start+end)
      (let-string-start+end (start end) string-remove s maybe-start+end
    	(let* ((slen (- end start))
    	       (temp (make-string slen))
    	       (ans-len (string-fold (lambda (c i)
    				       (if (criterion c) i
    					   (begin (string-set! temp i c)
    						  (+ i 1))))
    				     0 s start end)))
    	  (if (= ans-len slen) temp (substring temp 0 ans-len)))))
    
    	  
    
    (define (string-filter criterion s . maybe-start+end)
      (let-string-start+end (start end) string-filter s maybe-start+end
    	(let* ((slen (- end start))
    	       (temp (make-string slen))
    	       (ans-len (string-fold (lambda (c i)
    				       (if (criterion c)
    					   (begin (string-set! temp i c)
    						  (+ i 1))
    					   i))
    				     0 s start end)))
    	  (if (= ans-len slen) temp (substring temp 0 ans-len)))))
    
    ;; String search
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; string-index       string char/pred [start end]
    ;; string-index-right string char/pred [start end]
    ;; string-skip        string char/pred [start end]
    ;; string-skip-right  string char/pred [start end]
    ;; string-count       string char/pred [start end]
    ;;     There's a lot of replicated code here for efficiency.
    
    (define (string-index str criterion . maybe-start+end)
      (let-string-start+end (start end) string-index str maybe-start+end
               (let lp ((i start))
                 (and (< i end)
                      (if (criterion (string-ref str i)) i
                          (lp (+ i 1)))))))
    
    (define (string-index-right str criterion . maybe-start+end)
      (let-string-start+end (start end) string-index-right str maybe-start+end
    	   (let lp ((i (- end 1)))
    	     (and (>= i start)
    		  (if (criterion (string-ref str i)) i
    		      (lp (- i 1)))))))
    
    (define (string-skip str criterion . maybe-start+end)
      (let-string-start+end (start end) string-skip str maybe-start+end
               (let lp ((i start))
                 (and (< i end)
                      (if (criterion (string-ref str i)) (lp (+ i 1))
                          i)))))
    
    (define (string-skip-right str criterion . maybe-start+end)
      (let-string-start+end (start end) string-skip-right str maybe-start+end
               (let lp ((i (- end 1)))
                 (and (>= i start)
                      (if (criterion (string-ref str i)) (lp (- i 1))
                          i)))))
    
    ;; Useful hacks added for SRFI 152
    
    (define (string-take-while s criterion . maybe-start+end)
      (let-string-start+end (start end) string-take-while s maybe-start+end
        (let ((idx (string-skip s criterion start end)))
          (if idx
              (%substring s 0 idx)
              ""))))
    
    (define (string-take-while-right s criterion . maybe-start+end)
      (let-string-start+end (start end) string-take-while s maybe-start+end
        (let ((idx (string-skip-right s criterion start end)))
          (if idx
              (%substring s (+ idx 1) (string-length s))
              ""))))
    
    (define (string-drop-while s criterion . maybe-start+end)
      (let-string-start+end (start end) string-drop-while s maybe-start+end
        (let ((idx (string-skip s criterion start end)))
          (if idx
              (%substring s idx (string-length s))
              s))))
    
    (define (string-drop-while-right s criterion . maybe-start+end)
      (let-string-start+end (start end) string-drop-while s maybe-start+end
        (let ((idx (string-skip-right s criterion start end)))
          (if idx
              (%substring s 0 (+ idx 1))
              s))))
    
    (define (string-span s criterion . maybe-start+end)
      (let-string-start+end (start end) string-span s maybe-start+end
        (let ((idx (string-skip s criterion start end)))
          (if idx
            (values (%substring s 0 idx) (%substring s idx (string-length s)))
            (values "" s)))))
    
    (define (string-break s criterion . maybe-start+end)
      (let-string-start+end (start end) string-break s maybe-start+end
        (let ((idx (string-index s criterion start end)))
          (if idx
            (values (%substring s 0 idx) (%substring s idx (string-length s)))
            (values s "")))))
    
    (define (string-count s criterion . maybe-start+end)
      (let-string-start+end (start end) string-count s maybe-start+end
    	   (do ((i start (+ i 1))
    		(count 0 (if (criterion (string-ref s i)) (+ count 1) count)))
    	       ((>= i end) count))))
    
    ;; %string-copy! to tstart from [fstart fend]
    ;; 	Guaranteed to work, even if s1 eq s2.
    ;; Library-internal routine
    (define (%string-copy! to tstart from fstart fend)
      (if (> fstart tstart)
          (do ((i fstart (+ i 1))
    	   (j tstart (+ j 1)))
    	  ((>= i fend))
    	(string-set! to j (string-ref from i)))
    
          (do ((i (- fend 1)                    (- i 1))
    	   (j (+ -1 tstart (- fend fstart)) (- j 1)))
    	  ((< i fstart))
    	(string-set! to j (string-ref from i)))))
    
    ;; Returns starting-position in STRING or #f if not true.
    ;; This implementation is slow & simple. It is useful as a "spec" or for
    ;; comparison testing with fancier implementations.
    ;; See below for fast KMP version.
    
    ;(define (string-contains string substring . maybe-starts+ends)
    ;  (let-string-start+end2 (start1 end1 start2 end2) 
    ;                         string-contains string substring maybe-starts+ends
    ;    (let* ((len (- end2 start2))
    ;	   (i-bound (- end1 len)))
    ;      (let lp ((i start1))
    ;	(and (< i i-bound)
    ;	     (if (string= string substring i (+ i len) start2 end2)
    ;		 i
    ;		 (lp (+ i 1))))))))
    
    ;; Searching for an occurrence of a substring    
    (define (string-contains text pattern . maybe-starts+ends)
      (let-string-start+end2 (t-start t-end p-start p-end)
                             string-contains text pattern maybe-starts+ends
        (%kmp-search pattern text char=? p-start p-end t-start t-end)))
    
    (define (string-contains-right text pattern . maybe-starts+ends)
      (let-string-start+end2 (t-start t-end p-start p-end)
                             string-contains-right text pattern maybe-starts+ends
        (let* ((t-len (string-length text))
               (p-len (string-length pattern))
               (p-size (- p-end p-start))
               (rt-start (- t-len t-end))
               (rt-end (- t-len t-start))
               (rp-start (- p-len p-end))
               (rp-end (- p-len p-start))
               (res (%kmp-search (string-reverse pattern)
                                 (string-reverse text)
                                 char=? rp-start rp-end rt-start rt-end)))
          (if res
            (- t-len res p-size)
            #f))))
    
    ;; Knuth-Morris-Pratt string searching
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; See
    ;;     "Fast pattern matching in strings"
    ;;     SIAM J. Computing 6(2):323-350 1977
    ;;     D. E. Knuth, J. H. Morris and V. R. Pratt
    ;; also described in
    ;;     "Pattern matching in strings"
    ;;     Alfred V. Aho
    ;;     Formal Language Theory - Perspectives and Open Problems
    ;;     Ronald V. Brook (editor)
    ;; This algorithm is O(m + n) where m and n are the 
    ;; lengths of the pattern and string respectively
    
    ;; KMP search source[start,end) for PATTERN. Return starting index of leftmost match or #f.
    (define (%kmp-search pattern text c= p-start p-end t-start t-end)
      (let ((plen (- p-end p-start))
    	(rv (make-kmp-restart-vector pattern c= p-start p-end)))
        ;; The search loop. TJ & PJ are redundant state.
        (let lp ((ti t-start) (pi 0)
    	     (tj (- t-end t-start)) ; (- tlen ti) -- how many chars left.
    	     (pj plen))		 ; (- plen pi) -- how many chars left.
    
          (if (= pi plen)
    	  (- ti plen)			; Win.
    	  (and (<= pj tj)		; Lose.
    	       (if (c= (string-ref text ti) ; Search.
    		       (string-ref pattern (+ p-start pi)))
    		   (lp (+ 1 ti) (+ 1 pi) (- tj 1) (- pj 1)) ; Advance.
    		   
    		   (let ((pi (vector-ref rv pi))) ; Retreat.
    		     (if (= pi -1)
    			 (lp (+ ti 1) 0  (- tj 1) plen) ; Punt.
    			 (lp ti       pi tj       (- plen pi))))))))))
    
    ;; (make-kmp-restart-vector pattern [c= start end]) -> integer-vector
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Compute the KMP restart vector RV for string PATTERN.  If
    ;; we have matched chars 0..i-1 of PATTERN against a search string S, and
    ;; PATTERN[i] doesn't match S[k], then reset i := RV[i], and try again to
    ;; match S[k].  If RV[i] = -1, then punt S[k] completely, and move on to
    ;; S[k+1] and PATTERN[0] -- no possible match of PAT[0..i] contains S[k].
    ;;
    ;; In other words, if you have matched the first i chars of PATTERN, but
    ;; the i+1'th char doesn't match, RV[i] tells you what the next-longest
    ;; prefix of PATTERN is that you have matched.
    ;;
    ;; - C= (default CHAR=?) is used to compare characters for equality.
    ;;   Pass in CHAR-CI=? for case-folded string search.
    ;;
    ;; - START & END restrict the pattern to the indicated substring; the
    ;;   returned vector will be of length END - START. The numbers stored
    ;;   in the vector will be values in the range [0,END-START) -- that is,
    ;;   they are valid indices into the restart vector; you have to add START
    ;;   to them to use them as indices into PATTERN.
    ;;
    ;; I've split this out as a separate function in case other constant-string
    ;; searchers might want to use it.
    ;;
    ;; E.g.:
    ;;    a b d  a b x
    ;; #(-1 0 0 -1 1 2)
    (define (make-kmp-restart-vector pattern . maybe-c=+start+end)
      (let-optionals* maybe-c=+start+end
                      ((c= char=?) rest) ; (procedure? c=))
         (receive (rest2 start end) (string-parse-start+end make-kmp-restart-vector pattern rest)
           (let* ((rvlen (- end start))
    	      (rv (make-vector rvlen -1)))
          (if (> rvlen 0)
    	  (let ((rvlen-1 (- rvlen 1))
    		(c0 (string-ref pattern start)))
    	    ;; Here's the main loop. We have set rv[0] ... rv[i].
    	    ;; K = I + START -- it is the corresponding index into PATTERN.
    	    (let lp1 ((i 0) (j -1) (k start))
    	      (if (< i rvlen-1)
    		  ;; lp2 invariant:
    		  ;;   pat[(k-j) .. k-1] matches pat[start .. start+j-1]
    		  ;;   or j = -1.
    		  (let lp2 ((j j))
    		    (cond ((= j -1)
    			   (let ((i1 (+ i 1))
    				 (ck+1 (string-ref pattern (fx1+ k))))
    			     (vector-set! rv i1 (if (c= ck+1 c0) -1 0))
    			     (lp1 i1 0 (+ k 1))))
    
    			  ;; pat[(k-j) .. k] matches pat[start..start+j].
    			  ((c= (string-ref pattern k)
    			       (string-ref pattern (+ j start)))
    			   (let* ((i1 (+ 1 i))
    				  (j1 (+ 1 j)))
    			     (vector-set! rv i1 j1)
    			     (lp1 i1 j1 (+ k 1))))
    			  (else (lp2 (vector-ref rv j)))))))))
          rv))))
    
    ;; We've matched I chars from PAT. C is the next char from the search string.
    ;; Return the new I after handling C. 
    ;;
    ;; The pattern is (VECTOR-LENGTH RV) chars long, beginning at index PAT-START
    ;; in PAT (PAT-START is usually 0). The I chars of the pattern we've matched
    ;; are 
    ;;     PAT[PAT-START .. PAT-START + I].
    ;;
    ;; It's *not* an oversight that there is no friendly error checking or
    ;; defaulting of arguments. This is a low-level, inner-loop procedure
    ;; that we want integrated/inlined into the point of call.
    (define (kmp-step pat rv c i c= p-start)
      (let lp ((i i))
        (if (c= c (string-ref pat (+ i p-start)))	; Match =>
    	(+ i 1)                             ;   Done.
    	(let ((i (vector-ref rv i)))        ; Back up in PAT.
    	  (if (= i -1) 0                    ; Can't back up further.
    	      (lp i))))))                   ; Keep trying for match.
    
    ;; Zip through S[start,end), looking for a match of PAT. Assume we've
    ;; already matched the first I chars of PAT when we commence at S[start].
    ;; - <0:  If we find a match *ending* at index J, return -J.
    ;; - >=0: If we get to the end of the S[start,end) span without finding
    ;;   a complete match, return the number of chars from PAT we'd matched
    ;;   when we ran off the end.
    ;;
    ;; This is useful for searching *across* buffers -- that is, when your
    ;; input comes in chunks of text. We hand-integrate the KMP-STEP loop
    ;; for speed.
    (define (string-kmp-partial-search pat rv s i . c=+p-start+s-start+s-end)
      ; (check-arg vector? rv string-kmp-partial-search)
      (let-optionals* c=+p-start+s-start+s-end
          ((c=      char=?) ; (procedure? c=))
           (p-start 0) rest) ; (and (integer? p-start) (exact? p-start) (<= 0 p-start)))
        (receive (rest2 s-start s-end) (string-parse-start+end string-kmp-partial-search s rest)
        ;; Enough prelude. Here's the actual code.
        (let ((patlen (vector-length rv)))
          (let lp ((si s-start)		; An index into S.
    	       (vi i))			; An index into RV.
    	(cond ((= vi patlen) (- si))	; Win.
    	      ((= si s-end) vi)		; Ran off the end.
    	      (else			; Match s[si] & loop.
    	       (let ((c (string-ref s si)))
    		 (lp (+ si 1)	
    		     (let lp2 ((vi vi))	; This is just KMP-STEP.
    		       (if (c= c (string-ref pat (+ vi p-start)))
    			   (+ vi 1)
    			   (let ((vi (vector-ref rv vi)))
    			     (if (= vi -1) 0
    				 (lp2 vi))))))))))))) )
    
    ;; Misc
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; (string-null? s)
    ;; (reverse-list->string clist)
    ;; (string->list s [start end])
    
    (define (string-null? s) (zero? (string-length s)))
    
    (define (string-reverse s . maybe-start+end)
      (let-string-start+end (start end) string-reverse s maybe-start+end
        (let* ((len (- end start))
    	   (ans (make-string len)))
          (do ((i start (+ i 1))
    	   (j (- len 1) (- j 1)))
    	  ((< j 0))
    	(string-set! ans j (string-ref s i)))
          ans)))
    
    (define (reverse-list->string clist)
      (let* ((len (length clist))
    	 (s (make-string len)))
        (do ((i (- len 1) (- i 1))   (clist clist (cdr clist)))
    	((not (pair? clist)))
          (string-set! s i (car clist)))
        s))
    
    (define (string->vector s . maybe-start+end)
      (let-string-start+end (start end) string->list s maybe-start+end
        (define ans (make-vector (- end start)))
        (do ((i (- end 1) (- i 1)))
    	((< i start) ans)
          (vector-set! ans (- i start) (string-ref s i)))))
    
    ;; string-concatenate        string-list -> string
    ;; string-concatenate/shared string-list -> string
    (define (string-concatenate strings)
      (let* ((total (do ((strings strings (cdr strings))
    		     (i 0 (+ i (string-length (car strings)))))
    		    ((not (pair? strings)) i)))
    	 (ans (make-string total)))
        (let lp ((i 0) (strings strings))
          (if (pair? strings)
    	  (let* ((s (car strings))
    		 (slen (string-length s)))
    	    (%string-copy! ans i s 0 slen)
    	    (lp (+ i slen) (cdr strings)))))
        ans))
    
    ;; string-concatenate-reverse        string-list [final-string end] -> string
    ;; string-concatenate-reverse/shared string-list [final-string end] -> string
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Return
    ;;   (string-concatenate 
    ;;     (reverse
    ;;       (cons (substring final-string 0 end) string-list)))
    (define (string-concatenate-reverse string-list . maybe-final+end)
      (let-optionals* maybe-final+end ((final "" (string? final))
    				   (end (string-length final)
    					(and (integer? end)
    					     (exact? end)
    					     (<= 0 end (string-length final)))))
        (let ((len (let lp ((sum 0) (lis string-list))
    		 (if (pair? lis)
    		     (lp (+ sum (string-length (car lis))) (cdr lis))
    		     sum))))
    
          (%finish-string-concatenate-reverse len string-list final end))))
    
    (define (%finish-string-concatenate-reverse len string-list final end)
      (let ((ans (make-string (+ end len))))
        (%string-copy! ans len final 0 end)
        (let lp ((i len) (lis string-list))
          (if (pair? lis)
    	  (let* ((s   (car lis))
    		 (lis (cdr lis))
    		 (slen (string-length s))
    		 (i (- i slen)))
    	    (%string-copy! ans i s 0 slen)
    	    (lp i lis))))
        ans))
    
    ;; string-replace s1 s2 start1 end1 [start2 end2] -> string
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Replace S1[START1,END1) with S2[START2,END2).
    (define (string-replace s1 s2 start1 end1 . maybe-start+end)
      (check-substring-spec string-replace s1 start1 end1)
      (let-string-start+end (start2 end2) string-replace s2 maybe-start+end
        (let* ((slen1 (string-length s1))
               (sublen2 (- end2 start2))
               (alen (+ (- slen1 (- end1 start1)) sublen2))
               (ans (make-string alen)))
          (%string-copy! ans 0 s1 0 start1)
          (%string-copy! ans start1 s2 start2 end2)
          (%string-copy! ans (+ start1 sublen2) s1 end1 slen1)
          ans)))
    
    ;; string-split s delimiter [grammar limit start end] -> list
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Returns a list of the words contained in the substring of string from
    ;; start (inclusive) to end (exclusive). Delimiter specifies a string
    ;; whose characters are to be used as the word separator. The returned
    ;; list will then have one more item than the number of non-overlapping
    ;; occurrences of the delimiter in the string. If delimiter is an
    ;; empty string, then the returned list contains a list of strings,
    ;; each of which contains a single character.  Grammar is a symbol with
    ;; the same meaning as in the string-join procedure. If it is infix,
    ;; which is the default, processing is done as described above, except
    ;; that an empty s produces the empty list; if it is strict-infix,
    ;; an empty s signals an error. The values prefix and suffix cause a
    ;; leading/trailing empty string in the result to be suppressed.
    ;;
    ;; If limit is a non-negative exact integer, at most that many splits
    ;; occur, and the remainder of string is returned as the final element
    ;; of the list (thus, the result will have at most limit+1 elements). If
    ;; limit is not specified or is #f, then as many splits as possible
    ;; are made. It is an error if limit is any other value.
    ;;
    ;; Thanks to Shiro Kawai for the following code.
    
    (define (string-split s delimiter . args)
      ;; The argument checking part might be refactored with other srfi-130
      ;; routines.
      (if (not (string? s)) (error "string expected" s))
      (if (not (string? delimiter)) (error "string expected" delimiter))
      (let ((slen (string-length s)))
        (receive (grammar limit no-limit start end)
            (if (pair? args)
              (if (pair? (cdr args))
                (if (pair? (cddr args))
                  (if (pair? (cdddr args))
                    (values (car args) (cadr args) #f (caddr args) (cadddr args))
                    (values (car args) (cadr args) #f (caddr args) slen))
                  (values (car args) (cadr args) #f 0 slen))
                (values (car args) #f #t 0 slen))
              (values 'infix #f #t 0 slen))
          (if (not (memq grammar '(infix strict-infix prefix suffix)))
            (error "grammar must be one of (infix strict-infix prefix suffix)" grammar))
          (if (not limit) (set! no-limit #t))
          (if (not (or no-limit
                      (and (integer? limit) (exact? limit) (>= limit 0))))
            (error "limit must be exact nonnegative integer or #f" limit))
          (if (not (and (integer? start) (exact? start)))
            (error "start argument must be exact integer" start))
          (if (not (<= 0 start slen))
            (error "start argument out of range" start))
          (if (not (<= 0 end slen))
            (error "end argument out of range" end))
          (if (not (<= start end))
            (error "start argument is greater than end argument" (list start end)))
          (cond ((= start end)
                 (if (eq? grammar 'strict-infix)
                   (error "empty string cannot be spilt with strict-infix grammar")
                   '()))
                ((string-null? delimiter)
                 (%string-split-chars s start end limit))
                (else (%string-split s start end delimiter grammar limit))))))
    
    (define (%string-split-chars s start end limit)
      (if (not limit)
        (map string (string->list s start end))
        (let loop ((r '()) (c start) (n 0))
          (cond ((= c end) (reverse r))
                ((>= n limit) (reverse (cons (substring s c end) r)))
                (else (loop (cons (string (string-ref s c)) r)
                            (+ c 1)
                            (+ n 1)))))))
    
    (define (%string-split s start end delimiter grammar limit)
      (let ((dlen (string-length delimiter)))
        (define (finish r c)
          (let ((rest (substring s c end)))
            (if (and (eq? grammar 'suffix) (string-null? rest))
              (reverse r)
              (reverse (cons rest r)))))
        (define (scan r c n)
          (if (and limit (>= n limit))
            (finish r c)
            (let ((i (string-contains s delimiter c end)))
              (if i
                (let ((fragment (substring s c i)))
                  (if (and (= n 0) (eq? grammar 'prefix) (string-null? fragment))
                    (scan r (+ i dlen) (+ n 1))
                    (scan (cons fragment r) 
                          (+ i dlen)
                          (+ n 1))))
                (finish r c)))))
        (scan '() start 0)))
    
    ;; string-replicate s from [to start end] -> string
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; S is a string; START and END are optional arguments that demarcate
    ;; a substring of S, defaulting to 0 and the length of S (e.g., the whole
    ;; string). Replicate this substring up and down index space, in both the
    ;; positive and negative directions. For example, if S = "abcdefg", START=3, 
    ;; and END=6, then we have the conceptual bidirectionally-infinite string
    ;;     ...  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f ...
    ;;     ... -9 -8 -7 -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 ...
    ;; XSUBSTRING returns the substring of this string beginning at index FROM,
    ;; and ending at TO (which defaults to FROM+(END-START)).
    ;; 
    ;; You can use XSUBSTRING in many ways:
    ;; - To rotate a string left:  (string-replicate "abcdef" 2)  => "cdefab"
    ;; - To rotate a string right: (string-replicate "abcdef" -2) => "efabcd"
    ;; - To replicate a string:    (string-replicate "abc" 0 7) => "abcabca"
    ;;
    ;; Note that 
    ;;   - The FROM/TO indices give a half-open range -- the characters from
    ;;     index FROM up to, but not including index TO.
    ;;   - The FROM/TO indices are not in terms of the index space for string S.
    ;;     They are in terms of the replicated index space of the substring
    ;;     defined by S, START, and END.
    ;;
    ;; It is an error if START=END -- although this is allowed by special
    ;; dispensation when FROM=TO.
    (define (string-replicate s from . maybe-to+start+end)
      (check-arg (lambda (val) (and (integer? val) (exact? val)))
    	     from string-replicate)
      (receive (to start end)
               (if (pair? maybe-to+start+end)
    	       (let-string-start+end (start end) string-replicate s (cdr maybe-to+start+end)
    		 (let ((to (car maybe-to+start+end)))
    		   (check-arg (lambda (val) (and (integer? val)
    						 (exact? val)
    						 (<= from val)))
    			      to string-replicate)
    		   (values to start end)))
    	       (let ((slen (string-length (check-arg string? s string-replicate))))
    		 (values (+ from slen) 0 slen)))
        (let ((slen   (- end start))
    	  (anslen (- to  from)))
          (cond ((zero? anslen) "")
    	    ((zero? slen) (error "Cannot replicate empty (sub)string"
    				  string-replicate s from to start end))
    	    ((= 1 slen)		; Fast path for 1-char replication.
    	     (make-string anslen (string-ref s start)))
    	    ;; Selected text falls entirely within one span.
    	    ((= (floor (/ from slen)) (floor (/ to slen)))
    	     (substring s (+ start (modulo from slen))
    			  (+ start (modulo to   slen))))
    	    ;; Selected text requires multiple spans.
    	    (else (let ((ans (make-string anslen)))
    		    (%multispan-repcopy! ans 0 s from to start end)
    		    ans))))))
    
    ;; This is the core copying loop for XSUBSTRING and STRING-XCOPY!
    ;; Internal -- not exported, no careful arg checking.
    (define (%multispan-repcopy! target tstart s sfrom sto start end)
      (let* ((slen (- end start))
    	     (i0 (+ start (modulo sfrom slen)))
             (total-chars (- sto sfrom)))
        ; Copy the partial span ! the beginning
        (%string-copy! target tstart s i0 end)
        (let* ((ncopied (- end i0))               ; We've copied this many.
    	       (nleft (- total-chars ncopied))    ; # chars left to copy.
    	       (nspans (quotient nleft slen)))    ; # whole spans to copy
          ; Copy the whole spans in the middle.
          (do ((i (+ tstart ncopied) (+ i slen))  ; Current target index.
    	       (nspans nspans (- nspans 1)))      ; # spans to copy
    	      ((zero? nspans)
    	    ; Copy the partial-span ! the end & we're done.
    	    (%string-copy! target i s start (+ start (- total-chars (- i tstart)))))
    	(%string-copy! target i s start end)))))  ; Copy a whole span.
    
    ;; (string-join string-list [delimiter grammar]) => string
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Paste strings together using the delimiter string.
    ;;
    ;; (join-strings '("foo" "bar" "baz") ":") => "foo:bar:baz"
    ;;
    ;; DELIMITER defaults to a single space " "
    ;; GRAMMAR is one of the symbols {prefix, infix, strict-infix, suffix} 
    ;; and defaults to 'infix.
    ;;
    ;; I could rewrite this more efficiently -- precompute the length of the
    ;; answer string, then allocate & fill it in iteratively. Using 
    ;; STRING-CONCATENATE is less efficient.
    (define (string-join strings . delim+grammar)
      (let-optionals* delim+grammar ((delim " " (string? delim))
                                     (grammar 'infix))
        (let ((buildit (lambda (lis final)
    		     (let recur ((lis lis))
    		       (if (pair? lis)
    			   (cons delim (cons (car lis) (recur (cdr lis))))
    			   final)))))
          (cond ((pair? strings)
    	           (string-concatenate
    	             (case grammar
                       ((infix strict-infix)
            		     (cons (car strings) (buildit (cdr strings) '())))
                       ((prefix)
                         (buildit strings '()))
                       ((suffix)
                         (cons (car strings) (buildit (cdr strings) (list delim))))
                       (else
                         (error "Illegal join grammar" grammar string-join)))))
                ((not (null? strings))
    	          (error "STRINGS parameter not list." strings string-join))
                ((eq? grammar 'strict-infix)
                  (error "Empty list cannot be joined with STRICT-INFIX grammar" string-join))
    	        (else "")))))
    
    (define (string-segment str k)
      (if (< k 1) (error "minimum segment size is 1" k))
      (let ((len (string-length str)))
        (let loop ((start 0)
                   (result '()))
          (if (= start len)
            (reverse result)
            (let ((end (min (+ start k) len)))
              (loop end (cons (%substring str start end) result)))))))
    
    ;; Porting & performance-tuning notes
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; See the section at the beginning of this file on external dependencies.
    ;;
    ;; The biggest issue with respect to porting is the LET-OPTIONALS* macro.
    ;; There are many, many optional arguments in this library; the complexity
    ;; of parsing, defaulting & type-testing these parameters is handled with the
    ;; aid of this macro. There are about 15 uses of LET-OPTIONALS*. You can
    ;; rewrite the uses, port the hairy macro definition (which is implemented
    ;; using a Clinger-Rees low-level explicit-renaming macro system), or port
    ;; the simple, high-level definition, which is less efficient.
    ;;
    ;; There is a fair amount of argument checking. This is, strictly speaking,
    ;; unnecessary -- the actual body of the procedures will blow up if, say, a
    ;; START/END index is improper. However, the error message will not be as
    ;; good as if the error were caught at the "higher level." Also, a very, very
    ;; smart Scheme compiler may be able to exploit having the type checks done
    ;; early, so that the actual body of the procedures can assume proper values.
    ;; This isn't likely; this kind of compiler technology isn't common any 
    ;; longer.
    ;; 
    ;; The overhead of optional-argument parsing is irritating. The optional
    ;; arguments must be consed into a rest list on entry, and then parsed out.
    ;; Function call should be a matter of a few register moves and a jump; it
    ;; should not involve heap allocation! Your Scheme system may have a superior
    ;; non-R5RS optional-argument system that can eliminate this overhead. If so,
    ;; then this is a prime candidate for optimising these procedures,
    ;; *especially* the many optional START/END index parameters.
    ;;
    ;; Note that optional arguments are also a barrier to procedure integration.
    ;; If your Scheme system permits you to specify alternate entry points
    ;; for a call when the number of optional arguments is known in a manner
    ;; that enables inlining/integration, this can provide performance 
    ;; improvements.
    ;;
    ;; There is enough *explicit* error checking that *all* string-index
    ;; operations should *never* produce a bounds error. Period. Feel like
    ;; living dangerously? *Big* performance win to be had by replacing
    ;; STRING-REF's and STRING-SET!'s with unsafe equivalents in the loops. 
    ;; Similarly, fixnum-specific operators can speed up the arithmetic done on 
    ;; the index values in the inner loops. The only arguments that are not
    ;; completely error checked are
    ;;   - string lists (complete checking requires time proportional to the
    ;;     length of the list)
    ;;   - procedure arguments, such as char->char maps & predicates.
    ;;     There is no way to check the range & domain of procedures in Scheme.
    ;; Procedures that take these parameters cannot fully check their
    ;; arguments. But all other types to all other procedures are fully
    ;; checked.
    ;;
    ;; This does open up the alternate possibility of simply *removing* these 
    ;; checks, and letting the safe primitives raise the errors. On a dumb
    ;; Scheme system, this would provide speed (by eliminating the redundant
    ;; error checks) at the cost of error-message clarity.
    ;;
    ;; See the comments preceding the hash function code for notes on tuning
    ;; the default bound so that the code never overflows your implementation's
    ;; fixnum size into bignum calculation.
    ;;
    ;; In an interpreted Scheme, some of these procedures, or the internal
    ;; routines with % prefixes, are excellent candidates for being rewritten
    ;; in C. Consider STRING-HASH, %STRING-COMPARE, the 
    ;; %STRING-{SUF,PRE}FIX-LENGTH routines, STRING-COPY!, STRING-INDEX &
    ;; STRING-SKIP (char case), SUBSTRING and SUBSTRING,
    ;; %KMP-SEARCH, and %MULTISPAN-REPCOPY!.
    ;;
    ;; It would also be nice to have the ability to mark some of these
    ;; routines as candidates for inlining/integration.
    ;; 
    ;; All the %-prefixed routines in this source code are written
    ;; to be called internally to this library. They do *not* perform
    ;; friendly error checks on the inputs; they assume everything is
    ;; proper. They also do not take optional arguments. These two properties
    ;; save calling overhead and enable procedure integration -- but they
    ;; are not appropriate for exported routines.
    
    ;; Copyright details
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; The prefix/suffix and comparison routines in this code had (extremely
    ;; distant) origins in MIT Scheme's string lib, and was substantially
    ;; reworked by Olin Shivers (shivers@ai.mit.edu) 9/98. As such, it is
    ;; covered by MIT Scheme's open source copyright. See below for details.
    ;; 
    ;; The KMP string-search code was influenced by implementations written
    ;; by Stephen Bevan, Brian Dehneyer and Will Fitzgerald. However, this
    ;; version was written from scratch by myself.
    ;;
    ;; The remainder of this code was written from scratch by myself for scsh.
    ;; The scsh copyright is a BSD-style open source copyright. See below for
    ;; details.
    ;;     -Olin Shivers
    
    ;; MIT Scheme copyright terms
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; This material was developed by the Scheme project at the Massachusetts
    ;; Institute of Technology, Department of Electrical Engineering and
    ;; Computer Science.  Permission to copy and modify this software, to
    ;; redistribute either the original software or a modified version, and
    ;; to use this software for any purpose is granted, subject to the
    ;; following restrictions and understandings.
    ;; 
    ;; 1. Any copy made of this software must include this copyright notice
    ;; in full.
    ;; 
    ;; 2. Users of this software agree to make their best efforts (a) to
    ;; return to the MIT Scheme project any improvements or extensions that
    ;; they make, so that these may be included in future releases; and (b)
    ;; to inform MIT of noteworthy uses of this software.
    ;; 
    ;; 3. All materials developed as a consequence of the use of this
    ;; software shall duly acknowledge such use, in accordance with the usual
    ;; standards of acknowledging credit in academic research.
    ;; 
    ;; 4. MIT has made no warrantee or representation that the operation of
    ;; this software will be error-free, and MIT is under no obligation to
    ;; provide any services, by way of maintenance, update, or otherwise.
    ;; 
    ;; 5. In conjunction with products arising from the use of this material,
    ;; there shall be no use of the name of the Massachusetts Institute of
    ;; Technology nor of any adaptation thereof in any advertising,
    ;; promotional, or sales literature without prior written consent from
    ;; MIT in each case.
    
    ;; Scsh copyright terms
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; All rights reserved.
    ;; 
    ;; Redistribution and use in source and binary forms, with or without
    ;; modification, are permitted provided that the following conditions
    ;; are met:
    ;; 1. Redistributions of source code must retain the above copyright
    ;;    notice, this list of conditions and the following disclaimer.
    ;; 2. Redistributions in binary form must reproduce the above copyright
    ;;    notice, this list of conditions and the following disclaimer in the
    ;;    documentation and/or other materials provided with the distribution.
    ;; 3. The name of the authors may not be used to endorse or promote products
    ;;    derived from this software without specific prior written permission.
    ;; 
    ;; THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
    ;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    ;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    ;; IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    ;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
    ;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    ;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    ;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    ;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    ;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  )
)
;;; SRFI 154
;;; First-class dynamic extents
;;;
;;; Scheme has the notion of the dynamic extent of a procedure call. A number of standard
;;; Scheme procedures and syntaxes like dynamic-wind, call-with-current-continuation, and
;;; parameterize deal with the dynamic extent indirectly. This SRFI reifies the dynamic
;;; extent into a first-class value together with a well-defined procedural interface and
;;; a syntax to create procedures that remember not only their environment at creation
;;; time but also their dynamic extent, which includes their dynamic environment.
;;; 
;;; Copyright © 2017 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 154)
  
  (export dynamic-extent?
          current-dynamic-extent
          with-dynamic-extent
          dynamic-lambda)
  
  (import (lispkit base))
  
  (begin
    (define-record-type <dynamic-extent>
      (make-dynamic-extent proc)
      dynamic-extent?
      (proc dynamic-extent-proc))
    
    (define (current-dynamic-extent)
      (call-with-current-continuation
        (lambda (return)
          (let-values
            (((k thunk)
              (call-with-current-continuation
                (lambda (c)
                  (return
                    (make-dynamic-extent (lambda (thunk)
                                           (call-with-current-continuation
                                             (lambda (k)
                                               (c k thunk))))))))))
            (call-with-values thunk k)))))
    
    (define (with-dynamic-extent dynamic-extent thunk)
      ((dynamic-extent-proc dynamic-extent) thunk))
    
    (define-syntax dynamic-lambda
      (syntax-rules ()
        ((dynamic-lambda formals body)
          (let ((dynamic-extent (current-dynamic-extent)))
            (lambda formals
              (with-dynamic-extent dynamic-extent (lambda () body)))))))
  )
)
;;; SRFI 155
;;; Promises
;;;
;;; Scheme, like ML, is a programming language with strict evaluation while others,
;;; like Haskell, use lazy evaluation. Scheme, however, possesses the primitives delay
;;; and force that make it possible to express lazy algorithms.
;;; 
;;; Lazy evaluation does not go well in conjunction with imperative, non-functional,
;;; side-effecting code. It should, however, be applicable in a purely functional setting.
;;; This is the case for the delayed evaluation model as described in the R7RS as long as
;;; no dynamically bound variables, also known as parameter objects, are present. It is
;;; the purpose of this SRFI to rework the specification in the R7RS so that lazy
;;; evaluation works with purely functional code that makes use of dynamic environments
;;; or, more generally, the dynamic extent. This is done by remembering the dynamic extent
;;; in effect when the delay expression is evaluated.
;;; 
;;; Another perceived misfeature of the R7RS model of delayed evaluation is the apparent
;;; need of the `delay-force` special form to express iterative lazy algorithms. It is
;;; shown that the `delay-force` special form is unneeded and that the implementation can
;;; (and should) handle iterative lazy algorithms without space leaks.
;;; 
;;; Copyright © 2017 Marc Nieper-Wißkirchen. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 155)
  
  (export delay
          delay-force
          force
          make-promise
          promise?
          forcing-extent)
  
  (import (rename (lispkit base)
            (delay scheme-delay)
            (delay-force scheme-delay-force))
          (srfi 154))
  
  (begin
    
    (define current-forcing-extent (make-parameter #f))
    
    (define current-extents (make-parameter (vector #f #f)))
    
    (define (forcing-extent)
      (unless (current-forcing-extent)
        (error "forcing-extent: there is no promise being forced"))
      (current-forcing-extent))
    
    (define-syntax delay
      (syntax-rules (force)
        ((delay (force expression))
          (delay-force expression))
        ((delay expression)
          (let ((dynamic-extent
                  (if (and (vector-ref (current-extents) 1)
                           (eq? (current-dynamic-extent) (vector-ref (current-extents) 1)))
                      (vector-ref (current-extents) 0)
                      (current-dynamic-extent))))
            (scheme-delay
              (let ((forcing-extent (current-dynamic-extent)))
                (with-dynamic-extent dynamic-extent
                                     (lambda ()
                                       (let ((extents (vector dynamic-extent #f)))
                                         (parameterize ((current-extents extents)
                                                        (current-forcing-extent forcing-extent))
                                           (vector-set! extents 1 (current-dynamic-extent))
                                           expression))))))))))
    
    (define-syntax delay-force
      (syntax-rules ()
        ((delay-force expression)
          (let ((dynamic-extent (current-dynamic-extent)))
            (scheme-delay-force
              (with-dynamic-extent dynamic-extent (lambda () expression)))))))
  )
)
;;; SRFI 158
;;; Generators and Accumulators
;;; 
;;; This SRFI defines utility procedures that create, transform, and consume generators.
;;; A generator is simply a procedure with no arguments that works as a source of values.
;;; Every time it is called, it yields a value. Generators may be finite or infinite;
;;; a finite generator returns an end-of-file object to indicate that it is exhausted.
;;; For example, read-char, read-line, and read are generators that generate characters,
;;; lines, and objects from the current input port. Generators provide lightweight laziness.
;;; This SRFI also defines procedures that return accumulators. An accumulator is the
;;; inverse of a generator: it is a procedure of one argument that works as a sink of values.
;;;
;;; Copyright © 2015 Shiro Kawai, John Cowan, Thomas Gilray (2015). All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify,
;;; merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
;;; permit persons to whom the Software is furnished to do so, subject to the following
;;; conditions:
;;; The above copyright notice and this permission notice shall be included in all copies
;;; or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 158)

  (export generator
          circular-generator
          make-iota-generator
          make-range-generator
          make-coroutine-generator
          list->generator
          vector->generator
          reverse-vector->generator
          string->generator
          bytevector->generator
          make-for-each-generator
          make-unfold-generator)

  (export gcons*
          gappend
          gcombine
          gfilter
          gremove
          gtake
          gdrop
          gtake-while
          gdrop-while
          gflatten
          ggroup
          gmerge
          gmap
          gstate-filter
          gdelete
          gdelete-neighbor-dups
          gindex
          gselect)

  (export generator->list
          generator->reverse-list
          generator->vector
          generator->vector!
          generator->string
          generator-fold
          generator-map->list
          generator-for-each
          generator-find
          generator-count
          generator-any
          generator-every
          generator-unfold)

  (export make-accumulator
          count-accumulator
          list-accumulator
          reverse-list-accumulator
          vector-accumulator
          reverse-vector-accumulator
          vector-accumulator!
          string-accumulator
          bytevector-accumulator
          bytevector-accumulator!
          sum-accumulator
          product-accumulator)
  
  (import (lispkit base))
 
  (begin
 
    ;; list->bytevector
    (define (list->bytevector list)
      (let ((vec (make-bytevector (length list) 0)))
        (let loop ((i 0) (list list))
          (if (null? list)
            vec
            (begin
              (bytevector-u8-set! vec i (car list))
              (loop (+ i 1) (cdr list)))))))
 
 
    ;; generator
    (define (generator . args)
      (lambda () (if (null? args)
                   (eof-object)
                   (let ((next (car args)))
                    (set! args (cdr args))
                    next))))
 
    ;; circular-generator
    (define (circular-generator . args)
      (let ((base-args args))
        (lambda ()
          (when (null? args)
            (set! args base-args))
              (let ((next (car args)))
                    (set! args (cdr args))
                    next))))
 
 
    ;; make-iota-generator
    (define make-iota-generator
      (case-lambda ((count) (make-iota-generator count 0 1))
                   ((count start) (make-iota-generator count start 1))
                   ((count start step) (make-iota count start step))))
 
    ;; make-iota
    (define (make-iota count start step)
      (lambda ()
        (cond
          ((<= count 0)
           (eof-object))
          (else
            (let ((result start))
             (set! count (- count 1))
             (set! start (+ start step))
             result)))))
 
 
    ;; make-range-generator
    (define make-range-generator
      (case-lambda ((start end) (make-range-generator start end 1))
                   ((start) (make-infinite-range-generator start))
                   ((start end step)
                    (set! start (- (+ start step) step))
                    (lambda () (if (< start end)
                                 (let ((v start))
                                  (set! start (+ start step))
                                  v)
                                 (eof-object))))))
 
    (define (make-infinite-range-generator start)
      (lambda ()
        (let ((result start))
         (set! start (+ start 1))
         result)))
 
 
 
    ;; make-coroutine-generator
    (define (make-coroutine-generator proc)
      (define return #f)
      (define resume #f)
      (define yield (lambda (v) (call/cc (lambda (r) (set! resume r) (return v)))))
      (lambda () (call/cc (lambda (cc) (set! return cc)
                            (if resume
                              (resume (if #f #f))  ; void? or yield again?
                              (begin (proc yield)
                                     (set! resume (lambda (v) (return (eof-object))))
                                     (return (eof-object))))))))
 
 
    ;; list->generator
    (define (list->generator lst)
      (lambda () (if (null? lst)
                   (eof-object)
                   (let ((next (car lst)))
                    (set! lst (cdr lst))
                    next))))
 
 
    ;; vector->generator
    (define vector->generator
      (case-lambda ((vec) (vector->generator vec 0 (vector-length vec)))
                   ((vec start) (vector->generator vec start (vector-length vec)))
                   ((vec start end)
                    (lambda () (if (>= start end)
                                 (eof-object)
                                 (let ((next (vector-ref vec start)))
                                  (set! start (+ start 1))
                                  next))))))
 
 
    ;; reverse-vector->generator
    (define reverse-vector->generator
      (case-lambda ((vec) (reverse-vector->generator vec 0 (vector-length vec)))
                   ((vec start) (reverse-vector->generator vec start (vector-length vec)))
                   ((vec start end)
                    (lambda () (if (>= start end)
                                 (eof-object)
                                 (let ((next (vector-ref vec (- end 1))))
                                  (set! end (- end 1))
                                  next))))))
 
 
    ;; string->generator
    (define string->generator
      (case-lambda ((str) (string->generator str 0 (string-length str)))
                   ((str start) (string->generator str start (string-length str)))
                   ((str start end)
                    (lambda () (if (>= start end)
                                 (eof-object)
                                 (let ((next (string-ref str start)))
                                  (set! start (+ start 1))
                                  next))))))
 
 
    ;; bytevector->generator
    (define bytevector->generator
      (case-lambda ((str) (bytevector->generator str 0 (bytevector-length str)))
                   ((str start) (bytevector->generator str start (bytevector-length str)))
                   ((str start end)
                    (lambda () (if (>= start end)
                                 (eof-object)
                                 (let ((next (bytevector-u8-ref str start)))
                                  (set! start (+ start 1))
                                  next))))))
 
 
    ;; make-for-each-generator
    ;FIXME: seems to fail test
    (define (make-for-each-generator for-each obj)
      (make-coroutine-generator (lambda (yield) (for-each yield obj))))
 
 
    ;; make-unfold-generator
    (define (make-unfold-generator stop? mapper successor seed)
      (make-coroutine-generator (lambda (yield)
                                  (let loop ((s seed))
                                   (if (stop? s)
                                     (if #f #f)
                                     (begin (yield (mapper s))
                                            (loop (successor s))))))))
 
 
    ;; gcons*
    (define (gcons* . args)
      (lambda () (if (null? args)
                   (eof-object)
                   (if (= (length args) 1)
                     ((car args))
                     (let ((v (car args)))
                      (set! args (cdr args))
                      v)))))
 
 
    ;; gappend
    (define (gappend . args)
      (lambda () (if (null? args)
                   (eof-object)
                   (let loop ((v ((car args))))
                    (if (eof-object? v)
                      (begin (set! args (cdr args))
                             (if (null? args)
                               (eof-object)
                               (loop ((car args)))))
                      v)))))
 
    ;; gflatten
    (define (gflatten gen)
      (let ((state '()))
        (lambda ()
          (if (null? state) (set! state (gen)))
          (if (eof-object? state)
            state
            (let ((obj (car state)))
              (set! state (cdr state))
              obj)))))
 
    ;; ggroup
    (define ggroup
      (case-lambda
        ((gen k)
         (simple-ggroup gen k))
        ((gen k padding)
         (padded-ggroup (simple-ggroup gen k) k padding))))
 
    (define (simple-ggroup gen k)
      (lambda ()
        (let loop ((item (gen)) (result '()) (count (- k 1)))
          (if (eof-object? item)
            (if (null? result) item (reverse result))
            (if (= count 0)
              (reverse (cons item result))
              (loop (gen) (cons item result) (- count 1)))))))
 
    (define (padded-ggroup gen k padding)
      (lambda ()
        (let ((item (gen)))
          (if (eof-object? item)
            item
            (let ((len (length item)))
              (if (= len k)
                  item
                  (append item (make-list (- k len) padding))))))))
 
    ;; gmerge
    (define gmerge
      (case-lambda
        ((<) (error "wrong number of arguments for gmerge"))
        ((< gen) gen)
        ((< genleft genright)
         (let ((left (genleft))
               (right (genright)))
           (lambda ()
             (cond
              ((and (eof-object? left) (eof-object? right))
               left)
              ((eof-object? left)
               (let ((obj right)) (set! right (genright)) obj))
              ((eof-object? right)
               (let ((obj left))  (set! left (genleft)) obj))
              ((< right left)
               (let ((obj right)) (set! right (genright)) obj))
              (else
               (let ((obj left)) (set! left (genleft)) obj))))))
        ((< . gens)
         (apply gmerge <
                (let loop ((gens gens) (gs '()))
                  (cond ((null? gens) (reverse gs))
                        ((null? (cdr gens)) (reverse (cons (car gens) gs)))
                        (else (loop (cddr gens)
                                    (cons (gmerge < (car gens) (cadr gens)) gs)))))))))
 
    ;; gmap
    (define gmap
      (case-lambda
        ((proc) (error "wrong number of arguments for gmap"))
        ((proc gen)
         (lambda ()
           (let ((item (gen)))
             (if (eof-object? item) item (proc item)))))
        ((proc . gens)
         (lambda ()
           (let ((items (map (lambda (x) (x)) gens)))
             (if (any? eof-object? items) (eof-object) (apply proc items)))))))
 
    ;; gcombine
    (define (gcombine proc seed . gens)
      (lambda ()
        (define items (map (lambda (x) (x)) gens))
        (if (any? eof-object? items)
          (eof-object)
          (let-values (((value newseed) (apply proc (append items (list seed)))))
            (set! seed newseed)
            value))))
 
    ;; gfilter
    (define (gfilter pred gen)
      (lambda () (let loop ()
                  (let ((next (gen)))
                   (if (or (eof-object? next)
                           (pred next))
                     next
                     (loop))))))
 
    ;; gstate-filter
    (define (gstate-filter proc seed gen)
      (let ((state seed))
        (lambda ()
          (let loop ((item (gen)))
            (if (eof-object? item)
              item
              (let-values (((yes newstate) (proc item state)))
                (set! state newstate)
                (if yes
                   item
                   (loop (gen)))))))))
 
 
 
    ;; gremove
    (define (gremove pred gen)
      (gfilter (lambda (v) (not (pred v))) gen))
 
 
 
    ;; gtake
    (define gtake
      (case-lambda ((gen k) (gtake gen k (eof-object)))
                   ((gen k padding)
                    (make-coroutine-generator (lambda (yield)
                                                (if (> k 0)
                                                  (let loop ((i 0) (v (gen)))
                                                   (begin (if (eof-object? v) (yield padding) (yield v))
                                                          (if (< (+ 1 i) k)
                                                            (loop (+ 1 i) (gen))
                                                            (eof-object))))
                                                  (eof-object)))))))
 
 
 
    ;; gdrop
    (define (gdrop gen k)
      (lambda () (do () ((<= k 0)) (set! k (- k 1)) (gen))
        (gen)))
 
 
 
    ;; gdrop-while
    (define (gdrop-while pred gen)
      (define found #f)
      (lambda ()
        (let loop ()
         (let ((val (gen)))
          (cond (found val)
                ((and (not (eof-object? val)) (pred val)) (loop))
                (else (set! found #t) val))))))
 
 
    ;; gtake-while
    (define (gtake-while pred gen)
      (lambda () (let ((next (gen)))
                  (if (eof-object? next)
                    next
                    (if (pred next)
                      next
                      (begin (set! gen (generator))
                             (gen)))))))
 
 
 
    ;; gdelete
    (define gdelete
      (case-lambda ((item gen) (gdelete item gen equal?))
                   ((item gen ==)
                    (lambda () (let loop ((v (gen)))
                                (cond
                                  ((eof-object? v) (eof-object))
                                  ((== item v) (loop (gen)))
                                  (else v)))))))
 
 
 
    ;; gdelete-neighbor-dups
    (define gdelete-neighbor-dups
      (case-lambda
        ((gen)
           (gdelete-neighbor-dups gen equal?))
        ((gen ==)
           (let ((firsttime #t)
                 (prev #f))
             (lambda ()
               (if firsttime
                   (begin (set! firsttime #f)
                          (set! prev (gen))
                          prev)
                   (let loop ((v (gen)))
                     (cond
                       ((eof-object? v) v)
                       ((== prev v)     (loop (gen)))
                       (else            (set! prev v) v)))))))))
 
    ;; gindex
    (define (gindex value-gen index-gen)
      (let ((done? #f) (count 0))
       (lambda ()
         (if done?
           (eof-object)
           (let loop ((value (value-gen)) (index (index-gen)))
            (cond
              ((or (eof-object? value) (eof-object? index))
               (set! done? #t)
               (eof-object))
              ((= index count)
               (set! count (+ count 1))
               value)
              (else
                (set! count (+ count 1))
                (loop (value-gen) index))))))))
 
 
    ;; gselect
    (define (gselect value-gen truth-gen)
      (let ((done? #f))
       (lambda ()
         (if done?
           (eof-object)
           (let loop ((value (value-gen)) (truth (truth-gen)))
            (cond
              ((or (eof-object? value) (eof-object? truth))
               (set! done? #t)
               (eof-object))
              (truth value)
              (else (loop (value-gen) (truth-gen)))))))))
 
    ;; generator->list
    (define generator->list
      (case-lambda ((gen n)
        (generator->list (gtake gen n)))
                   ((gen)
        (reverse (generator->reverse-list gen)))))
 
    ;; generator->reverse-list
    (define generator->reverse-list
      (case-lambda ((gen n)
        (generator->reverse-list (gtake gen n)))
                   ((gen)
        (generator-fold cons '() gen))))
 
    ;; generator->vector
    (define generator->vector
      (case-lambda ((gen) (list->vector (generator->list gen)))
                   ((gen n) (list->vector (generator->list gen n)))))
 
 
    ;; generator->vector!
    (define (generator->vector! vector at gen)
      (let loop ((value (gen)) (count 0) (at at))
       (cond
         ((eof-object? value) count)
         ((>= at (vector-length vector)) count)
         (else (begin
                 (vector-set! vector at value)
                 (loop (gen) (+ count 1) (+ at 1)))))))
 
 
    ;; generator->string
    (define generator->string
      (case-lambda ((gen) (list->string (generator->list gen)))
                   ((gen n) (list->string (generator->list gen n)))))
 
 
 
 
    ;; generator-fold
    (define (generator-fold f seed . gs)
      (define (inner-fold seed)
        (let ((vs (map (lambda (g) (g)) gs)))
         (if (any? eof-object? vs)
           seed
           (inner-fold (apply f (append vs (list seed)))))))
      (inner-fold seed))
 
 
 
    ;; generator-for-each
    (define (generator-for-each f . gs)
      (let loop ()
       (let ((vs (map (lambda (g) (g)) gs)))
        (if (any? eof-object? vs)
          (if #f #f)
          (begin (apply f vs)
                 (loop))))))
 
 
    (define (generator-map->list f . gs)
      (let loop ((result '()))
       (let ((vs (map (lambda (g) (g)) gs)))
        (if (any? eof-object? vs)
          (reverse result)
          (loop (cons (apply f vs) result))))))
 
 
    ;; generator-find
    (define (generator-find pred g)
      (let loop ((v (g)))
       ; A literal interpretation might say it only terminates on #eof if (pred #eof) but I think this makes more sense...
       (if (or (pred v) (eof-object? v))
         v
         (loop (g)))))
 
 
    ;; generator-count
    (define (generator-count pred g)
      (generator-fold (lambda (v n) (if (pred v) (+ 1 n) n)) 0 g))
 
 
    ;; generator-any
    (define (generator-any pred g)
      (let loop ((v (g)))
       (if (eof-object? v)
         #f
         (if (pred v)
           #t
           (loop (g))))))
 
 
    ;; generator-every
    (define (generator-every pred g)
      (let loop ((v (g)))
       (if (eof-object? v)
         #t
         (if (pred v)
           (loop (g))
           #f ; the spec would have me return #f, but I think it must simply be wrong...
           ))))
 
 
    ;; generator-unfold
    (define (generator-unfold g unfold . args)
      (apply unfold eof-object? (lambda (x) x) (lambda (x) (g)) (g) args))
 
 
    ;; make-accumulator
    (define (make-accumulator kons knil finalize)
      (let ((state knil))
        (lambda (obj)
          (if (eof-object? obj)
            (finalize state)
            (set! state (kons obj state))))))
 
 
    ;; count-accumulator
    (define (count-accumulator) (make-accumulator
                                (lambda (obj state) (+ 1 state)) 0 (lambda (x) x)))
 
    ;; list-accumulator
    (define (list-accumulator) (make-accumulator cons '() reverse))
 
    ;; reverse-list-accumulator
    (define (reverse-list-accumulator) (make-accumulator cons '() (lambda (x) x)))
 
    ;; vector-accumulator
    (define (vector-accumulator)
      (make-accumulator cons '() (lambda (x) (list->vector (reverse x)))))
 
    ;; reverse-vector-accumulator
    (define (reverse-vector-accumulator)
      (make-accumulator cons '() list->vector))
 
    ;; vector-accumulator!
    (define (vector-accumulator! vec at)
      (lambda (obj)
        (if (eof-object? obj)
          vec
          (begin
            (vector-set! vec at obj)
            (set! at (+ at 1))))))
 
    ;; bytevector-accumulator
    (define (bytevector-accumulator)
      (make-accumulator cons '() (lambda (x) (list->bytevector (reverse x)))))
 
    (define (bytevector-accumulator! bytevec at)
      (lambda (obj)
        (if (eof-object? obj)
          bytevec
          (begin
            (bytevector-u8-set! bytevec at obj)
            (set! at (+ at 1))))))
 
    ;; string-accumulator
    (define (string-accumulator)
      (make-accumulator cons '()
            (lambda (lst) (list->string (reverse lst)))))
 
    ;; sum-accumulator
    (define (sum-accumulator) (make-accumulator + 0 (lambda (x) x)))
 
    ;; product-accumulator
    (define (product-accumulator) (make-accumulator * 1 (lambda (x) x)))
  )
)
;;; SRFI 16
;;; Syntax for procedures of variable arity
;;;
;;; The SRFI introduces `case-lambda`, a syntax for procedures with a variable number
;;; of arguments. `case-lambda` reduces the clutter of procedures that execute different
;;; code depending on the number of arguments they were passed. It is a pattern-matching
;;; mechanism that matches on the number of arguments. CASE-LAMBDA is available in some
;;; Scheme systems.
;;;
;;; Author of spec: Lars T Hansen
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 16)

  (export case-lambda)

  (import (lispkit core))

  ;; `case-lambda` is implemented natively in library `(lispkit core)`
)

;;; SRFI 161
;;; Unifiable Boxes
;;;
;;; Unifiable boxes are, like the boxes of SRFI 111, objects with a single mutable state.
;;; A constructor, predicate, accessor, and mutator are provided.
;;; In addition to the state, an equality predicate and union operations (link, union, unify)
;;; are provided. Applying a union operation to two unifiable boxes makes the two boxes equal
;;; (in the sense of the equality predicate). As a consequence, their state will also become
;;; identical. In the case of link and union, it will be the state of one of the two unioned
;;; boxes. In the case of unify, the state is determined by a supplied unification procedure.
;;;
;;; Copyright © 2018 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 161)

  (export ubox
          ubox?
          ubox-ref
          ubox-set!
          ubox=?
          ubox-unify!
          ubox-union!
          ubox-link!)

  (import (lispkit base))

  (begin
    (define-record-type <ubox>
      (make-ubox parent rank value)
      ubox?
      (parent ubox-parent ubox-set-parent!)
      (rank ubox-rank ubox-set-rank!)
      (value ubox-value ubox-set-value!))

    (define (ubox-find ubox)
      (let ((parent (ubox-parent ubox)))
        (if parent
            (let ((root (ubox-find parent)))
              (ubox-set-parent! ubox root)
              root)
            ubox)))

    (define (ubox value)
      (make-ubox #f 0 value))

    (define (ubox-ref ubox)
      (ubox-value (ubox-find ubox)))

    (define (ubox-set! ubox val)
      (ubox-set-value! (ubox-find ubox) val))

    (define (ubox=? ubox1 ubox2)
      (eq? (ubox-find ubox1) (ubox-find ubox2)))

    (define (ubox-unify! proc ubox1 ubox2)
      (let ((value (proc (ubox-ref ubox1) (ubox-ref ubox2))))
        (ubox-union! ubox1 ubox2)
        (ubox-set! ubox1 value)))

    (define (ubox-union! ubox1 ubox2)
      (let ((root1 (ubox-find ubox1))
            (root2 (ubox-find ubox2)))
        (unless (eq? root1 root2)
          (cond ((< (ubox-rank root1) (ubox-rank root2))
                  (ubox-set-parent! root1 root2)
                  (ubox-set-value! root1 #f)
                  (ubox-set-rank! root1 #f))
                (else
                  (when (= (ubox-rank root1) (ubox-rank root2))
                    (ubox-set-rank! root1 (+ (ubox-rank root1) 1)))
                  (ubox-set-parent! root2 root1)
                  (ubox-set-value! root2 #f)
                  (ubox-set-rank! root2 #f))))))

    (define (ubox-link! ubox1 ubox2)
      (ubox-unify! (lambda (x y) y) ubox1 ubox2))
  )
)

;;; SRFI 162
;;; Comparators
;;;
;;; This SRFI extends SRFI 128. It provides comparators, which bundle a type test predicate,
;;; an equality predicate, an ordering predicate, and a hash function (the last two are optional)
;;; into a single Scheme object. By packaging these procedures together, they can be treated as
;;; a single item for use in the implementation of data structures.
;;;
;;; Copyright © 2018 John Cowan. All Rights Reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 162)

  ;; SRFI 128 exports
  (export comparator?
          comparator-ordered?
          comparator-hashable?
          make-comparator
          make-pair-comparator
          make-list-comparator
          make-vector-comparator
          make-eq-comparator
          make-eqv-comparator
          make-equal-comparator
          boolean-hash
          char-hash
          char-ci-hash
          string-hash
          string-ci-hash
          symbol-hash
          number-hash
          make-default-comparator
          default-hash
          comparator-register-default!
          comparator-type-test-predicate
          comparator-equality-predicate
          comparator-ordering-predicate
          comparator-hash-function
          comparator-test-type
          comparator-check-type
          comparator-hash
          hash-bound
          hash-salt
          =?
          <?
          >?
          <=?
          >=?
          comparator-if<=>)

  ;; SRFI 162 exports
  (export comparator-max
          comparator-min
          comparator-max-in-list
          comparator-min-in-list
          default-comparator
          boolean-comparator
          real-comparator
          char-comparator
          char-ci-comparator
          string-comparator
          string-ci-comparator
          list-comparator
          vector-comparator
          eq-comparator
          eqv-comparator
          equal-comparator)

  (import (srfi 128))
)

;;; SRFI 165
;;; The Environment Monad
;;;
;;; Monads model computations. The environment monad models computations that depend on
;;; values from a shared environment. These computations can read values from the
;;; environment, pass values to subsequent computations, execute sub-computations in
;;; an extended environment, and modify the environment for future computations.
;;;
;;; The environment monad is useful whenever code has to be suspended and executed at
;;; a later time (even several times), and whenever code depends (implicitly) on bindings
;;; of variables in a shared environment.
;;;
;;; Copyright © 2019 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2019 Matthias Zenger. All rights reserved.

(define-library (srfi 165)

  (export make-computation-environment-variable
          make-computation-environment
          computation-environment-ref
          computation-environment-update
          computation-environment-update!
          computation-environment-copy
          make-computation
          computation-each
          computation-each-in-list
          computation-pure
          computation-bind
          computation-sequence
          computation-run
          computation-ask
          computation-local
          computation-fn
          computation-with
          computation-with!
          computation-forked
          computation-bind/forked
          default-computation
          define-computation-type)

  (import (lispkit base)
          (srfi 1)
          (srfi 111)
          (except (srfi 125) string-hash string-ci-hash symbol-hash equal-hash eq-hash)
          (srfi 128)
          (srfi 146))

  (begin

    (define-record-type <computation-environment-variable>
      (make-environment-variable name default immutable? id)
      environment-variable?
      (name environment-variable-name)
      (default environment-variable-default)
      (immutable? environment-variable-immutable?)
      (id environment-variable-id))

    (define make-computation-environment-variable
      (let ((count 0))
        (lambda (name default immutable?)
          (set! count (+ count 1))
          (make-environment-variable name default immutable? (- count)))))

    (define (predefined? var)
      (not (negative? (environment-variable-id var))))

    (define variable-comparator
      (make-comparator environment-variable?
                       eq?
                       (lambda (x y) (< (environment-variable-id x) (environment-variable-id y)))
                       (lambda (x . y) (environment-variable-id x))))

    (define default-computation
      (make-computation-environment-variable 'default-computation #f #f))

    (define (environment-global env)
      (vector-ref env 0))

    (define (environment-local env)
      (vector-ref env 1))

    (define (environment-set-global! env global)
      (vector-set! env 0 global))

    (define (environment-set-local! env local)
      (vector-set! env 1 local))

    (define (environment-cell-set! env var box)
      (vector-set! env (+ 2 (environment-variable-id var)) box))

    (define (environment-cell env var)
      (vector-ref env (+ 2 (environment-variable-id var))))

    (define-syntax define-computation-type
      (syntax-rules ()
        ((define-computation-type make-environment run var ...)
          (%define-computation-type make-environment run (var ...) 0 ()))))

    (define-syntax %define-computation-type
      (syntax-rules ()
        ((_ make-environment run () n ((var default e immutable i) ...))
          (begin
            (define-values (e ...) (values default ...))
            (define var (make-environment-variable 'var e immutable i))
            ...
            (define (make-environment)
              (let ((env (make-vector (+ n 2))))
                (environment-set-global! env (hash-table variable-comparator))
                (environment-set-local! env (mapping variable-comparator))
                (vector-set! env (+ i 2) (box e))
                ...
                env))
            (define (run computation) (execute computation (make-environment)))))
        ((_ make-environment run ((v d) . v*) n (p ...))
          (%define-computation-type make-environment run v* (+ n 1) (p ... (v d e #f n))))
        ((_ make-environment run ((v d "immutable") . v*) n (p ...))
          (%define-computation-type make-environment run v* (+ n 1) (p ... (v d e #t n))))
        ((_ make-environment run (v . v*) n (p ...))
          (%define-computation-type make-environment run v* (+ n 1) (p ... (v #f e #f n))))))

    (define-computation-type make-computation-environment computation-run)

    (define (computation-environment-ref env var)
      (if (predefined? var)
          (unbox (environment-cell env var))
          (mapping-ref (environment-local env)
                       var
                       (lambda () (hash-table-ref/default (environment-global env) var
                                     (environment-variable-default var)))
                       unbox)))

    (define (computation-environment-update env . arg*)
      (let ((new-env (vector-copy env)))
        (let loop ((arg* arg*)
               (local (environment-local env)))
          (if (null? arg*)
              (begin
                (environment-set-local! new-env local)
                new-env)
              (let ((var (car arg*))
                    (val (cadr arg*)))
                (if (predefined? var)
                    (begin
                      (environment-cell-set! new-env var (box val))
                      (loop (cddr arg*) local))
                    (loop (cddr arg*) (mapping-set local var (box val)))))))))

    (define (computation-environment-update! env var val)
      (if (predefined? var)
          (set-box! (environment-cell env var) val)
          (mapping-ref (environment-local env)
                       var
                       (lambda () (hash-table-set! (environment-global env) var val))
                       (lambda (cell) (set-box! cell val)))))

    (define (computation-environment-copy env)
      (let ((global (hash-table-copy (environment-global env) #t)))
        (mapping-for-each (lambda (var cell)
                (hash-table-set! global var (unbox cell)))
                  (environment-local env))
        (let ((new-env (make-vector (vector-length env))))
          (environment-set-global! new-env global)
          (environment-set-local! new-env (mapping variable-comparator))
          (do ((i (- (vector-length env) 1) (- i 1)))
              ((< i 2) new-env)
            (vector-set! new-env i (box (unbox (vector-ref env i))))))))

    (define (execute computation env)
      (let ((coerce (if (procedure? computation)
                        values
                        (or (computation-environment-ref env default-computation)
                            (error "not a computation" computation)))))
        ((coerce computation) env)))

    (define (make-computation proc)
      (lambda (env) (proc (lambda (c) (execute c env)))))

    (define (computation-pure . args)
      (make-computation (lambda (compute) (apply values args))))

    (define (computation-each a . a*)
      (computation-each-in-list (cons a a*)))

    (define (computation-each-in-list a*)
      (make-computation
        (lambda (compute)
          (let loop ((a (car a*)) (a* (cdr a*)))
            (if (null? a*)
                (compute a)
                (begin (compute a)
                       (loop (car a*) (cdr a*))))))))

    (define (computation-bind a . f*)
      (make-computation
       (lambda (compute)
         (let loop ((a a) (f* f*))
           (if (null? f*)
               (compute a)
               (loop (call-with-values (lambda () (compute a)) (car f*)) (cdr f*)))))))

    (define (computation-ask)
      (lambda (env) env))

    (define (computation-local updater computation)
      (lambda (env) (computation (updater env))))

    (define-syntax computation-fn
      (syntax-rules ()
        ((_ (clause ...) expr ... computation)
          (%fn (clause ...) () expr ... computation))))

    (define-syntax %fn
      (syntax-rules ()
        ((_ () ((id var tmp) ...) expr ... computation)
          (let ((tmp var) ...)
            (computation-bind (computation-ask)
              (lambda (env)
                (let ((id (computation-environment-ref env tmp)) ...)
                  expr ...
                  computation)))))
        ((_ ((id var) . rest) (p ...) expr ... computation)
          (%fn rest (p ... (id var tmp)) expr ... computation))
        ((_ (id . rest) (p ...) expr ... computation)
          (%fn rest (p ... (id id tmp)) expr ... computation))))

    (define-syntax computation-with
      (syntax-rules ()
        ((_ ((var val) ...) a* ... a)
          (%with ((var val) ...) () () a* ... a))))

    (define-syntax %with
      (syntax-rules ()
        ((_ () ((x u) ...) ((a b) ...))
          (let ((u x) ... (b a) ...)
            (computation-local
            (lambda (env) (computation-environment-update env u ...))
            (computation-each b ...))))
        ((_ ((var val) . rest) (p ...) () a* ...)
          (%with rest (p ... (var u) (val v)) () a* ...))
        ((_ () p* (q ...) a . a*)
          (%with () p* (q ... (a b)) . a*))))

    (define-syntax computation-with!
      (syntax-rules ()
        ((_ (var val) ...)
          (%with! (var val) ... ()))))

    (define-syntax %with!
      (syntax-rules ()
        ((_ ((var u val v) ...))
          (let ((u var) ... (v val) ...)
            (computation-bind (computation-ask)
          (lambda (env)
            (computation-environment-update! env u v) ...
            (computation-pure (if #f #f))))))
        ((_ (var val) r ... (p ...))
          (%with! r ... (p ... (var u val v))))))

    (define (computation-forked a . a*)
      (make-computation
       (lambda (compute)
         (let loop ((a a) (a* a*))
           (if (null? a*)
               (compute a)
               (begin
                 (compute (computation-local (lambda (env) (computation-environment-copy env)) a))
                 (loop (car a*) (cdr a*))))))))

    (define (computation-bind/forked computation . proc*)
      (apply computation-bind
             (computation-local computation-environment-copy computation)
             proc*))

    (define (computation-sequence fmt*)
      (fold-right (lambda (fmt res)
                    (computation-bind res
                      (lambda (vals)
                        (computation-bind fmt
                          (lambda (val) (computation-pure (cons val vals)))))))
                  (computation-pure '()) fmt*))
  )
)

;;; SRFI 166
;;; Monadic Formatting
;;;
;;; A library of procedures for formatting Scheme objects to text in various ways, and
;;; for easily concatenating, composing and extending these formatters efficiently
;;; without resorting to capturing and manipulating intermediate strings. This SRFI is
;;; an updated version of SRFI 159, primarily with the difference that state variables
;;; are hygienic.
;;; 
;;; This implementation is lacking support for pretty printing. There are also issues
;;; related to writing shared/recursive structures.
;;; 
;;; Copyright © 2020 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 166)
  
  (export show
          displayed
          written
          written-shared
          written-simply
          escaped
          maybe-escaped
          numeric
          numeric/comma
          numeric/si
          numeric/fitted
          nl
          fl
          space-to
          tab-to
          nothing
          each
          each-in-list
          joined
          joined/prefix
          joined/suffix
          joined/last
          joined/dot
          joined/range
          padded
          padded/right
          padded/both
          trimmed
          trimmed/right
          trimmed/both
          trimmed/lazy
          fitted
          fitted/right
          fitted/both
          output-default
          fn
          with
          with!
          forked
          call-with-output
          port
          row
          col
          width
          output
          writer
          string-width
          pad-char
          ellipsis
          radix
          precision
          decimal-sep
          decimal-align
          sign-rule
          comma-sep
          comma-rule
          word-separator?
          ambiguous-is-wide?
          pretty
          pretty-shared
          pretty-simply
          pretty-color
          columnar tabular wrapped wrapped/list wrapped/char
          justified from-file line-numbers
          ;; show-columns
          as-unicode unicode-terminal-width unicode-terminal-width/wide
          upcased downcased
          as-red as-blue as-green as-cyan as-yellow
          as-magenta as-white as-black
          as-bold as-underline
          as-color as-true-color)
  
  (import (srfi 166 base)
          (srfi 166 color)
          (srfi 166 columnar)
          (srfi 166 unicode)
          (srfi 166 pretty))
)
;;; SRFI 17
;;; Generalized set!
;;;
;;; This is a proposal to allow procedure calls that evaluate to the "value of a location"
;;; to be used to set the value of the location, when used as the first operand of set!.
;;; For example: (set! (vector-ref x 0) 17)
;;; becomes equivalent to: (vector-set! x 0 17)
;;;
;;; Many programming languages have the concept of an lvalue. that is an "expression" that
;;; "evaluates" to a location, and which can appear on the left-hand-side of an assignment.
;;; Common Lisp has a related concept of "generalized variables" which can be used in `setf`
;;; and some other special forms. However, the Common Lisp concept is based on the idea of
;;; compile-time recognition of special "location-producing" functions; this does not seem
;;; to be in the "spirit of Scheme".
;;;
;;; This SRFI implements an extension of set! so that it provides similar functionality as
;;; Common Lisp's `setf`, except that the updater is associated with a procedure value,
;;; rather than a name.
;;;
;;; Author of spec: Per Bothner
;;;
;;; Copyright © 2017 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 17)
  (export set!
          setter
          getter-with-setter)
  (import (rename (lispkit base) (set! %set!)))

  (begin
    (define-syntax set!
      (syntax-rules ()
        ((_ (getter arg ...) val) ((setter getter) arg ... val))
        ((_ var val)              (%set! var val))))
    
    (define setter
      (let ((setters (list (cons vector-ref vector-set!)
                           (cons string-ref string-set!)
                           (cons bytevector-u8-ref bytevector-u8-set!)
                           (cons hashtable-ref hashtable-set!)
                           (cons unbox set-box!)
                           (cons mcar set-mcar!)
                           (cons mcdr set-mcdr!))))
        (letrec ((setter      (lambda (proc)
                                (let ((probe (assv proc setters)))
                                  (if probe
                                      (cdr probe)
                                      (error "missing setter for $0" proc)))))
                 (set-setter! (lambda (proc setter)
                                (set! setters (cons (cons proc setter) setters))
                                (void))))
          (set-setter! setter set-setter!)
          setter)))

    (define (getter-with-setter get set)
      (let ((proc (lambda args (apply get args))))
        (set! (setter proc) set)
        proc))
  )
)
;;; SRFI 173
;;; Hooks
;;;
;;; This library describes a mechanism known as hooks. Hooks are a certain kind of
;;; extension point in a program that allows interleaving the execution of arbitrary
;;; code with the execution of the program without introducing any coupling between
;;; the two.
;;;
;;; Author of spec: Amirouche Boubekki
;;;
;;; Copyright © 2019 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 173)

  (export make-hook
          hook?
          hook-type-tag
          hook-add!
          hook-delete!
          hook-reset!
          hook->list
          hook-run)

  (import (lispkit base))

  (begin

    (define-values (hook-type-tag new-hook hook? hook-ref make-hook-subtype) (make-type 'hook))

    (define (make-hook arity)
      (new-hook (cons arity (box '()))))

    (define (hook-add! hook proc)
      (let ((procs (cdr (hook-ref hook))))
        (set-box! procs (cons proc (unbox procs)))))

    (define (hook-delete! hook proc)
      (let ((procs (cdr (hook-ref hook))))
        (set-box! procs (remove (lambda (x) (eq? x proc)) (unbox procs)))))

    (define (hook-reset! hook)
      (set-box! (cdr (hook-ref hook)) '()))

    (define (hook->list hook)
      (unbox (cdr (hook-ref hook))))

    (define (hook-run hook . args)
      (if (not (= (length args) (car (hook-ref hook))))
          (error "arity of hook ($0) does not match number of arguments ($1)"
                 (car (hook-ref hook))
                 (length args)))
      (for-each (lambda (proc) (apply proc args))
                (hook->list hook)))
  )
)
;;; SRFI 174
;;; POSIX Timespecs
;;;
;;; This SRFI defines the trivial type timespec, which is used to represent the struct
;;; timespec defined by the POSIX `<time.h>` header.
;;;
;;; The reason for putting this very simple and straightforward type into a SRFI (and
;;; library) of its own is that timespecs are part of the interface for more than one
;;; SRFI. If they are defined in just one SRFI and imported by the rest, that produces
;;; an otherwise useless and unnecessary dependency on the defining SRFI. This arises
;;; particularly in R6RS and R7RS because record types are generative (distinct
;;; definitions lead to distinct record types) and because most implementations report
;;; a warning or even an error if the same identifier is imported from different
;;; libraries, unless they have both imported it in turn from the same original library.
;;;
;;; Author of spec: John Cowan
;;;
;;; Copyright © 2019 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 174)

  (import (lispkit base)
          (lispkit comparator))

  (export timespec
          timespec?
          timespec-seconds
          timespec-nanoseconds
          timespec=
          timespec<
          timespec-hash
          timespec-comparator)

  (begin

    (define-type timespec timespec?

      ((timespec sec nano)
        (unless (exact-integer? sec)
          (error "timespec expects exact integer for its second"))
        (unless (and (exact-integer? nano) (<= 0 nano 999999999))
          (error "timespec expects exact integer for its nano second"))
        (cons sec nano))

      ((timespec-seconds (ts)) (car ts))

      ((timespec-nanoseconds (ts)) (cdr ts))

      ((timespec= a b)
         (and (= (timespec-seconds a) (timespec-seconds b))
              (= (timespec-nanoseconds a) (timespec-nanoseconds b))))

      ((timespec< a b)
         (or (< (timespec-seconds a) (timespec-seconds b))
             (and (= (timespec-seconds a) (timespec-seconds b))
                  (< (timespec-nanoseconds a) (timespec-nanoseconds b)))))

      ((timespec-hash (ts))
         (combine-hash (number-hash (car ts)) (number-hash (cdr ts)))))

    (define timespec-comparator
      (make-comparator
        timespec?
        timespec=
        timespec<
        timespec-hash))
  )
)
;;; SRFI 175
;;; ASCII Character Library
;;;
;;; This SRFI defines ASCII-only equivalents to many of the character procedures in
;;; standard Scheme plus a few extra ones. Recent Scheme standards are based around
;;; Unicode but the significant syntactic elements in many file formats and network
;;; protocols are all ASCII. Such low-level code can run faster and its behavior
;;; can be easier to understand when it uses ASCII primitives.
;;;
;;; Copyright © 2019 Lassi Kortela. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2019 Matthias Zenger. All rights reserved.

(define-library (srfi 175)

  (export ascii-codepoint?
          ascii-bytevector?
          ascii-char?
          ascii-string?
          ascii-control?
          ascii-display?
          ascii-whitespace?
          ascii-space-or-tab?
          ascii-punctuation?
          ascii-upper-case?
          ascii-lower-case?
          ascii-alphabetic?
          ascii-alphanumeric?
          ascii-numeric?
          ascii-digit-value
          ascii-upper-case-value
          ascii-lower-case-value
          ascii-nth-digit
          ascii-nth-upper-case
          ascii-nth-lower-case
          ascii-upcase
          ascii-downcase
          ascii-control->display
          ascii-display->control
          ascii-open-bracket
          ascii-close-bracket
          ascii-mirror-bracket
          ascii-ci=?
          ascii-ci<?
          ascii-ci>?
          ascii-ci<=?
          ascii-ci>=?
          ascii-string-ci=?
          ascii-string-ci<?
          ascii-string-ci>?
          ascii-string-ci<=?
          ascii-string-ci>=?)

  (import (lispkit base))

  (begin

    (define (ensure-int x)
      (if (char? x) (char->integer x) x))

    (define (base-offset-limit x base offset limit)
      (let ((cc (ensure-int x)))
        (and (>= cc base) (< cc (+ base limit))
             (+ offset (- cc base)))))

    (define (char->int->char map-int char)
      (let ((int (map-int (char->integer char))))
        (and int (integer->char int))))

    (define (int->char->int map-char int)
      (let ((char (map-char (integer->char int))))
        (and char (char->integer char))))

    (define (ascii-codepoint? x)
      (and (integer? x) (exact? x) (<= 0 x #x7f)))

    (define (ascii-char? x)
      (and (char? x) (< (char->integer x) #x80)))

    (define (ascii-bytevector? x)
      (and (bytevector? x)
           (let check ((i (- (bytevector-length x) 1)))
             (or (< i 0) (and (< (bytevector-u8-ref x i) #x80)
                              (check (- i 1)))))))

    (define (ascii-string? x)
      (and (string? x)
           (call-with-port
            (open-input-string x)
            (lambda (in)
              (let check ()
                (let ((char (read-char in)))
                  (or (eof-object? char)
                      (and (< (char->integer char) #x80) (check)))))))))

    (define (ascii-control? x)
      (let ((cc (ensure-int x)))
        (or (<= 0 cc #x1f) (= cc #x7f))))

    (define (ascii-display? x)
      (let ((cc (ensure-int x)))
        (<= #x20 cc #x7e)))

    (define (ascii-whitespace? x)
      (let ((cc (ensure-int x)))
        (cond ((< cc #x09) #f)
              ((< cc #x0e) #t)
              (else (= cc #x20)))))

    (define (ascii-space-or-tab? x)
      (let ((cc (ensure-int x)))
        (case cc ((#x09 #x20) #t) (else #f))))

    (define (ascii-punctuation? x)
      (let ((cc (ensure-int x)))
        (or (<= #x21 cc #x2f)
            (<= #x3a cc #x40)
            (<= #x5b cc #x60)
            (<= #x7b cc #x7e))))

    (define (ascii-upper-case? x)
      (let ((cc (ensure-int x)))
        (<= #x41 cc #x5a)))

    (define (ascii-lower-case? x)
      (let ((cc (ensure-int x)))
        (<= #x61 cc #x7a)))

    (define (ascii-alphabetic? x)
      (let ((cc (ensure-int x)))
        (or (<= #x41 cc #x5a)
            (<= #x61 cc #x7a))))

    (define (ascii-alphanumeric? x)
      (let ((cc (ensure-int x)))
        (or (<= #x30 cc #x39)
            (<= #x41 cc #x5a)
            (<= #x61 cc #x7a))))

    (define (ascii-numeric? x radix)
      (not (not (ascii-digit-value x radix))))

    (define (ascii-digit-value x limit)
      (base-offset-limit x #x30 0 (min limit 10)))

    (define (ascii-upper-case-value x offset limit)
      (base-offset-limit x #x41 offset (min limit 26)))

    (define (ascii-lower-case-value x offset limit)
      (base-offset-limit x #x61 offset (min limit 26)))

    (define (ascii-nth-digit n)
      (and (<= 0 n 9) (integer->char (+ #x30 n))))

    (define (ascii-nth-upper-case n)
      (integer->char (+ #x41 (modulo n 26))))

    (define (ascii-nth-lower-case n)
      (integer->char (+ #x61 (modulo n 26))))

    (define (ascii-upcase x)
      (if (char? x)
          (integer->char (ascii-upcase (char->integer x)))
          (or (ascii-lower-case-value x #x41 26) x)))

    (define (ascii-downcase x)
      (if (char? x)
          (integer->char (ascii-downcase (char->integer x)))
          (or (ascii-upper-case-value x #x61 26) x)))

    (define (ascii-control->display x)
      (if (char? x)
          (char->int->char ascii-control->display x)
          (or (and (<= 0 x #x1f) (+ x #x40))
              (and (= x #x7f) #x3f))))

    (define (ascii-display->control x)
      (if (char? x)
          (char->int->char ascii-display->control x)
          (or (and (<= #x40 x #x5f) (- x #x40))
              (and (= x #x3f) #x7f))))

    (define (ascii-open-bracket char)
      (case char
        ((#\( #\[ #\{ #\<) char)
        (else (and (integer? char) (int->char->int ascii-open-bracket char)))))

    (define (ascii-close-bracket char)
      (case char
        ((#\) #\] #\} #\>) char)
        (else (and (integer? char) (int->char->int ascii-close-bracket char)))))

    (define (ascii-mirror-bracket char)
      (case char
        ((#\() #\))
        ((#\)) #\()
        ((#\[) #\])
        ((#\]) #\[)
        ((#\{) #\})
        ((#\}) #\{)
        ((#\<) #\>)
        ((#\>) #\<)
        (else (and (integer? char) (int->char->int ascii-mirror-bracket char)))))

    (define (ascii-ci-cmp char1 char2)
      (let ((cc1 (ensure-int char1))
            (cc2 (ensure-int char2)))
        (when (<= #x41 cc1 #x5a) (set! cc1 (+ cc1 #x20)))
        (when (<= #x41 cc2 #x5a) (set! cc2 (+ cc2 #x20)))
        (cond ((< cc1 cc2) -1)
              ((> cc1 cc2) 1)
              (else 0))))

    (define (ascii-ci=? char1 char2)
      (= (ascii-ci-cmp char1 char2) 0))

    (define (ascii-ci<? char1 char2)
      (< (ascii-ci-cmp char1 char2) 0))

    (define (ascii-ci>? char1 char2)
      (> (ascii-ci-cmp char1 char2) 0))

    (define (ascii-ci<=? char1 char2)
      (<= (ascii-ci-cmp char1 char2) 0))

    (define (ascii-ci>=? char1 char2)
      (>= (ascii-ci-cmp char1 char2) 0))

    (define (ascii-string-ci-cmp string1 string2)
      (call-with-port
       (open-input-string string1)
       (lambda (in1)
         (call-with-port
          (open-input-string string2)
          (lambda (in2)
            (let loop ()
              (let ((char1 (read-char in1))
                    (char2 (read-char in2)))
                (cond ((eof-object? char1) (if (eof-object? char2) 0 -1))
                      ((eof-object? char2) 1)
                      (else (let ((cc1 (char->integer char1))
                                  (cc2 (char->integer char2)))
                              (when (<= #x41 cc1 #x5a) (set! cc1 (+ cc1 #x20)))
                              (when (<= #x41 cc2 #x5a) (set! cc2 (+ cc2 #x20)))
                              (cond ((< cc1 cc2) -1)
                                    ((> cc1 cc2) 1)
                                    (else (loop)))))))))))))

    (define (ascii-string-ci=? string1 string2)
      (= (ascii-string-ci-cmp string1 string2) 0))

    (define (ascii-string-ci<? string1 string2)
      (< (ascii-string-ci-cmp string1 string2) 0))

    (define (ascii-string-ci>? string1 string2)
      (> (ascii-string-ci-cmp string1 string2) 0))

    (define (ascii-string-ci<=? string1 string2)
      (<= (ascii-string-ci-cmp string1 string2) 0))

    (define (ascii-string-ci>=? string1 string2)
      (>= (ascii-string-ci-cmp string1 string2) 0))
  )
)

;;; SRFI 177
;;; Portable keyword arguments
;;;
;;; Many Scheme implementations have keyword arguments, but they have not been widely
;;; standardized. This SRFI defines the macros `keyword-lambda` and `keyword-call`. They
;;; can be used identically in every major implementation currently in use, making it
;;; safe to use keyword arguments in portable code. The macros expand to native keyword
;;; arguments in Schemes that have them, letting programmers mix portable code and
;;; implementation-specific code.
;;;
;;; Keyword arguments are a very useful tool for managing complexity as programs grow.
;;; They are a natural solution to the "no, wait, this procedure still needs another
;;; argument" problem which is almost guaranteed to pop up many times over the lifetime
;;; of any non-trivial program. Humans simply cannot plan years ahead at this level of
;;; detail, and adding keyword arguments as an afterthought is less objectionable than
;;; accumulating long lists of optional positional arguments or refactoring central APIs
;;; every few years when third-party code depends on them.
;;;
;;; Copyright © 2019 Lassi Kortela. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2019 Matthias Zenger. All rights reserved.

(define-library (srfi 177)

  (export keyword-lambda
          keyword-call)

  (import (lispkit base))

  (begin

    (define-syntax let-false
      (syntax-rules ()
        ((_ () body ...) (begin body ...))
        ((_ (var) body ...) (let ((var #f)) body ...))
        ((_ (var vars ...) body ...)
          (let ((var #f)) (let-false (vars ...) body ...)))))

    (define-syntax kw-setters
      (syntax-rules ()
        ((_ sym val)
          (error (if (symbol? sym)
                     (string-append "keyword not known: " (symbol->string sym))
                     "keyword is not a symbol")))
        ((_ sym val keyword keywords ...)
          (if (eq? 'keyword sym)
              (set! keyword val)
              (kw-setters sym val keywords ...)))))

    (define-syntax keyword-lambda
      (syntax-rules (kv val vals loop i)
        ((_ (formals ... (keywords ...)) body ...)
          (lambda (formals ... . kv)
            (let-false (keywords ...)
              (let loop ((kv kv))
                (cond ((null? kv))
                      ((not (pair? (cdr kv)))
                       (error "Keyword without value"))
                      (else
                       (let ((sym (car kv)) (val (cadr kv)))
                         (kw-setters sym val keywords ...))
                      (loop (cddr kv)))))
              ((lambda () body ...)))))))

    (define-syntax kw-call-aux
      (syntax-rules ()
        ((_ kw-lambda (kvs ...) (args ...) ())
          (kw-lambda args ... kvs ...))
        ((_ kw-lambda (kvs ...) (args ...) (key val more-kvs ...))
          (kw-call-aux kw-lambda (kvs ... 'key val) (args ...) (more-kvs ...)))))

    (define-syntax keyword-call
      (syntax-rules ()
        ((_ kw-lambda args ... (kvs ...))
          (kw-call-aux kw-lambda () (args ...) (kvs ...)))))
  )
)

;;; SRFI 18
;;; Multithreading support
;;;
;;; This SRFI defines the following multithreading datatypes for Scheme;
;;;   - Thread
;;;   - Mutex
;;;   - Condition variable
;;;   - Time
;;; 
;;; It also defines a mechanism to handle exceptions and some multithreading
;;; exception datatypes.
;;; 
;;; Author of spec: Marc Feeley
;;; 
;;; Copyright © 2022 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
;;; file except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed
;;; under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
;;; CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
;;; language governing permissions and limitations under the License.

(define-library (srfi 18)
  
  (export current-thread
          thread?
          make-thread
          thread-name
          thread-specific
          thread-specific-set!
          thread-start!
          thread-yield!
          thread-sleep!
          thread-terminate!
          thread-join!
          mutex?
          make-mutex
          mutex-name
          mutex-specific
          mutex-specific-set!
          mutex-state
          mutex-lock!
          mutex-unlock!
          condition-variable?
          make-condition-variable
          condition-variable-name
          condition-variable-specific
          condition-variable-specific-set!
          condition-variable-signal!
          condition-variable-broadcast!
          current-time
          time?
          time->seconds
          seconds->time
          current-exception-handler
          with-exception-handler
          raise
          join-timeout-exception?
          abandoned-mutex-exception?
          terminated-thread-exception?
          uncaught-exception?
          uncaught-exception-reason)
  
  (import (lispkit base)
          (rename (lispkit date-time)
            (date-time current-time)
            (date-time? time?)
            (date-time->seconds time->seconds)
            (seconds->date-time seconds->time))
          (rename (lispkit thread)
            (make-thread make-thread-internal)
            (make-mutex make-mutex-internal)
            (make-condition-variable make-condition-variable-internal)
            (thread-yield! thread-yield-internal!)
            (thread-sleep! thread-sleep-internal!)
            (thread-join! thread-join-internal!)
            (mutex-lock! mutex-lock-internal!)
            (mutex-unlock! mutex-unlock-internal!)))
  
  (begin
    
    (define (timeout->seconds timeout)
      (if (time? timeout) 
          (let ((res (fl- (time->seconds timeout) (current-seconds))))
            (if (fl< res 0.0) 0.0 res))
          timeout))
    
    (define-optionals (make-thread proc (name #f))
      (make-thread-internal proc name (box #f)))
    
    (define (thread-specific thread)
      (unbox (thread-tag thread)))
    
    (define (thread-specific-set! thread obj)
      (set-box! (thread-tag thread) obj))
    
    (define (thread-yield!)
      (thread-yield-internal!)
      (thread-sleep-internal! 0.01)) ; this is needed since LispKit's native yield
                                     ; does not guarantee a thread switch
    
    (define (thread-sleep! timeout)
      (thread-sleep-internal! (timeout->seconds timeout)))
    
    (define-optionals (thread-join! thread (timeout #f) (val #f))
      (thread-join-internal! thread (timeout->seconds timeout) val))
    
    (define-optionals (make-mutex (name #f))
      (make-mutex-internal name (box #f)))
    
    (define (mutex-specific thread)
      (unbox (mutex-tag thread)))
    
    (define (mutex-specific-set! thread obj)
      (set-box! (mutex-tag thread) obj))
    
    (define-optionals (mutex-lock! mutex (timeout #f) (thread #f))
      (mutex-lock-internal! mutex (timeout->seconds timeout) thread))
    
    (define (mutex-unlock! mutex (condvar #f) (timeout #f))
      (mutex-unlock-internal! mutex condvar (timeout->seconds timeout)))
    
    (define-optionals (make-condition-variable (name #f))
      (make-condition-variable-internal name (box #f)))
    
    (define (condition-variable-specific thread)
      (unbox (condition-variable-tag thread)))
    
    (define (condition-variable-specific-set! thread obj)
      (set-box! (condition-variable-tag thread) obj))
  )
)
;;; SRFI 180
;;; JSON
;;; 
;;; This library implements a JavaScript Object Notation (JSON) parser and printer.
;;; It supports JSON that may be bigger than memory.
;;; 
;;; Copyright © 2020 Amirouche Boubekki. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 180)

  (export json-number-of-character-limit
          json-nesting-depth-limit
          json-null?
          json-error?
          json-error-reason
          json-fold
          json-generator
          json-read
          json-lines-read
          json-sequence-read
          json-accumulator
          json-write)

  (import (lispkit base)
          (lispkit regexp)
          (srfi 145)
          (only (srfi 151) arithmetic-shift bitwise-ior))
  
  (begin
    (define (%read-error? x)
      (and (error-object? x) (memq (exception-kind x) '(user read read-incomplete)) #t))

    (define json-numbers (regexp "-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?"))

    (define (valid-number? str)
      (regexp-matches? json-numbers str))
  )
  
  (begin
    
    (define (pk . args)
      (write args)(newline)
      (car (reverse args)))
    
    (define json-number-of-character-limit (make-parameter +inf.0))
    
    (define json-nesting-depth-limit (make-parameter +inf.0))
    
    (define (json-null? obj)
      (eq? obj 'null))
    
    (define-record-type <json-error>
      (make-json-error reason)
      json-error?
      (reason json-error-reason))
    
    (define (json-whitespace? char)
      (case char
        ((#\x20 ; Space
          #\x09 ; Horizontal tab
          #\x0A ; Line feed or New line
          #\x0D
          #\x1E ; Record Separator
          )
         #t)
        (else #f)))
    
    (define (expect value other)
      (when (eof-object? value)
        (raise (make-json-error "Unexpected end-of-file.")))
      (assume (char? value))
      (assume (char? other))
      (unless (char=? value other)
        (raise (make-json-error "Unexpected character."))))
    
    (define (port->generator port)
      (let ((count 0)
            (limit (json-number-of-character-limit)))
        (lambda ()
          (let ((out (guard (ex ((%read-error? ex) (raise (make-json-error "Read error!"))))
                       (read-char port))))
            (if (= count limit)
                (raise (make-json-error "Maximum number of character reached."))
                (begin
                  (set! count (+ count 1))
                  out))))))
    
    (define (gcons head generator)
      ;; returns a generator that will yield, HEAD the first time, and
      ;; after than, it will yield items from GENERATOR.
      (let ((head? #t))
        (lambda ()
          (if head?
              (begin (set! head? #f) head)
              (generator)))))
    
    (define (%json-tokens generator)
    
      (define (maybe-ignore-whitespace generator)
        (let loop ((char (generator)))
          (if (json-whitespace? char)
              (loop (generator))
              char)))
    
      (define (expect-null generator)
        (expect (generator) #\u)
        (expect (generator) #\l)
        (expect (generator) #\l))
    
      (define (expect-true generator)
        (expect (generator) #\r)
        (expect (generator) #\u)
        (expect (generator) #\e))
    
      (define (expect-false generator)
        (expect (generator) #\a)
        (expect (generator) #\l)
        (expect (generator) #\s)
        (expect (generator) #\e))
    
      (define (maybe-char generator)
        (let ((char (generator)))
          (when (eof-object? char)
            (raise (make-json-error "Unexpected end-of-file.")))
          (when (char=? char #\")
            (raise (make-json-error "Unexpected end of string.")))
          char))
    
      (define (read-unicode-escape generator)
        (let* ((one (maybe-char generator))
               (two (maybe-char generator))
               (three (maybe-char generator))
               (four (maybe-char generator)))
          (let ((out (string->number (list->string (list one two three four)) 16)))
            (if out
                out
                (raise (make-json-error "Invalid code point."))))))
    
      (define ash arithmetic-shift)
    
      (define (read-json-string generator)
        (let loop ((char (generator))
                   (out '()))
    
          (when (eof-object? char)
            (raise (make-json-error "Unexpected end of file.")))
    
          (when (or (char=? char #\x00)
                    (char=? char #\newline)
                    (char=? char #\tab))
            (raise (make-json-error "Unescaped control char.")))
    
          ;; XXX: Here be dragons.
          (if (char=? char #\\)
              (begin
                (let loop-unescape ((char (generator))
                                    (chars-unescaped '()))
                  (case char
                    ((#\" #\\ #\/) (loop (generator)
                                         (cons char (append chars-unescaped
                                                            out))))
                    ((#\b) (loop (generator) (cons #\backspace
                                                        (append chars-unescaped
                                                                out))))
                    ((#\f) (loop (generator) (cons #\x0C
                                                        (append chars-unescaped
                                                                out))))
                    ((#\n) (loop (generator) (cons #\newline
                                                        (append chars-unescaped
                                                                out))))
                    ((#\r) (loop (generator) (cons #\x0D
                                                        (append chars-unescaped
                                                                out))))
                    ((#\t) (loop (generator) (cons #\tab
                                                        (append chars-unescaped
                                                                out))))
                    ((#\u) (let loop-unicode ((code1 (read-unicode-escape generator))
                                              (chars chars-unescaped))
                             (let ((next-char (generator)))
                               (if (and (<= #xd800 code1 #xdbff)
                                        (char=? next-char #\\))
                                   (if (char=? (generator) #\u)
                                       (let ((code2 (read-unicode-escape generator)))
                                         (if (<= #xdc00 code2 #xdfff)
                                             (let ((integer
                                                    (+ #x10000 (bitwise-ior
                                                                (ash (- code1 #xd800) 10)
                                                                (- code2 #xdc00)))))
                                               ;; full escape of unicode is parsed...
                                               (loop (generator)
                                                     (cons (integer->char integer)
                                                           (append chars
                                                                   out))))
                                             ;; This is another unicode char
                                             (loop-unicode (read-unicode-escape generator)
                                                           (cons (integer->char code1) chars))))
                                       ;; The escaped unicode char is
                                       ;; parsed, need to parse another
                                       ;; escape that is not a unicode
                                       ;; escape sequence
                                       (loop-unescape char (cons (integer->char code1)
                                                                 chars)))
                                 ;; This is not a big-ish unicode char and
                                 ;; the next thing is some other char.
                                 (loop next-char
                                       (cons (integer->char code1) (append chars out)))))))
                    (else (raise (make-json-error "Unexpected escaped sequence."))))))
              (cond
               ((char=? char #\")
                (list->string (reverse out)))
               (else
                (loop (generator) (cons char out)))))))
    
      (define (maybe-read-number generator)
        ;; accumulate chars until a control char or whitespace is reached,
        ;; validate that it is JSON number, then intrepret it as Scheme
        ;; number using string->number
        (let loop ((char (generator))
                   (out '()))
          (if (or (eof-object? char)
                  (json-whitespace? char)
                  (char=? char #\,)
                  (char=? char #\])
                  (char=? char #\}))
              (let ((string (list->string (reverse out))))
                (if (valid-number? string)
                    (let ((number (string->number string)))
                      (if number
                          (values number char)
                          (raise (make-json-error "Invalid number."))))
                    (raise (make-json-error "Invalid number."))))
              (loop (generator) (cons char out)))))
    
      ;; gist
      (assume (procedure? generator))
    
      (let ((char (generator)))
        (if (eof-object? char)
            eof-object  ;; return an empty generator
            (begin
    
              (unless (char=? char #\xFEFF)
                ;; if it is not a UTF-8 BOM, put back the char in front of
                ;; the generator
                (set! generator (gcons char generator)))
    
              (lambda ()
    
                (define char (maybe-ignore-whitespace generator))
    
                (if (eof-object? char)
                    char ;; return that eof-object
                    (case char
                      ((#\n) (expect-null generator) 'null)
                      ((#\t) (expect-true generator) #t)
                      ((#\f) (expect-false generator) #f)
                      ((#\:) 'colon)
                      ((#\,) 'comma)
                      ((#\[) 'array-start)
                      ((#\]) 'array-end)
                      ((#\{) 'object-start)
                      ((#\}) 'object-end)
                      ((#\") (read-json-string generator))
                      (else
                       (call-with-values (lambda () (maybe-read-number (gcons char generator)))
                         (lambda (number next)
                           (set! generator (gcons next generator))
                           number))))))))))
    
    (define json-tokens
      (case-lambda
       (() (json-tokens (current-input-port)))
       ((port-or-generator)
        (cond
         ((procedure? port-or-generator)
          (%json-tokens port-or-generator))
         ((and (textual-port? port-or-generator) (input-port? port-or-generator))
           (%json-generator (port->generator port-or-generator)))
         (else (error 'json "json-tokens error, argument is not valid" port-or-generator))))))
    
    (define (%json-generator tokens)
    
      (define limit (json-nesting-depth-limit))
      (define count 0)
    
      (define (handle-limit!)
        (if (= count limit)
            (raise (make-json-error "Maximum JSON nesting depth reached"))
            (set! count (+ count 1))))
    
      (define (array-maybe-continue tokens k)
        (lambda ()
          (let ((token (tokens)))
            (case token
              ((comma) (start tokens (array-maybe-continue tokens k)))
              ((array-end) (values 'array-end k))
              (else (raise (make-json-error "Invalid array, expected comma or array close.")))))))
    
      (define (array-start tokens k)
        (lambda ()
          (handle-limit!)
          (let ((token (tokens)))
            (if (eq? token 'array-end)
                (values 'array-end k)
                (start (gcons token tokens) (array-maybe-continue tokens k))))))
    
      (define (object-maybe-continue tokens k)
        (lambda ()
          (let ((token (tokens)))
            (case token
              ((object-end) (values 'object-end k))
              ((comma) (let ((token (tokens)))
                         (unless (string? token)
                           (raise (make-json-error "Invalid object, expected an object key")))
                         (values token
                                 (object-colon tokens k))))
              (else (raise (make-json-error "Invalid object, expected comma or object close.")))))))
    
      (define (object-colon tokens k)
        (lambda ()
          (let ((token (tokens)))
            (if (eq? token 'colon)
                (let ((token (tokens)))
                  (if (eof-object? token)
                      (raise (make-json-error "Invalid object, expected object value."))
                      (start (gcons token tokens) (object-maybe-continue tokens k))))
                (raise (make-json-error "Invalid object, expected colon."))))))
    
      (define (object-start tokens k)
        (lambda ()
          (handle-limit!)
          (let ((token (tokens)))
            (cond
             ((eq? token 'object-end) (values 'object-end k))
             ((string? token)
              (values token
                      (object-colon tokens k)))
             (else (raise (make-json-error "Invalid object, expected object key or object close.")))))))
    
      (define (start tokens k)
        (let ((token (tokens)))
          (if (eof-object? token)
              (values token k)
              (cond
               ((or (json-null? token)
                    (number? token)
                    (string? token)
                    (boolean? token))
                (values token k))
               ((eq? token 'array-start)
                (values 'array-start (array-start tokens k)))
               ((eq? token 'object-start)
                (values 'object-start (object-start tokens k)))
               (else (raise (make-json-error "Is it JSON text?!")))))))
    
      (define (end-of-top-level-value)
        ;; json-generator returns a generator that reads one top-level
        ;; json. If there is more than one top-level json value in the
        ;; generator separated with space as it is the case of json-lines,
        ;; you need to call json-generator with the same port or
        ;; generator.
        (values (eof-object) #f))
    
      (define (make-trampoline-generator tokens)
        (let ((continuation (lambda () (start tokens end-of-top-level-value))))
          (lambda ()
            (when continuation
              (call-with-values continuation
                (lambda (event new-continuation)
                  (set! continuation new-continuation)
                  event))))))
    
      ;; gist
    
      (assume (procedure? tokens))
    
      (make-trampoline-generator tokens))
    
    (define json-generator-error
      "Argument does not look like a generator and is not a textual input port.")
    
    (define json-generator
      (case-lambda
        (() (json-generator (current-input-port)))
        ((port)
         (%json-generator (json-tokens (port->generator port))))))
    
    ;; XXX: procedure foldts is not used as-is. It was copied here for
    ;; documentation purpose (public domain, by Oleg Kiselyov).
    (define (foldts fdown fup fhere seed tree)
      ;; - fhere is applied to the leafs of the tree
      ;;
      ;; - fdown is invoked when a non-leaf node is entered before any of
      ;; the node's children are visited. fdown action has to generate a
      ;; seed to be passed to the first visited child of the node.
      ;;
      ;; - fup is invoked after all the children of a node have been
      ;; seen. The first argument is the local state at the moment the
      ;; traversal process enters the branch rooted at the current node. The
      ;; second argument is the result of visiting all child branches.  The
      ;; action of fup isto produce a seed that is taken to be the state of
      ;; the traversal after the process leave the currents the current
      ;; branch.
      (cond
        ((null? tree) seed)
        ((not (pair? tree))      ; An atom
          (fhere seed tree))
        (else
          (let loop ((kid-seed (fdown seed tree))
                     (kids (cdr tree)))
            (if (null? kids)
                (fup seed kid-seed tree)
                (loop (foldts fdown fup fhere kid-seed (car kids))
                      (cdr kids)))))))
    
    (define (%json-fold proc array-start array-end object-start object-end seed port-or-generator)
    
      ;; json-fold is inspired from the above foldts definition, unlike
      ;; the above definition, it is continuation-passing-style.  fhere is
      ;; renamed PROC.  Unlike foldts, json-fold will call (proc obj seed)
      ;; everytime a JSON value or complete structure is read from the
      ;; EVENTS generator, where OBJ will be: a) In the case of
      ;; structures, the the result of the recursive call or b) a JSON
      ;; value.
    
      ;; json-fold will terminates in three cases:
      ;;
      ;; - eof-object was generated, return the seed.
      ;;
      ;; - event-type 'array-end is generated, if EVENTS is returned by
      ;; json-generator, it means a complete array was read.
      ;;
      ;; - event-type 'object-end is generated, similarly, if EVENTS is
      ;; returned by json-generator, it means complete array was
      ;; read.
      ;;
      ;; IF EVENTS does not follow the json-generator protocol, the
      ;; behavior is unspecified.
    
      (define events (json-generator port-or-generator))
    
      (define (ruse seed k)
        (lambda ()
          (let loop ((seed seed))
            (let ((event (events)))
              (if (eof-object? event)
                  (begin (k seed) #f)
                  (case event
                    ;; termination cases
                    ((array-end) (k seed))
                    ((object-end) (k seed))
                    ;; recursion
                    ((array-start) (ruse (array-start seed)
                                         (lambda (out) (loop (proc (array-end out) seed)))))
                    ((object-start) (ruse (object-start seed)
                                          (lambda (out) (loop (proc (object-end out) seed)))))
                    (else (loop (proc event seed)))))))))
    
      (define (make-trampoline-fold k)
        (let ((thunk (ruse seed k)))
          (let loop ((thunk thunk))
            (when thunk
              (loop (thunk))))))
    
      (define %unset '(unset))
    
      (let ((out %unset))
        (define (escape out*)
          (set! out out*)
          #f)
        (make-trampoline-fold escape)
        (if (eq? out %unset)
            (error 'json "Is this JSON text")
            out)))
    
    (define json-fold
      (case-lambda
        ((proc array-start array-end object-start object-end seed)
          (json-fold proc array-start array-end object-start object-end seed (current-input-port)))
        ((proc array-start array-end object-start object-end seed port-or-generator)
          (%json-fold proc array-start array-end object-start object-end seed port-or-generator))))
    
    (define (%json-read port-or-generator)
    
      (define %root '(root))
    
      (define (array-start seed)
        ;; array will be read as a list, then converted into a vector in
        ;; array-end.
        '())
    
      (define (array-end items)
        (list->vector (reverse items)))
    
      (define (object-start seed)
        ;; object will be read as a property list, then converted into an
        ;; alist in object-end.
        '())
    
      (define (plist->alist plist)
        ;; PLIST is a list of even items, otherwise json-generator
        ;; would have raised a json-error.
        (let loop ((plist plist)
                   (out '()))
          (if (null? plist)
              out
              (loop (cddr plist) (cons (cons (string->symbol (cadr plist)) (car plist)) out)))))
    
      (define object-end plist->alist)
    
      (define (proc obj seed)
        ;; proc is called when a JSON value or structure was completly
        ;; read.  The parse result is passed as OBJ.  In the case where
        ;; what is parsed is a JSON simple json value then OBJ is simply
        ;; the token that is read that can be 'null, a number or a string.
        ;; In the case where what is parsed is a JSON structure, OBJ is
        ;; what is returned by OBJECT-END or ARRAY-END.
        (if (eq? seed %root)
         ;; It is toplevel, a complete JSON value or structure was read,
         ;; return it.
         obj
         ;; This is not toplevel, hence json-fold is called recursivly,
         ;; to parse an array or object.  Both ARRAY-START and
         ;; OBJECT-START return an empty list as a seed to serve as an
         ;; accumulator.  Both OBJECT-END and ARRAY-END expect a list
         ;; as argument.
         (cons obj seed)))
    
      (let ((out (json-fold proc
                            array-start
                            array-end
                            object-start
                            object-end
                            %root
                            port-or-generator)))
        ;; if out is the root object, then the port or generator is empty.
        (if (eq? out %root)
            (eof-object)
            out)))
    
    (define json-read
      (case-lambda
        (() (json-read (current-input-port)))
        ((port-or-generator) (%json-read port-or-generator))))
    
    ;; json-lines-read
    
    (define json-lines-read
      (case-lambda
        (() (json-lines-read (current-input-port)))
        ((port-or-generator)
         (lambda ()
           (json-read port-or-generator)))))
    
    ;; json-sequence-read
    
    (define json-sequence-read
      (case-lambda
        (() (json-sequence-read (current-input-port)))
        ((port-or-generator)
         (lambda ()
           (let loop ()
             (guard (ex ((json-error? ex) (loop)))
               (json-read port-or-generator)))))))
    
    ;; write procedures
    
    (define (json-accumulator accumulator)
    
      (define (write-json-char char accumulator)
        (case char
          ((#\x00) (accumulator "\\u0000"))
          ((#\") (accumulator "\\\""))
          ((#\\) (accumulator "\\\\"))
          ((#\/) (accumulator "\\/"))
          ((#\return) (accumulator "\\r"))
          ((#\newline) (accumulator "\\n"))
          ((#\tab) (accumulator "\\t"))
          ((#\backspace) (accumulator "\\b"))
          ((#\x0c) (accumulator "\\f"))
          ((#\x0d) (accumulator "\\r"))
          (else (accumulator char))))
    
      (define (write-json-string string accumulator)
        (accumulator #\")
        (string-for-each
         (lambda (char) (write-json-char char accumulator))
         string)
        (accumulator #\"))
    
      (define (write-json-value obj accumulator)
        (cond
         ((eq? obj 'null) (accumulator "null"))
         ((boolean? obj) (if obj
                             (accumulator "true")
                             (accumulator "false")))
         ((string? obj) (write-json-string obj accumulator))
         ((number? obj) (accumulator (number->string obj)))
         (else (raise (make-json-error "Invalid json value.")))))
    
      (define (raise-invalid-event event)
        (raise event))
      ;;(raise (make-json-error "json-accumulator: invalid event.")))
    
      (define (object-start k)
        (lambda (accumulator event)
          (accumulator #\{)
          (case (car event)
            ((json-value)
             (let ((key (cdr event)))
               (unless (symbol? key) (raise-invalid-event event))
               (write-json-string (symbol->string key) accumulator)
               (object-value k)))
            ((json-structure)
             (case (cdr event)
               ((object-end)
                (accumulator #\})
                k)
               (else (raise-invalid-event event))))
            (else (raise-invalid-event event)))))
    
      (define (object-value k)
        (lambda (accumulator event)
          (accumulator #\:)
          (case (car event)
            ((json-value)
             (write-json-value (cdr event) accumulator)
             (object-maybe-continue k))
            ((json-structure)
             (case (cdr event)
               ((array-start)
                (array-start (object-maybe-continue k)))
               ((object-start)
                (object-start (object-maybe-continue k)))
               (else (raise-invalid-event event))))
            (else (raise-invalid-event event)))))
    
      (define (object-maybe-continue k)
        (lambda (accumulator event)
          (case (car event)
            ((json-value)
             (accumulator #\,)
             (let ((key (cdr event)))
               (unless (symbol? key) (raise-invalid-event event))
               (write-json-value (symbol->string key) accumulator)
               (object-value k)))
            ((json-structure)
             (case (cdr event)
               ((object-end)
                (accumulator #\})
                k)
               (else (raise-invalid-event event))))
            (else (raise-invalid-event event)))))
    
      (define (array-start k)
        (lambda (accumulator event)
          (accumulator #\[)
          (case (car event)
            ((json-value)
             (write-json-value (cdr event) accumulator)
             (array-maybe-continue k))
            ((json-structure)
             (case (cdr event)
               ((array-end)
                (accumulator #\])
                k)
               ((array-start) (array-start (array-maybe-continue k)))
               ((object-start) (object-start (array-maybe-continue k)))
               (else (raise-invalid-event event))))
            (else (raise-invalid-event event)))))
    
      (define (array-maybe-continue k)
        (lambda (accumulator event)
          (case (car event)
            ((json-value)
             (accumulator #\,)
             (write-json-value (cdr event) accumulator)
             (array-maybe-continue k))
            ((json-structure)
             (case (cdr event)
               ((array-end)
                (accumulator #\])
                k)
               ((array-start)
                (accumulator #\,)
                (array-start (array-maybe-continue k)))
               ((object-start)
                (accumulator #\,)
                (object-start (array-maybe-continue k)))
               (else (raise-invalid-event event))))
            (else (raise-invalid-event event)))))
    
      (define (start accumulator event)
        (case (car event)
          ((json-value)
           (write-json-value (cdr event) accumulator)
           raise-invalid-event)
          ((json-structure)
           (case (cdr event)
             ((array-start)
              (array-start raise-invalid-event))
             ((object-start)
              (object-start raise-invalid-event))
             (else (raise-invalid-event event))))
          (else (raise-invalid-event event))))
    
      (assume (procedure? accumulator)
              "ACCUMULATOR does look like a valid accumulator.")
    
      (let ((k start))
        (lambda (event)
          (set! k (k accumulator event)))))
    
    (define (%json-write obj accumulator)
    
      (define (void)
        (if #f #f))
    
      (define (raise-unless-valid? obj)
        (cond
         ((null? obj) (void))
         ((eq? obj 'null) (void))
         ((boolean? obj) (void))
         ((string? obj) (void))
         ((and (number? obj)
               (not (infinite? obj))
               (not (nan? obj))
               (real? obj)
               (or (and (exact? obj) (= (denominator obj) 1))
                   (inexact? obj)))
          (void))
         ((vector? obj)
          (vector-for-each (lambda (obj) (raise-unless-valid? obj)) obj))
         ;; XXX: use pair? then recursively check the tail.
         ((pair? obj)
          (for-each (lambda (obj)
                      (unless (pair? obj)
                        (raise (make-json-error "Unexpected object, not a pair.")))
                      (unless (symbol? (car obj))
                        (raise (make-json-error "Unexpected object, not a symbol key.")))
                      (raise-unless-valid? (cdr obj)))
                    obj))
         (else (raise (make-json-error "Unexpected object")))))
    
      (define (write obj accumulator)
        (cond
         ((or (eq? obj 'null)
              (boolean? obj)
              (string? obj)
              (symbol? obj)
              (number? obj))
          (accumulator (cons 'json-value obj)))
         ((vector? obj)
          (accumulator '(json-structure . array-start))
          (vector-for-each (lambda (obj) (write obj accumulator)) obj)
          (accumulator '(json-structure . array-end)))
         ((null? obj)
          (accumulator '(json-structure . object-start))
          (accumulator '(json-structure . object-end)))
         ((pair? obj)
          (accumulator '(json-structure . object-start))
          (for-each (lambda (pair)
                      (write (car pair) accumulator)
                      (write (cdr pair) accumulator))
                    obj)
          (accumulator '(json-structure . object-end)))
         (else (error "Unexpected error!"))))
    
      (assume (procedure? accumulator))
      (raise-unless-valid? obj)
      (write obj (json-accumulator accumulator)))
    
    (define (port->accumulator port)
      (lambda (char-or-string)
        (cond
         ((char? char-or-string) (write-char char-or-string port))
         ((string? char-or-string) (write-string char-or-string port))
         (else (raise (make-json-error "Not a char or string"))))))
    
    (define json-write
      (case-lambda
        ((obj) (json-write obj (current-output-port)))
        ((obj port-or-accumulator)
         (assume (or (procedure? port-or-accumulator)
                      (and (textual-port? port-or-accumulator)
                           (output-port? port-or-accumulator))))
         (if (procedure? port-or-accumulator)
             (%json-write obj port-or-accumulator)
             (%json-write obj (port->accumulator port-or-accumulator)))))) 
  )  
)
;;; SRFI 189
;;; Maybe and Either: Optional Container Types
;;; 
;;; This SRFI defines two disjoint immutable container types known as Maybe and Either,
;;; both of which can contain objects collectively known as their payload. A Maybe
;;; object is either a Just object or the unique object Nothing (which has no payload);
;;; an Either object is either a Right object or a Left object. Maybe represents the
;;; concept of optional values; Either represents the concept of values which are
;;; either correct (Right) or errors (Left).
;;; 
;;; Copyright © 2020 John Cowan, Wolfgang Corcoran-Mathe. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 189)
  
  (export maybe?
          either?
          just
          nothing
          left
          right
          nothing?
          just?
          left?
          right?
          maybe= 
          either=
          either-swap
          maybe-ref
          maybe-ref/default
          either-ref
          either-ref/default
          maybe-join
          maybe-bind
          maybe-compose
          either-join
          either-bind
          either-compose
          maybe-length
          maybe-filter
          maybe-remove
          either-length
          either-filter
          either-remove
          maybe-sequence
          either-sequence
          maybe->either
          either->maybe
          list->just
          list->right
          maybe->list
          either->list
          maybe->truth
          either->truth
          truth->maybe
          maybe->values
          maybe->two-values
          values->maybe
          either->values
          values
          values->either
          two-values->maybe
          maybe-for-each
          either-for-each
          maybe->generation
          generation->maybe
          list->left
          list->maybe
          list->either
          maybe->list-truth
          either->list-truth
          list-truth->maybe
          list-truth->either
          truth->either
          either->generation
          generation->either
          exception->either
          either-guard
          maybe-map
          maybe-fold
          maybe-unfold
          either-map
          either-fold
          either-unfold
          tri-not
          tri=?
          tri-and
          tri-or
          tri-merge
          maybe-and
          maybe-or
          maybe-let*
          either-and
          either-or
          either-let*
          maybe-let*-values
          either-let*-values
          maybe-if)
  
  (import (lispkit base)
          (srfi 1)
          (srfi 145))
  
  (begin
    
    (define-record-type <just>
      (raw-just objs)
      just?
      (objs just-objs))
    
    (define-record-type <nothing>
      (make-nothing)
      nothing?)
    
    (define-record-type <left>
      (raw-left objs)
      left?
      (objs left-objs))
    
    (define-record-type <right>
      (raw-right objs)
      right?
      (objs right-objs))
    
    (define nothing-obj (make-nothing))
    
    (define (nothing)
      nothing-obj)
    
    ;;;; Utility
    
    (define-syntax const
      (syntax-rules ()
        ((_ obj) (lambda _ obj))))
    
    (define (singleton? lis)
      (and (pair? lis) (null? (cdr lis))))
    
    (define-syntax fast-apply
      (syntax-rules ()
        ((_ proc args)
          (if (singleton? args) (proc (car args)) (apply proc args)))))
    
    (define-syntax fast-list->values
      (syntax-rules ()
        ((_ vals)
          (if (singleton? vals) (car vals) (apply values vals)))))
    
    (define unspecified (if #f #f))
    
    ;;;; Constructors
    
    (define (just . objs)
      (raw-just objs))
    
    (define (left . objs)
      (raw-left objs))
    
    (define (right . objs)
      (raw-right objs))
    
    ;;; List -> <container> equivalents of the basic constructors.
    
    ;;; Here and elsewhere, we copy caller-provided list arguments when
    ;;; passing them to raw-just/left/right, so that later mutation of the
    ;;; list argument doesn't affect the payloads of any Maybes/Eithers.
    
    (define (list->just lis)
      (assume (or (null? lis) (pair? lis)))
      (raw-just lis))
    
    (define (list->right lis)
      (assume (or (null? lis) (pair? lis)))
      (raw-right lis))
    
    (define (list->left lis)
      (assume (or (null? lis) (pair? lis)))
      (raw-left lis))
    
    (define (maybe->either maybe . default-objs)
      (assume (maybe? maybe))
      (if (nothing? maybe)
          (raw-left default-objs)
          (raw-right (just-objs maybe))))
    
    (define (either->maybe either)
      (assume (either? either))
      (if (left? either)
          nothing-obj
          (raw-just (right-objs either))))
    
    (define (either-swap either)
      (assume (either? either))
      (if (right? either)
          (raw-left (right-objs either))
          (raw-right (left-objs either))))
    
    ;;;; Predicates
    
    (define (maybe? obj)
      (or (just? obj) (nothing? obj)))
    
    (define (nothing? obj)
      (eqv? obj nothing-obj))
    
    ;; True if all the maybes are Nothing, or if all are Justs containing
    ;; the same number of values which are element-wise equal in the sense
    ;; of `equal'.
    (define (maybe= equal . maybes)
      (assume (procedure? equal))
      (assume (pair? maybes))
      (let ((maybe1 (car maybes)))
        (every (lambda (maybe2) (%maybe=2 equal maybe1 maybe2))
               (cdr maybes))))
    
    ;; Compare two Maybes.
    (define (%maybe=2 equal maybe1 maybe2)
      (or (eqv? maybe1 maybe2)  ; Also handles the Nothing = Nothing case.
          (and (just? maybe1)
               (just? maybe2)
               (list= equal (just-objs maybe1) (just-objs maybe2)))))
    
    (define (either? obj)
      (or (left? obj) (right? obj)))
    
    ;; True if the eithers are all Lefts/all Rights containing the same
    ;; number of values which are element-wise equal in the sense of `equal'.
    (define (either= equal . eithers)
      (assume (procedure? equal))
      (assume (pair? eithers))
      (let ((either1 (car eithers)))
        (every (lambda (either2) (%either=2 equal either1 either2))
               (cdr eithers))))
    
    ;; Compare two Eithers.
    (define (%either=2 equal either1 either2)
      (let ((e= (lambda (acc) (list= equal (acc either1) (acc either2)))))
        (or (eqv? either1 either2)
            (and (left? either1) (left? either2) (e= left-objs))
            (and (right? either1) (right? either2) (e= right-objs)))))
    
    ;;;; Accessors
    
    ;; Unwrap a Maybe.  If it's a Just, call the optional success
    ;; continuation (default: values) on its payload; otherwise,
    ;; call failure.
    (define (maybe-ref maybe failure . %opt-args)
      (assume (maybe? maybe))
      (assume (procedure? failure))
      (if (just? maybe)
          (let ((objs (just-objs maybe))
                (success (if (pair? %opt-args) (car %opt-args) values)))
            (fast-apply success objs))
          (failure)))
    
    ;; Unwrap a Maybe.  If it's a Nothing, return the default objects.
    (define (maybe-ref/default maybe . default-objs)
      (assume (maybe? maybe))
      (if (just? maybe)
          (let ((objs (just-objs maybe)))
            (fast-list->values objs))
          (fast-list->values default-objs)))
    
    (define (%either-ref-single either accessor cont)
      (let ((objs (accessor either)))
        (fast-apply cont objs)))
    
    ;; Unwrap an Either, calling failure on the payload of a Left and the
    ;; optional success continuation (default: values) on that of a Right.
    (define (either-ref either failure . %opt-args)
      (assume (either? either))
      (assume (procedure? failure))
      (if (right? either)
          (%either-ref-single either right-objs (if (pair? %opt-args)
                                                    (car %opt-args)
                                                    values))
          (%either-ref-single either left-objs failure)))
    
    ;; Unwrap an Either.  If it's a Left, return the default objects.
    (define (either-ref/default either . default-objs)
      (assume (either? either))
      (if (right? either)
          (let ((objs (right-objs either)))
            (fast-list->values objs))
          (fast-list->values default-objs)))
    
    ;;;; Join and bind
    
    ;; If maybe is a Just containing a single Maybe, return that Maybe.
    (define (maybe-join maybe)
      (assume (maybe? maybe))
      (if (nothing? maybe)
          nothing-obj
          (let ((objs (just-objs maybe)))
            (assume (and (singleton? objs) (maybe? (car objs)))
                    "maybe-join: invalid payload")
            (car objs))))
    
    ;; Call the first mproc on the payload of a Maybe, producing a Maybe.
    ;; Repeat the operation with this Maybe and the remaining mprocs.
    ;; Return a Nothing immediately.
    (define (maybe-bind maybe mproc . mprocs)
      (assume (maybe? maybe))
      (if (null? mprocs)
          (maybe-ref maybe nothing mproc)  ; fast path
          (let lp ((m maybe) (mp mproc) (mprocs mprocs))
            (maybe-ref m
                       nothing
                       (lambda objs
                         (if (null? mprocs)
                             (fast-apply mp objs) ; tail-call last
                             (lp (fast-apply mp objs)
                                 (car mprocs)
                                 (cdr mprocs))))))))
    
    ;; Compose the argument mprocs and return the resulting monadic procedure.
    (define (maybe-compose . mprocs)
      (assume (pair? mprocs))
      (lambda args
        (let lp ((args args) (mproc (car mprocs)) (rest (cdr mprocs)))
          (if (null? rest)
              (fast-apply mproc args)             ; tail-call last
              (maybe-ref (fast-apply mproc args)
                         nothing
                         (lambda objs
                           (lp objs (car rest) (cdr rest))))))))
    
    ;; If either is a Right containing a single Either, return that Either.
    (define (either-join either)
      (assume (either? either))
      (if (left? either)
          either
          (let ((objs (right-objs either)))
            (assume (and (singleton? objs) (either? (car objs)))
                    "either-join: invalid payload")
            (car objs))))
    
    ;; Call the first mproc on the payload of a Either, producing a Either.
    ;; Repeat the operation with this Either and the remaining mprocs.
    ;; Return a Left immediately.
    (define (either-bind either mproc . mprocs)
      (assume (either? either))
      (if (null? mprocs)
          (either-ref either (const either) mproc)  ; fast path
          (let lp ((e either) (mp mproc) (mprocs mprocs))
            (either-ref e
                        (const e)
                        (lambda objs
                          (if (null? mprocs)
                              (fast-apply mp objs)  ; tail-call last
                              (lp (fast-apply mp objs)
                                  (car mprocs)
                                  (cdr mprocs))))))))
    
    ;; Compose the argument mprocs and return the resulting monadic procedure.
    (define (either-compose . mprocs)
      (assume (pair? mprocs))
      (lambda args
        (let lp ((args args) (mproc (car mprocs)) (rest (cdr mprocs)))
          (if (null? rest)
              (fast-apply mproc args)              ; tail-call last
              (either-ref (fast-apply mproc args)
                          left
                          (lambda objs
                            (lp objs (car rest) (cdr rest))))))))
    
    ;;;; Sequence operations
    
    (define (maybe-length maybe)
      (assume (maybe? maybe))
      (if (just? maybe) 1 0))
    
    ;; Return maybe if its payload satisfies pred; otherwise, return Nothing.
    (define (maybe-filter pred maybe)
      (assume (procedure? pred))
      (assume (maybe? maybe))
      (if (and (just? maybe) (fast-apply pred (just-objs maybe)))
          maybe
          nothing-obj))
    
    ;; Return maybe if its payload doesn't satisfy pred; otherwise, return
    ;; Nothing.
    (define (maybe-remove pred maybe)
      (assume (procedure? pred))
      (assume (maybe? maybe))
      (if (and (just? maybe)
               (not (fast-apply pred (just-objs maybe))))
          maybe
          nothing-obj))
    
    ;; Traverse a container of Maybes with cmap, collect the payload
    ;; objects with aggregator, and wrap the new collection in a Just.
    ;; If a Nothing is encountered while traversing, return it
    ;; immediately.
    (define maybe-sequence
      (case-lambda
        ((container cmap) (maybe-sequence container cmap list))
        ((container cmap aggregator)
          (assume (procedure? cmap))
          (assume (procedure? aggregator))
          (call-with-current-continuation
            (lambda (return)
              (just (cmap (lambda (m)
                            (maybe-ref m (lambda () (return m)) aggregator))
                          container)))))))
    
    (define (either-length either)
      (assume (either? either))
      (if (right? either) 1 0))
    
    ;; Return either if its payload satisfies pred; otherwise, return
    ;; a Left of the default objects.
    (define (either-filter pred either . default-objs)
      (assume (procedure? pred))
      (assume (either? either))
      (if (and (right? either) (fast-apply pred (right-objs either)))
          either
          (raw-left default-objs)))
    
    (define (either-remove pred either . default-objs)
      (assume (procedure? pred))
      (assume (either? either))
      (if (and (right? either)
               (not (fast-apply pred (right-objs either))))
          either
          (raw-left default-objs)))
    
    ;; Traverse a container of Eithers with cmap, collect the payload
    ;; objects with aggregator, and wrap the new collection in a Right.
    ;; If a Left is encountered while traversing, return it immediately.
    (define either-sequence
      (case-lambda
        ((container cmap) (either-sequence container cmap list))
        ((container cmap aggregator)
          (assume (procedure? cmap))
          (assume (procedure? aggregator))
          (call-with-current-continuation
            (lambda (return)
              (right (cmap (lambda (e)
                             (either-ref e (const (return e)) aggregator))
                           container)))))))
    
    ;;;; Protocol conversion
    
    (define (maybe->list maybe)
      (assume (maybe? maybe))
      (if (nothing? maybe) '() (just-objs maybe)))
    
    (define (either->list either)
      (assume (either? either))
      ((if (right? either) right-objs left-objs) either))
    
    (define (list->maybe lis)
      (assume (or (null? lis) (pair? lis)))
      (if (null? lis) nothing-obj (raw-just lis)))
    
    (define (list->either lis . default-objs)
      (assume (or (null? lis) (pair? lis)))
      (if (null? lis)
          (raw-left default-objs)
          (raw-right lis)))
    
    ;; If maybe is a Just, return its payload; otherwise, return false.
    (define (maybe->truth maybe)
      (assume (maybe? maybe))
      (if (nothing? maybe)
          #f
          (begin
            (assume (singleton? (just-objs maybe))
                    "maybe->truth: invalid payload")
            (car (just-objs maybe)))))
    
    ;; If either is a Right, return its payload; otherwise, return false.
    (define (either->truth either)
      (assume (either? either))
      (if (left? either)
          #f
          (begin
            (assume (singleton? (right-objs either))
                    "either->truth: invalid payload")
            (car (right-objs either)))))
    
    (define (truth->maybe obj)
      (if obj (just obj) nothing-obj))
    
    (define (truth->either obj . default-objs)
      (if obj (right obj) (raw-left default-objs)))
    
    ;;; These procedures interface between the Maybe protocol and the
    ;;; list-truth protocol, which uses #f to represent failure and a
    ;;; list to represent success.
    
    (define (maybe->list-truth maybe)
      (assume (maybe? maybe))
      (if (just? maybe) (just-objs maybe) #f))
    
    (define (either->list-truth either)
      (assume (either? either))
      (if (right? either) (right-objs either) #f))
    
    ;; If list-or-false is #f, return Nothing.  If it's a list, return a
    ;; Just containing its elements.
    (define (list-truth->maybe list-or-false)
      (if list-or-false
          (begin
            (assume (or (null? list-or-false) (pair? list-or-false)))
            (raw-just list-or-false))
          nothing-obj))
    
    ;; If list-or-false is #f, return a Left of the default objects.
    ;; If it's a list, return a Right containing its elements.
    (define (list-truth->either list-or-false . default-objs)
      (if list-or-false
          (begin
            (assume (or (null? list-or-false) (pair? list-or-false)))
            (raw-right list-or-false))
          (raw-left default-objs)))
    
    ;;; The following procedures interface between the Maybe protocol and
    ;;; the generation protocol, which uses an EOF object to represent
    ;;; failure and any other value to represent success.
    
    ;; If maybe is a Just whose payload is a single value, return that
    ;; value.  If it's a Nothing, return an eof-object.
    (define (maybe->generation maybe)
      (assume (maybe? maybe))
      (if (nothing? maybe)
          (eof-object)
          (begin
            (assume (singleton? (just-objs maybe))
                    "maybe->generation: invalid payload")
            (car (just-objs maybe)))))
    
    ;; If either is a Right whose payload is a single value, return that
    ;; value.  If it's a Left, return an eof-object.
    (define (either->generation either)
      (assume (either? either))
      (if (left? either)
          (eof-object)
          (begin
            (assume (singleton? (right-objs either))
                    "either->generation: invalid payload")
            (car (right-objs either)))))
    
    (define (generation->maybe obj)
      (if (eof-object? obj) nothing-obj (just obj)))
    
    (define (generation->either obj . default-objs)
      (if (eof-object? obj) (raw-left default-objs) (right obj)))
    
    ;;; These procedures interface between the Maybe/Either protocols and
    ;;; the values protocol, which returns one or more values to represent
    ;;; success and zero values to represent failure.
    
    (define (maybe->values maybe)
      (maybe-ref maybe values values))
    
    (define (values->maybe producer)
      (assume (procedure? producer))
      (call-with-values
        producer
        (lambda objs
          (if (null? objs) nothing-obj (raw-just objs)))))
    
    ;;; The following procedures interface between the Maybe protocol and
    ;;; the two-values protocol, which returns |#f, #f| to represent
    ;;; failure and |<any object>, #t| to represent success.
    
    ;; If maybe is Just containing a single value, return that value and #t.
    ;; If it's a Nothing, return |#f, #f|.
    (define (maybe->two-values maybe)
      (assume (maybe? maybe))
      (if (nothing? maybe)
          (values #f #f)
          (begin
            (assume (singleton? (just-objs maybe))
                    "maybe->two-values: invalid payload")
            (values (car (just-objs maybe)) #t))))
    
    (define (two-values->maybe producer)
      (assume (procedure? producer))
      (call-with-values
        producer
        (lambda (obj success)
          (if success (just obj) nothing-obj))))
    
    (define (either->values either)
      (either-ref/default either))
    
    (define (values->either producer . default-objs)
      (assume (procedure? producer))
      (call-with-values
        producer
        (lambda objs
          (if (null? objs) (raw-left default-objs) (raw-right objs)))))
    
    (define (exception->either pred thunk)
      (assume (procedure? pred))
      (assume (procedure? thunk))
      (guard (obj ((pred obj) (left obj)))
             (call-with-values thunk right)))
    
    ;;;; Map, fold, and unfold
    
    ;; If maybe is a Just, apply proc to its payload and wrap the result
    ;; in a Just.  Otherwise, return Nothing.
    (define (maybe-map proc maybe)
      (assume (procedure? proc))
      (assume (maybe? maybe))
      (if (nothing? maybe)
          nothing-obj
          (call-with-values (lambda () (fast-apply proc (just-objs maybe)))
                            just)))
    
    (define (maybe-for-each proc maybe)
      (assume (procedure? proc))
      (maybe-ref maybe (const #f) proc)
      unspecified)
    
    ;; If maybe is a Just, apply kons to its payload values and nil.
    ;; Otherwise, return nil.
    (define (maybe-fold kons nil maybe)
      (assume (procedure? kons))
      (assume (maybe? maybe))
      (if (nothing? maybe)
          nil
          (let ((objs (just-objs maybe)))
            (if (singleton? objs)
                (kons (car objs) nil)
                (apply kons (append objs (list nil)))))))
    
    ;; If the seeds satisfy stop?, return Nothing.  Otherwise, call
    ;; successor on seeds and apply stop? to the results; if stop? returns
    ;; true, apply mapper to seeds and return the results wrapped in a Just.
    (define (maybe-unfold stop? mapper successor . seeds)
      (assume (procedure? stop?))
      (assume (procedure? mapper))
      (if (singleton? seeds)
          (let ((seed (car seeds)))  ; fast path
            (if (stop? seed)
                nothing-obj
                (begin
                  ;; successor might return multiple seeds.
                  (assume (call-with-values (lambda () (successor seed)) stop?))
                  (call-with-values (lambda () (mapper (car seeds))) just))))
          (if (apply stop? seeds)
              nothing-obj
              (begin
                (assume (call-with-values (lambda () (apply successor seeds))
                                          stop?))
                (call-with-values (lambda () (apply mapper seeds)) just)))))
    
    ;; If either is a Right, apply proc to its payload and wrap the result
    ;; in a Right.  Otherwise, return either.
    (define (either-map proc either)
      (assume (procedure? proc))
      (assume (either? either))
      (if (left? either)
          either
          (call-with-values (lambda () (fast-apply proc (right-objs either)))
                            right)))
    
    (define (either-for-each proc either)
      (assume (procedure? proc))
      (either-ref either (const #f) proc)
      unspecified)
    
    ;; If either is a Right, apply kons to its payload values and nil.
    ;; Otherwise, return nil.
    (define (either-fold kons nil either)
      (assume (procedure? kons))
      (assume (either? either))
      (if (left? either)
          nil
          (let ((objs (right-objs either)))
            (if (singleton? objs)
                (kons (car objs) nil)
                (apply kons (append objs (list nil)))))))
    
    ;; If the seeds satisfy stop?, return a Left of seeds.  Otherwise, call
    ;; successor on seeds and apply stop? to the results; if stop? returns
    ;; true, apply mapper to seeds and return the results wrapped in a Right.
    (define (either-unfold stop? mapper successor . seeds)
      (assume (procedure? stop?))
      (assume (procedure? mapper))
      (if (singleton? seeds)
          (let ((seed (car seeds)))  ; fast path
            (if (stop? seed)
                (raw-left seeds)
                (begin
                  ;; successor might return multiple values.
                  (assume (call-with-values (lambda () (successor seed)) stop?))
                  (call-with-values (lambda () (apply mapper seeds)) right))))
          (if (apply stop? seeds)
              (raw-left seeds)
              (begin
                (assume (call-with-values (lambda () (apply successor seeds))
                                          stop?))
                (call-with-values (lambda () (apply mapper seeds)) right)))))
    
    ;;;; Syntax
    
    (define-syntax maybe-if
      (syntax-rules ()
        ((_ maybe-expr just-expr nothing-expr)
          (let ((mval maybe-expr))
            (unless (maybe? mval)
              (error "maybe-if: ill-typed value"))
            (if (just? mval) just-expr nothing-expr)))))
    
    ;; Return the value of expr if it satisfies pred.
    (define-syntax %guard-value
      (syntax-rules ()
        ((_ pred expr)
          (let ((val expr))
            (unless (pred val)
              (error "ill-typed value" pred val))
            val))))
    
    ;; Maybe analog of and.  Evaluate the argument expressions in order.
    ;; If any expression evaluates to Nothing, return it.  Otherwise,
    ;; return the last Just.
    (define-syntax maybe-and
      (syntax-rules ()
        ((_) (just unspecified))
        ((_ maybe-expr) (%guard-value maybe? maybe-expr))
        ((_ maybe-expr maybe-expr* ...)
          (let ((maybe maybe-expr))
            (cond ((just? maybe) (maybe-and maybe-expr* ...))
                  ((nothing? maybe) nothing-obj)
                  (else
                    (error "maybe-and: ill-typed value" maybe? maybe)))))))
    
    ;; Maybe analog of or.  Evaluate the argument expressions in order.
    ;; If any expression evaluates to a Just, return it immediately.
    ;; Otherwise, return Nothing.
    (define-syntax maybe-or
      (syntax-rules ()
        ((_) (nothing))
        ((_ maybe-expr) (%guard-value maybe? maybe-expr))
        ((_ maybe-expr maybe-expr* ...)
          (let ((maybe maybe-expr))
            (cond ((just? maybe) maybe)
                  ((nothing? maybe) (maybe-or maybe-expr* ...))
                  (else
                    (error "maybe-or: ill-typed value" maybe? maybe)))))))
    
    ;; Maybe analog of SRFI 2's and-let*.  Each claw evaluates an expression
    ;; or bound variable to a Maybe, or binds the payload of the value of a
    ;; Maybe expression to a name in later claws and the body.  If any claw
    ;; gives a Nothing, the whole expression evaluates to Nothing.
    (define-syntax maybe-let*
      (syntax-rules ()
        ((_ () expr1 expr2 ...)
          (call-with-values (lambda () expr1 expr2 ...) just))
        ((_ ((id maybe-expr) . claws) . body)
          (let ((maybe maybe-expr))
            (cond ((and (just? maybe) (singleton? (just-objs maybe)))
                    (let ((id (car (just-objs maybe))))
                      (maybe-let* claws . body)))
                  ((nothing? maybe) nothing-obj)
                  (else (error "ill-typed value" maybe? maybe)))))
        ((_ ((maybe-expr) . claws) . body)
          (let ((maybe maybe-expr))
            (cond ((just? maybe) (maybe-let* claws . body))
                  ((nothing? maybe) nothing-obj)
                  (else (error "ill-typed value" maybe? maybe)))))
        ((_ (id . claws) . body)
          (cond ((just? id) (maybe-let* claws . body))
                ((nothing? id) nothing-obj)
                (else (error "ill-typed value" maybe? id))))
        ((_ . _)
          (syntax-error "ill-formed maybe-let* form"))))
    
    ;; Like maybe-let*, but a claw of the form (<formals> <maybe-expr>)
    ;; binds the payload of the value of <maybe-expr> to <formals> in the
    ;; manner of let-values.
    (define-syntax maybe-let*-values
      (syntax-rules ()
        ((_ () expr1 expr2 ...)
          (call-with-values (lambda () expr1 expr2 ...) just))
        ((_ (((id id* ...) maybe-expr) . claws) . body)
          (maybe-bind (%guard-value maybe? maybe-expr)
                      (lambda (id id* ...)
                        (maybe-let*-values claws . body))))
        ((_ ((ids maybe-expr) . claws) . body)
          (maybe-bind (%guard-value maybe? maybe-expr)
                      (lambda ids
                        (maybe-let*-values claws . body))))
        ((_ ((maybe-expr) . claws) . body)
          (let ((maybe maybe-expr))
            (cond ((just? maybe) (maybe-let*-values claws . body))
                  ((nothing? maybe) nothing-obj)
                  (else (error "ill-typed value" maybe? maybe)))))
        ((_ (id . claws) . body)
          (cond ((just? id) (maybe-let*-values claws . body))
                ((nothing? id) nothing-obj)
                (else (error "ill-typed value" maybe? id))))
        ((_ . _)
          (syntax-error "ill-formed maybe-let*-values form"))))
    
    ;; Either analog of and.  Evaluate the argument expressions in order.
    ;; If any expression evaluates to a Left, return it immediately.
    ;; Otherwise, return the last Right.
    (define-syntax either-and
      (syntax-rules ()
        ((_) (right unspecified))
        ((_ either-expr) (%guard-value either? either-expr))
        ((_ either-expr either-expr* ...)
          (let ((either either-expr))
            (cond ((right? either) (either-and either-expr* ...))
                  ((left? either) either)
                  (else (error "ill-typed value" either? either)))))))
    
    ;; Either analog of or.  Evaluate the argument expressions in order.
    ;; If any expression evaluates to a Right, return it immediately.
    ;; Otherwise, return the last Left.
    (define-syntax either-or
      (syntax-rules ()
        ((_) (left unspecified))
        ((_ either-expr) (%guard-value either? either-expr))
        ((_ either-expr either-expr* ...)
          (let ((either either-expr))
            (cond ((right? either) either)
                  ((left? either) (either-or either-expr* ...))
                  (else (error "ill-typed value" either? either)))))))
    
    ;; Either analog of SRFI 2's and-let*.  Each claw evaluates an expression
    ;; or bound variable to a Maybe, or binds the payload of the value of an
    ;; Either expression to a name in later claws and the body.  If any claw
    ;; gives a Left, then the whole expression evaluates to that Left.
    (define-syntax either-let*
      (syntax-rules ()
        ((_ () expr1 expr2 ...)
          (call-with-values (lambda () expr1 expr2 ...) right))
        ((_ ((id either-expr) . claws) . body)
          (let ((either either-expr))
            (cond ((and (right? either) (singleton? (right-objs either)))
                    (let ((id (car (right-objs either))))
                      (either-let* claws . body)))
                  ((left? either) either)
                  (else (error "ill-typed value" either? either)))))
        ((_ ((either-expr) . claws) . body)
          (let ((either either-expr))
            (cond ((right? either) (either-let* claws . body))
                  ((left? either) either)
                  (else (error "ill-typed value" either? either)))))
        ((_ (id . claws) . body)
          (cond ((right? id) (either-let* claws . body))
                ((left? id) id)
                (else (error "ill-typed value" either? either))))
        ((_ . _)
          (syntax-error "ill-formed either-let* form"))))
    
    ;; Like either-let*, but a claw of the form (<formals> <either-expr>)
    ;; binds the payload of the value of <either-expr> to <formals> in the
    ;; manner of let-values.
    (define-syntax either-let*-values
      (syntax-rules ()
        ((_ () expr1 expr2 ...)
          (call-with-values (lambda () expr1 expr2 ...) right))
        ((_ (((id id* ...) either-expr) . claws) . body)
          (either-bind (%guard-value either? either-expr)
                       (lambda (id id* ...)
                         (either-let*-values claws . body))))
        ((_ ((ids either-expr) . claws) . body)
          (either-bind (%guard-value either? either-expr)
                       (lambda ids
                         (either-let*-values claws . body))))
        ((_ ((either-expr) . claws) . body)
          (let ((either either-expr))
            (cond ((right? either) (either-let*-values claws . body))
                  ((left? either) either)
                  (else (error "ill-typed value" either? either)))))
        ((_ (id . claws) . body)
          (cond ((right? id) (either-let*-values claws . body))
                ((left? id) id)
                (else (error "ill-typed value" either? either))))
        ((_ . _)
          (syntax-error "ill-formed either-let*-values form"))))
    
    (define-syntax either-guard
      (syntax-rules ()
        ((_ pred-expr expr1 expr2 ...)
          (exception->either pred-expr (lambda () expr1 expr2 ...)))))
    
    ;;;; Trivalent logic
    
    ;;; In the following procedures, (just #f) is considered to be false.
    ;;; All other Just values are taken to be true.
    
    (define (just->boolean maybe)
      (not (equal? (just-objs maybe) '(#f))))
    
    (define (tri-not maybe)
      (maybe-bind maybe (lambda (x) (just (not x)))))
    
    ;; Returns #t if all arguments are true or all false.  If any argument
    ;; is Nothing or if any two arguments have different (tri-)truth values,
    ;; #f is returned.
    (define (tri=? maybe . ms)
      (let ((make-pred
              (lambda (b)
                (lambda (m)
                  (assume (maybe? m))
                  (and (just? m) (eqv? (just->boolean m) b))))))
        (if (nothing? maybe)
            (just #f)
            (let ((tri-same? (make-pred (just->boolean maybe))))
              (if (every tri-same? ms) (just #t) (just #f))))))
    
    ;; Returns #t if all arguments are true.  If any argument is false or
    ;; Nothing, return the first such object.
    (define (tri-and . maybes)
      (or (find (lambda (m)
                  (assume (maybe? m))
                  (or (nothing? m) (not (just->boolean m))))
                maybes)
          (just #t)))
    
    ;; Returns #f if all arguments are false.  If any argument is true or
    ;; Nothing, return the first such object.
    (define (tri-or . maybes)
      (or (find (lambda (m)
                  (assume (maybe? m))
                  (or (nothing? m) (just->boolean m)))
                maybes)
          (just #f)))
    
    ;; If all arguments are Nothing, then return Nothing.  Otherwise,
    ;; return the first Just value.
    (define (tri-merge . maybes)
      (or (find just? maybes) nothing-obj))
  )
)
;;; SRFI 19
;;; Time data types and procedures
;;;
;;; Points in time are represented a the number of seconds (with nanosecond precision) since
;;; "the epoch," a zero point in time. Several standard variants are defined, including UTC
;;; (universal coordinated time), TAI (international atomic time), and monotonic time.
;;; A point in time can also be represented as a Julian Day or Modified Julian Day number.
;;; Time durations are defined. Conversion routines are provided. The procedure CURRENT-TIME
;;; queries the current time in a specified variant, with a system-dependent resolution.
;;; Procedures for time arithmetic and time comparisons are also provided.
;;; 
;;; A date is a representation of a point in time in the Gregorian calendar, a 24 hour clock
;;; (with nanosecond precision) and a time zone offset from UTC. Procedures for converting
;;; between time and dates are provided, as well as for reading and writing string
;;; representations of dates.
;;;
;;; Author: Will Fitzgerald
;;; Copyright © 2000-2003 I/NET, Inc. All Rights Reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 19)

  (export add-duration
          add-duration!
          copy-time
          current-date
          current-julian-day
          current-modified-julian-day
          current-time
          date?
          date->julian-day
          date->modified-julian-day
          date->string
          date->time-monotonic
          date->time-tai
          date->time-utc
          date-day
          date-hour
          date-minute
          date-month
          date-nanosecond
          date-second
          date-week-day
          date-week-number
          date-year
          date-year-day
          date-zone-offset
          julian-day->date
          julian-day->time-monotonic
          julian-day->time-tai
          julian-day->time-utc
          make-date
          make-time
          modified-julian-day->date
          modified-julian-day->time-monotonic
          modified-julian-day->time-tai
          modified-julian-day->time-utc
          set-time-nanosecond!
          set-time-second!
          set-time-type!
          string->date
          subtract-duration
          subtract-duration!
          time-difference
          time-difference!
          time-duration
          time-monotonic
          time-monotonic->date
          time-monotonic->julian-day
          time-monotonic->modified-julian-day
          time-monotonic->time-tai
          time-monotonic->time-tai!
          time-monotonic->time-utc
          time-monotonic->time-utc!
          time-nanosecond
          time-resolution
          time-second
          time-tai
          time-tai->date
          time-tai->julian-day
          time-tai->modified-julian-day
          time-tai->time-monotonic
          time-tai->time-monotonic!
          time-tai->time-utc
          time-tai->time-utc!
          time-type
          time-utc
          time-utc->date
          time-utc->julian-day
          time-utc->modified-julian-day
          time-utc->time-monotonic
          time-utc->time-monotonic!
          time-utc->time-tai
          time-utc->time-tai!
          time?
          time<?
          time<=?
          time=?
          time>?
          time>=?)
  
  (import (lispkit base))

  (begin
  
    ;; -- Bug fixes.
    ;;
    ;; MAKE-TIME had parameters seconds and nanoseconds reversed; change all
    ;;           references in file to match.  Will F: 2002-10-15
    ;;
    ;; DATE-YEAR-DAY returned the wrong day; tm:year-day fixed to do the right
    ;;               thing. Will F: 2002-10-15
    ;;               It also called an undefined error procedure.
    ;;
    ;; DISPLAYING procedure removed. Will F: 2002-10-15.
    ;;
    ;; TM:NANO constant corrected. 2002-11-04.
    ;;
    ;; The following fixes by Will Fitzgerald, February, 2003.
    ;;  -- Thanks to Steven Ma and others.
    ;;
    ;; (CURRENT-TIME 'TIME-THREAD) added.
    ;;
    ;; TIME-RESOLUTION for TIME-PROCESS added. 
    ;;
    ;; TIME comparison procedures (time=?, etc. fixed. 
    ;;
    ;; Corrected errors in converting between TAI and UTC time.
    ;;
    ;; TAI and UTC date converters no longer look at leap seconds,
    ;; which was an error.
    ;;
    ;; corrections to calls to tm:time-error
    ;;
    ;; timezone offset not used in date->time-utc and date->julian-day
    ;;
    ;; typos in tm:integer-reader-exact, tm:string->date,
    ;; time-monotonic->time-utc!, tm:char->int fixed
    ;;
    ;; corrected "~k", "~f" formatting for date->string (includes fix for
    ;; "~4"
    ;;
    ;; 'split-real' fixed.
    ;;
    ;; fixed julian-day->time-utc and variants.
    ;;
    ;; changes 2003-02-26, based on comments by Martin Gasbichler.
    ;; 
    ;; moronic, overly complicated COPY-TIME procedure changed
    ;; to simple version suggested by Martin Gasbichler.
    ;;
    ;; To provide more portability, changed #\Space to #\space
    ;; and #\tab to #\Tab to (integer->char 9)
    ;;
    ;; changed arity-3 calls to / and - to arity 2 calls (again,
    ;; for more general portability). 
    ;;
    ;; split-real fixed again -- by removing it, and using
    ;; 'fractional part'. Will Fitzgerald 5/16/2003.

    (define time-tai       'time-tai)
    (define time-utc       'time-utc)
    (define time-monotonic 'time-monotonic)
    (define time-duration  'time-duration)

    ;;-- LOCALE dependent constants

    (define tm:locale-number-separator ".")

    (define tm:locale-abbr-weekday-vector (vector "Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"))

    (define tm:locale-long-weekday-vector (vector "Sunday" "Monday" "Tuesday" "Wednesday"
                                                  "Thursday" "Friday" "Saturday"))

    ;; note empty string in 0th place. 
    (define tm:locale-abbr-month-vector   (vector "" "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul"
                                                  "Aug" "Sep" "Oct" "Nov" "Dec"))

    (define tm:locale-long-month-vector   (vector "" "January" "February" "March" "April" "May"
                                                  "June" "July" "August" "September" "October"
                                                  "November" "December")) 

    (define tm:locale-am "am")
    (define tm:locale-pm "pm")

    ;; See date->string
    (define tm:locale-date-time-format "~a ~b ~d ~H:~M:~S~z ~Y")
    (define tm:locale-short-date-format "~m/~d/~y")
    (define tm:locale-time-format "~H:~M:~S")
    (define tm:iso-8601-date-time-format "~Y-~m-~dT~H:~M:~S~z")
    (define tm:uk-short-date-format "~d/~m/~y")
    (define tm:uk-short-date-time-format "~d/~m/~Y ~H:~M")

    ;;-- Miscellaneous Constants.
    ;;-- only the tm:tai-epoch-in-jd might need changing if a different epoch is used.

    (define tm:nano            (expt 10 9))
    (define tm:sid             86400)      ; seconds in a day
    (define tm:sihd            43200)      ; seconds in a half day
    (define tm:tai-epoch-in-jd 4881175/2)  ; julian day number for 'the epoch'

    ;; A table of leap seconds
    ;; See ftp://maia.usno.navy.mil/ser7/tai-utc.dat
    ;; and update as necessary.
    ;; This procedures reads the file in the abover format and creates the leap second table.
    ;; It also calls the almost standard, but not R5 procedures read-line & open-input-string
    ;; ie (set! tm:leap-second-table (tm:read-tai-utc-date "tai-utc.dat"))
    
    (define (tm:read-tai-utc-data filename)
      (let ((convert-jd (lambda (jd) (* (- (exact jd) tm:tai-epoch-in-jd) tm:sid)))
            (port (open-input-file filename))
            (table '()))
        (let loop ((line (read-line port)))
          (if (eof-object? line)
              table
              (begin (let* ((data (read (open-input-string (string-append "(" line ")"))))
                            (year (car data))
                            (jd   (cadddr (cdr data)))
                            (secs (cadddr (cdddr data))))
                       (if (>= year 1972)
                           (set! table (cons (cons (convert-jd jd) (exact secs)) table)))
                           (loop (read-line port))))))))

    ;; each entry is (utc seconds since epoch . # seconds to add for tai)
    ;; note they go higher to lower, and end in 1972.
    (define tm:leap-second-table
      '((1483228800 . 37)
        (1435708800 . 36)
        (1341100800 . 35)
        (1230768000 . 34)
        (1136073600 . 33)
         (915148800 . 32)
         (867715200 . 31)
         (820454400 . 30)
         (773020800 . 29)
         (741484800 . 28)
         (709948800 . 27)
         (662688000 . 26)
         (631152000 . 25)
         (567993600 . 24)
         (489024000 . 23)
         (425865600 . 22)
         (394329600 . 21)
         (362793600 . 20)
         (315532800 . 19)
         (283996800 . 18)
         (252460800 . 17)
         (220924800 . 16)
         (189302400 . 15)
         (157766400 . 14)
         (126230400 . 13)
          (94694400 . 12)
          (78796800 . 11)
          (63072000 . 10)))

    (define (read-leap-second-table filename)
      (set! tm:leap-second-table (tm:read-tai-utc-data filename)))

    (define (tm:leap-second-delta utc-seconds)
      (letrec ((lsd (lambda (table)
                      (if (>= utc-seconds (caar table))
                          (cdar table)
                          (lsd (cdr table))))))
        (if (< utc-seconds (* (- 1972 1970) 365 tm:sid))
            0
            (lsd tm:leap-second-table))))

    ;; going from tai seconds to utc seconds

    (define (tm:leap-second-neg-delta tai-seconds)
      (letrec ((lsd (lambda (table)
                      (cond ((null? table)                                  0)
                            ((<= (cdar table) (- tai-seconds (caar table))) (cdar table))
                            (else                                           (lsd (cdr table)))))))
        (if (< tai-seconds (* (- 1972 1970) 365 tm:sid))
            0
            (lsd tm:leap-second-table))))

    ;;; the time structure

    (define-record-type <time>
      (make-time type nanosecond second)
      time?
      (type time-type set-time-type!)
      (nanosecond time-nanosecond set-time-nanosecond!)
      (second time-second set-time-second!))

    ;; thanks, Martin Gasbichler ...

    (define (copy-time time)
      (make-time (time-type time)
                 (time-nanosecond time)
                 (time-second time)))

    ;;; specific time getters.
    ;;; these should be rewritten to be os specific.
    ;;
    ;; -- using gnu gettimeofday() would be useful here -- gets
    ;;    second + millisecond 
    ;;    let's pretend we do, using mzscheme's current-seconds & current-milliseconds
    ;;    this is supposed to return utc.
    ;; 

    (define (tm:get-time-of-day)
      (let ((cursec (current-second)))
        (cons (exact (truncate cursec))
              (abs (remainder (exact (truncate (* cursec 1000.0))) 1000)))))

    (define (tm:current-time-utc)
      (let ((tod (tm:get-time-of-day)))
        (make-time time-utc (* (cdr tod) 10000) (car tod))))

    (define (tm:current-time-tai)
      (let ((tod (tm:get-time-of-day)))
        (make-time time-tai (* (cdr tod) 10000) (+ (car tod) (tm:leap-second-delta (car tod))))))

    (define (tm:current-time-ms-time time-type proc)
      (let ((current-ms (proc)))
        (make-time time-type (* (remainder current-ms 1000) 10000) (quotient current-ms 10000))))

    ;; -- we define it to be the same as tai.
    ;;    a different implemation of current-time-montonic will require rewriting all of the
    ;;    time-monotonic converters, of course.

    (define (tm:current-time-monotonic)
      (let ((tod (tm:get-time-of-day)))
        (make-time time-monotonic (* (cdr tod) 10000)
                                  (+ (car tod) (tm:leap-second-delta (car tod))))))
    
    (define (current-time . clock-type)
      (cond ((null? clock-type)
              (tm:current-time-utc))
            ((eq? (car clock-type) time-tai)
              (tm:current-time-tai))
            ((eq? (car clock-type) time-utc)
              (tm:current-time-utc))
            ((eq? (car clock-type) time-monotonic)
              (tm:current-time-monotonic))
            (else
              (error "current-time: invalid clock type" (car clock-type)))))

    ;; -- time resolution
    ;; this is the resolution of the clock in nanoseconds.
    ;; this will be implementation specific.

    (define (time-resolution . clock-type)
      (cond ((null? clock-type) ; utc
              10000)
            ((eq? (car clock-type) time-tai)
              10000)
            ((eq? (car clock-type) time-utc)
              10000)
            ((eq? (car clock-type) time-monotonic)
              10000)
            (else
              (error "time-resolution: invalid clock type" clock-type))))

    ;; -- time comparisons

    (define (tm:time-compare-check time1 time2 caller)
      (if (or (not (and (time? time1) (time? time2)))
              (not (eq? (time-type time1) (time-type time2))))
          (error (string-append caller ": incompatible time types") time1 time2)))

    (define (time=? time1 time2)
      (tm:time-compare-check time1 time2 "time=?")
      (and (= (time-second time1) (time-second time2))
           (= (time-nanosecond time1) (time-nanosecond time2))))

    (define (time>? time1 time2)
      (tm:time-compare-check time1 time2 "time>")
      (or (> (time-second time1) (time-second time2))
          (and (= (time-second time1) (time-second time2))
               (> (time-nanosecond time1) (time-nanosecond time2)))))

    (define (time<? time1 time2)
      (tm:time-compare-check time1 time2 "time<")
      (or (< (time-second time1) (time-second time2))
          (and (= (time-second time1) (time-second time2))
               (< (time-nanosecond time1) (time-nanosecond time2)))))

    (define (time>=? time1 time2)
      (tm:time-compare-check time1 time2 "time>=")
      (or (> (time-second time1) (time-second time2))
          (and (= (time-second time1) (time-second time2))
               (>= (time-nanosecond time1) (time-nanosecond time2)))))

    (define (time<=? time1 time2)
      (tm:time-compare-check time1 time2 "time<=")
      (or (< (time-second time1) (time-second time2))
          (and (= (time-second time1) (time-second time2))
               (<= (time-nanosecond time1) (time-nanosecond time2)))))

    ;; -- time arithmetic

    (define (tm:time->nanoseconds time)
      (+ (* (time-second time) tm:nano) (time-nanosecond time)))

    (define (tm:nanoseconds->time time-type nanoseconds)
      (make-time time-type
                 (remainder nanoseconds tm:nano)
                 (quotient nanoseconds tm:nano)))

    (define (tm:time-difference time1 time2 time3)
      (if (or (not (and (time? time1) (time? time2)))
              (not (eq? (time-type time1) (time-type time2))))
          (error "time-difference: incompatible time types" time1 time2))
      (set-time-type! time3 time-duration)
      (if (time=? time1 time2)
          (begin (set-time-second! time3 0)
                 (set-time-nanosecond! time3 0))
          (let ((nanoseconds (- (tm:time->nanoseconds time1) (tm:time->nanoseconds time2))))
            (set-time-second! time3 (quotient nanoseconds tm:nano))
            (set-time-nanosecond! time3 (abs (remainder nanoseconds tm:nano)))))
      time3)

    (define (time-difference time1 time2)
      (tm:time-difference time1 time2 (make-time #f #f #f)))

    (define (time-difference! time1 time2)
      (tm:time-difference time1 time2 time1))

    (define (tm:add-duration time1 duration time3)
      (if (not (and (time? time1) (time? duration)))
          (error "tm:add-duration: incompatible time types" time1 duration))
      (if (not (eq? (time-type duration) time-duration))
          (error "tm:add-duration: not a duration" duration)
          (let* ((sec-plus  (+ (time-second time1) (time-second duration)))
                 (nsec-plus (+ (time-nanosecond time1) (time-nanosecond duration)))
                 (r (remainder nsec-plus tm:nano))
                 (q (quotient nsec-plus tm:nano)))
            ; (set-time-type! time3 (time-type time1))
            (if (negative? r)
                (begin (set-time-second! time3 (+ sec-plus q -1))
                       (set-time-nanosecond! time3 (+ tm:nano r)))
                (begin (set-time-second! time3 (+ sec-plus q))
                       (set-time-nanosecond! time3 r)))
            time3)))

    (define (add-duration time1 duration)
      (tm:add-duration time1 duration (make-time (time-type time1) #f #f)))

    (define (add-duration! time1 duration)
      (tm:add-duration time1 duration time1))

    (define (tm:subtract-duration time1 duration time3)
      (if (not (and (time? time1) (time? duration)))
          (error "tm:subtract-duration: incompatible time types" time1 duration))
      (if (not (eq? (time-type duration) time-duration))
          (error "tm:subtract-duration: not a duration" duration)
          (let* ((sec-minus  (- (time-second time1) (time-second duration)))
                 (nsec-minus (- (time-nanosecond time1) (time-nanosecond duration)))
                 (r (remainder nsec-minus tm:nano))
                 (q (quotient nsec-minus tm:nano)))
            (if (negative? r)
                (begin (set-time-second! time3 (- sec-minus q 1))
                       (set-time-nanosecond! time3 (+ tm:nano r)))
                (begin (set-time-second! time3 (- sec-minus q))
                       (set-time-nanosecond! time3 r)))
            time3)))

    (define (subtract-duration time1 duration)
      (tm:subtract-duration time1 duration (make-time (time-type time1) #f #f)))

    (define (subtract-duration! time1 duration)
      (tm:subtract-duration time1 duration time1))

    ;; -- converters between types

    (define (tm:time-tai->time-utc! time-in time-out caller)
      (if (not (eq? (time-type time-in) time-tai))
          (error (string-append caller ": expected time to be of type tai") time-in))
      (set-time-type!       time-out time-utc)
      (set-time-nanosecond! time-out (time-nanosecond time-in))
      (set-time-second!     time-out (- (time-second time-in)
                                        (tm:leap-second-neg-delta (time-second time-in))))
      time-out)

    (define (time-tai->time-utc time-in)
      (tm:time-tai->time-utc! time-in (make-time #f #f #f) "time-tai->time-utc"))

    (define (time-tai->time-utc! time-in)
      (tm:time-tai->time-utc! time-in time-in "time-tai->time-utc!"))

    (define (tm:time-utc->time-tai! time-in time-out caller)
      (if (not (eq? (time-type time-in) time-utc))
          (error (string-append caller ": expected time to be of type utc") time-in))
      (set-time-type!       time-out time-tai)
      (set-time-nanosecond! time-out (time-nanosecond time-in))
      (set-time-second!     time-out (+ (time-second time-in)
                                        (tm:leap-second-delta (time-second time-in))))
      time-out)

    (define (time-utc->time-tai time-in)
      (tm:time-utc->time-tai! time-in (make-time #f #f #f) "time-utc->time-tai"))

    (define (time-utc->time-tai! time-in)
      (tm:time-utc->time-tai! time-in time-in "time-utc->time-tai!"))

    ;; -- these depend on time-monotonic having the same definition as time-tai!

    (define (time-monotonic->time-utc time-in)
      (if (not (eq? (time-type time-in) time-monotonic))
          (error (string-append caller ": expected time to be of type monotonic") time-in))
      (let ((ntime (copy-time time-in)))
        (set-time-type! ntime time-tai)
        (tm:time-tai->time-utc! ntime ntime "time-monotonic->time-utc")))

    (define (time-monotonic->time-utc! time-in)
      (if (not (eq? (time-type time-in) time-monotonic))
          (error "time-monotonic->time-utc!: expected time to be of type monotonic" time-in))
      (set-time-type! time-in time-tai)
      (tm:time-tai->time-utc! time-in time-in "time-monotonic->time-utc"))

    (define (time-monotonic->time-tai time-in)
      (if (not (eq? (time-type time-in) time-monotonic))
          (error "time-monotonic->time-tai: expected time to be of type monotonic" time-in))
      (let ((ntime (copy-time time-in)))
        (set-time-type! ntime time-tai)
        ntime))

    (define (time-monotonic->time-tai! time-in)
      (if (not (eq? (time-type time-in) time-monotonic))
          (error "time-monotonic->time-tai!: expected time to be of type monotonic" time-in))
      (set-time-type! time-in time-tai)
      time-in)

    (define (time-utc->time-monotonic time-in)
      (if (not (eq? (time-type time-in) time-utc))
          (error "time-utc->time-monotonic: expected time to be of type utc" time-in))
      (let ((ntime (tm:time-utc->time-tai! time-in
                                           (make-time #f #f #f)
                                           "time-utc->time-monotonic")))
        (set-time-type! ntime time-monotonic)
        ntime))

    (define (time-utc->time-monotonic! time-in)
      (if (not (eq? (time-type time-in) time-utc))
          (error "time-utc->time-monotonic!: expected time to be of type utc" time-in))
      (let ((ntime (tm:time-utc->time-tai! time-in time-in "time-utc->time-monotonic!")))
        (set-time-type! ntime time-monotonic)
        ntime))

    (define (time-tai->time-monotonic time-in)
      (if (not (eq? (time-type time-in) time-tai))
          (error "time-tai->time-monotonic: expected time to be of type tai" time-in))
      (let ((ntime (copy-time time-in)))
        (set-time-type! ntime time-monotonic)
        ntime))

    (define (time-tai->time-monotonic! time-in)
      (if (not (eq? (time-type time-in) time-tai))
          (error "time-tai->time-monotonic!: expected time to be of type tai" time-in))
      (set-time-type! time-in time-monotonic)
      time-in)

    ;; -- date structures

    (define-record-type <date>
      (make-date nanosecond second minute hour day month year zone-offset)
      date?
      (nanosecond  date-nanosecond  tm:set-date-nanosecond!)
      (second      date-second      tm:set-date-second!)
      (minute      date-minute      tm:set-date-minute!)
      (hour        date-hour        tm:set-date-hour!)
      (day         date-day         tm:set-date-day!)
      (month       date-month       tm:set-date-month!)
      (year        date-year        tm:set-date-year!)
      (zone-offset date-zone-offset tm:set-date-zone-offset!))

    ;; gives the julian day which starts at noon.
    (define (tm:encode-julian-day-number day month year)
      (let* ((a (quotient (- 14 month) 12))
             (y (- (- (+ year 4800) a) (if (negative? year) -1 0)))
             (m (- (+ month (* 12 a)) 3)))
        (+ day
           (quotient (+ (* 153 m) 2) 5)
           (* 365 y)
           (quotient y 4)
           (- (quotient y 100))
           (quotient y 400)
           -32045)))

    (define (tm:char-pos char str index len)
      (cond ((>= index len)                       #f)
            ((char=? (string-ref str index) char) index)
            (else                                 (tm:char-pos char str (+ index 1) len))))

    (define (tm:fractional-part r)
      (if (integer? r)
          "0"
          (let* ((str (number->string (exact->inexact r)))
                 (ppos (tm:char-pos #\. str 0 (string-length str))))
            (substring str (+ ppos 1) (string-length str)))))

    ;; gives the seconds/date/month/year 
    (define (tm:decode-julian-day-number jdn)
      (let* ((days (truncate jdn))
             (a (+ days 32044))
             (b (quotient (+ (* 4 a) 3) 146097))
             (c (- a (quotient (* 146097 b) 4)))
             (d (quotient (+ (* 4 c) 3) 1461))
             (e (- c (quotient (* 1461 d) 4)))
             (m (quotient (+ (* 5 e) 2) 153))
             (y (+ (* 100 b) d -4800 (quotient m 10))))
        (list ; seconds date month year
          (* (- jdn days) tm:sid)
          (+ e (- (quotient (+ (* 153 m) 2) 5)) 1)
          (+ m 3 (* -12 (quotient m 10)))
          (if (>= 0 y) (- y 1) y))))

    ;; tm:local-tz-offset reports the number of seconds east of UTC (GMT) for the current time
    ;; zone (e.g., Pacific Standard Time is -28800), including any daylight-saving adjustment
    ;; (e.g., Pacific Daylight Time is -25200). Without argument, it returns the default
    ;; defined by the system. The argument overrides this default if provided.
    (define (tm:local-tz-offset . tzarg)
      (if (or (null? tzarg) (null? (car tzarg))) (seconds-from-gmt) (caar tzarg)))

    ;; special thing -- ignores nanos
    (define (tm:time->julian-day-number seconds tz-offset)
      (+ (/ (+ seconds tz-offset tm:sihd) tm:sid) tm:tai-epoch-in-jd))

    (define (tm:find proc l)
      (if (null? l) #f (if (proc (car l)) #t (tm:find proc (cdr l)))))

    (define (tm:tai-before-leap-second? second)
      (tm:find (lambda (x) (= second (- (+ (car x) (cdr x)) 1))) tm:leap-second-table))

    (define (tm:time->date time tz-offset ttype)
      (if (not (eq? (time-type time) ttype))
          (error "tm:time->date: incompatible time type" time ttype))
      (let ((offset (tm:local-tz-offset tz-offset)))
        (apply (lambda (secs date month year)
                 (let* ((hrs (quotient secs 3600))
                        (rem (remainder secs 3600))
                        (min (quotient rem 60))
                        (sec (remainder rem 60)))
                   (make-date (time-nanosecond time) sec min hrs date month year offset)))
               (tm:decode-julian-day-number
                 (tm:time->julian-day-number (time-second time) offset)))))

    (define (time-tai->date time . tz-offset)
      (if (tm:tai-before-leap-second? (time-second time))
          ;; if it's *right* before the leap, we need to pretend to subtract a second ...
          (let ((d (tm:time->date (subtract-duration! (time-tai->time-utc time)
                                                      (make-time time-duration 0 1))
                                  tz-offset time-utc)))
               (tm:set-date-second! d 60)
               d)
          (tm:time->date (time-tai->time-utc time) tz-offset time-utc)))

    (define (time-utc->date time . tz-offset)
      (tm:time->date time tz-offset time-utc))

    ;; again, time-monotonic is the same as time tai
    (define (time-monotonic->date time . tz-offset)
      (tm:time->date time tz-offset time-monotonic))

    (define (date->time-utc date)
      (let ((nanosecond (date-nanosecond date))
            (second (date-second date))
            (minute (date-minute date))
            (hour (date-hour date))
            (day (date-day date))
            (month (date-month date))
            (year (date-year date))
            (offset (date-zone-offset date)))
        (let ((jdays (- (tm:encode-julian-day-number day month year) tm:tai-epoch-in-jd)))
          (make-time time-utc
                     nanosecond
                     (+ (* (- jdays 1/2) 24 60 60)
                        (* hour 60 60)
                        (* minute 60)
                        second
                        (- offset))))))

    (define (date->time-tai d)
      (if (= (date-second d) 60)
          (subtract-duration! (time-utc->time-tai! (date->time-utc d))
                              (make-time time-duration 0 1))
          (time-utc->time-tai! (date->time-utc d))))

    (define (date->time-monotonic date)
      (time-utc->time-monotonic! (date->time-utc date)))

    (define (tm:leap-year? year)
      (or (= (modulo year 400) 0) (and (= (modulo year 4) 0) (not (= (modulo year 100) 0)))))

    (define (leap-year? date)
      (tm:leap-year? (date-year date)))

    ;; tm:year-day fixed: adding wrong number of days.
    (define  tm:month-assoc '((0 . 0) (1 . 31)  (2 . 59)   (3 . 90)   (4 . 120) 
                              (5 . 151) (6 . 181)  (7 . 212)  (8 . 243)
                              (9 . 273) (10 . 304) (11 . 334)))

    (define (tm:year-day day month year)
      (let ((days-pr (assoc (- month 1) tm:month-assoc)))
        (if (not days-pr)
            (error "tm:date-year-day: invalid month" month))
        (if (and (tm:leap-year? year) (> month 2))
            (+ day (cdr days-pr) 1)
            (+ day (cdr days-pr)))))

    (define (date-year-day date)
      (tm:year-day (date-day date) (date-month date) (date-year date)))

    ;; from calendar faq 
    (define (tm:week-day day month year)
      (let* ((a (quotient (- 14 month) 12))
             (y (- year a))
             (m (+ month (* 12 a) -2)))
        (modulo (+ day y (quotient y 4) (- (quotient y 100))
                   (quotient y 400) (quotient (* 31 m) 12))
                7)))

    (define (date-week-day date)
      (tm:week-day (date-day date) (date-month date) (date-year date)))

    (define (tm:days-before-first-week date day-of-week-starting-week)
      (let* ((first-day  (make-date 0 0 0 0 1 1 (date-year date) #f))
             (fdweek-day (date-week-day first-day)))
        (modulo (- day-of-week-starting-week fdweek-day) 7)))

    (define (date-week-number date day-of-week-starting-week)
      (quotient (- (date-year-day date)
                   (tm:days-before-first-week date day-of-week-starting-week)) 7))

    (define (current-date . tz-offset) 
      (time-utc->date (current-time time-utc) (tm:local-tz-offset tz-offset)))

    ;; given a 'two digit' number, find the year within 50 years +/-
    (define (tm:natural-year n)
      (let* ((current-year (date-year (current-date)))
             (current-century (* (quotient current-year 100) 100)))
        (cond ((>= n 100)                                     n)
              ((<  n 0)                                       n)
              ((<= (- (+ current-century n) current-year) 50) (+ current-century n))
              (else                                           (+ (- current-century 100) n)))))

    (define (date->julian-day date)
      (let ((nanosecond (date-nanosecond date))
            (second (date-second date))
            (minute (date-minute date))
            (hour (date-hour date))
            (day (date-day date))
            (month (date-month date))
            (year (date-year date))
            (offset (date-zone-offset date)))
        (+ (tm:encode-julian-day-number day month year)
           (- 1/2)
           (+ (/ (/ (+ (* hour 60 60)
           (* minute 60) second (/ nanosecond tm:nano)) tm:sid)
           (- offset))))))

    (define (date->modified-julian-day date)
      (- (date->julian-day date) 4800001/2))

    (define (time-utc->julian-day time)
      (if (not (eq? (time-type time) time-utc))
          (error "time-utc->julian-day: expected time in utc" time))
      (+ (/ (+ (time-second time) (/ (time-nanosecond time) tm:nano)) tm:sid) tm:tai-epoch-in-jd))

    (define (time-utc->modified-julian-day time)
      (- (time-utc->julian-day time) 4800001/2))

    (define (time-tai->julian-day time)
      (if (not (eq? (time-type time) time-tai))
          (error "time-tai->julian-day: expected time in tai" time))
      (+ (/ (+ (- (time-second time) (tm:leap-second-delta (time-second time)))
               (/ (time-nanosecond time) tm:nano))
            tm:sid)
         tm:tai-epoch-in-jd))

    (define (time-tai->modified-julian-day time)
      (- (time-tai->julian-day time) 4800001/2))

    ;; this is the same as time-tai->julian-day
    (define (time-monotonic->julian-day time)
      (if (not (eq? (time-type time) time-monotonic))
          (error "time-monotonic->julian-day: expected time in monotonic" time))
      (+ (/ (+ (- (time-second time) (tm:leap-second-delta (time-second time)))
               (/ (time-nanosecond time) tm:nano))
            tm:sid)
         tm:tai-epoch-in-jd))

    (define (time-monotonic->modified-julian-day time)
      (- (time-monotonic->julian-day time) 4800001/2))

    (define (julian-day->time-utc jdn)
      (let ((nanosecs (* tm:nano tm:sid (- jdn tm:tai-epoch-in-jd))))
        (make-time time-utc (remainder nanosecs tm:nano) (floor (/ nanosecs tm:nano)))))

    (define (julian-day->time-tai jdn)
      (time-utc->time-tai! (julian-day->time-utc jdn)))

    (define (julian-day->time-monotonic jdn)
      (time-utc->time-monotonic! (julian-day->time-utc jdn)))

    (define (julian-day->date jdn . tz-offset)
      (time-utc->date (julian-day->time-utc jdn) (tm:local-tz-offset tz-offset)))

    (define (modified-julian-day->date jdn . tz-offset)
      (julian-day->date (+ jdn 4800001/2) (tm:local-tz-offset tz-offset)))

    (define (modified-julian-day->time-utc jdn)
      (julian-day->time-utc (+ jdn 4800001/2)))

    (define (modified-julian-day->time-tai jdn)
      (julian-day->time-tai (+ jdn 4800001/2)))

    (define (modified-julian-day->time-monotonic jdn)
      (julian-day->time-monotonic (+ jdn 4800001/2)))

    (define (current-julian-day)
      (time-utc->julian-day (current-time time-utc)))

    (define (current-modified-julian-day)
      (time-utc->modified-julian-day (current-time time-utc)))
  
    ;; returns a string rep. of number N, of minimum LENGTH,
    ;; padded with character PAD-WITH. If PAD-WITH is #f, 
    ;; no padding is done, and it's as if number->string was used.
    ;; if string is longer than LENGTH, it's as if number->string was used.

    (define (tm:padding n pad-with length)
      (let* ((str (number->string n))
             (str-len (string-length str)))
        (if (or (>= str-len length) (not pad-with))
            str
            (string-append (make-string (- length str-len) pad-with) str))))

    (define (tm:last-n-digits i n)
      (abs (remainder i (expt 10 n))))

    (define (tm:locale-abbr-weekday n) 
      (vector-ref tm:locale-abbr-weekday-vector n))

    (define (tm:locale-long-weekday n)
      (vector-ref tm:locale-long-weekday-vector n))

    (define (tm:locale-abbr-month n)
      (vector-ref tm:locale-abbr-month-vector n))

    (define (tm:locale-long-month n)
      (vector-ref tm:locale-long-month-vector n))

    (define (tm:vector-find needle haystack comparator)
      (let ((len (vector-length haystack)))
        (let loop ((index 0))
          (cond ((>= index len)                                  #f)
                ((comparator needle (vector-ref haystack index)) index)
                (else                                            (loop (+ index 1)))))))

    (define (tm:locale-abbr-weekday->index string)
      (tm:vector-find string tm:locale-abbr-weekday-vector string=?))

    (define (tm:locale-long-weekday->index string)
      (tm:vector-find string tm:locale-long-weekday-vector string=?))

    (define (tm:locale-abbr-month->index string)
      (tm:vector-find string tm:locale-abbr-month-vector string=?))

    (define (tm:locale-long-month->index string)
      (tm:vector-find string tm:locale-long-month-vector string=?))

    ;; do nothing. 
    ;; Your implementation might want to do something...
    ;; 
    (define (tm:locale-print-time-zone date port)
      (void))

    ;; Again, locale specific.
    (define (tm:locale-am/pm hr)
      (if (> hr 11) tm:locale-pm tm:locale-am))

    (define (tm:tz-printer offset port)
      (cond ((= offset 0)       (display "Z" port))
            ((negative? offset) (display "-" port))
            (else               (display "+" port)))
      (if (not (= offset 0))
          (let ((hours (abs (quotient offset (* 60 60))))
                (minutes (abs (quotient (remainder offset (* 60 60)) 60))))
            (display (tm:padding hours #\0 2) port)
            (display (tm:padding minutes #\0 2) port))))

    ;; A table of output formatting directives.
    ;; the first time is the format char.
    ;; the second is a procedure that takes the date, a padding character
    ;; (which might be #f), and the output port.
    ;;
    (define tm:directives 
      (list
        (cons #\~ (lambda (date pad-with port) (display #\~ port)))
        (cons #\a (lambda (date pad-with port)
                    (display (tm:locale-abbr-weekday (date-week-day date)) port)))
        (cons #\A (lambda (date pad-with port)
                    (display (tm:locale-long-weekday (date-week-day date)) port)))
        (cons #\b (lambda (date pad-with port)
                    (display (tm:locale-abbr-month (date-month date)) port)))
        (cons #\B (lambda (date pad-with port)
                    (display (tm:locale-long-month (date-month date)) port)))
        (cons #\c (lambda (date pad-with port)
                    (display (date->string date tm:locale-date-time-format) port)))
        (cons #\d (lambda (date pad-with port)
                    (display (tm:padding (date-day date) #\0 2) port)))
        (cons #\D (lambda (date pad-with port)
                    (display (date->string date "~m/~d/~y") port)))
        (cons #\e (lambda (date pad-with port)
                    (display (tm:padding (date-day date) #\space 2) port)))
        (cons #\f (lambda (date pad-with port)
                    (if (> (date-nanosecond date) tm:nano)
                        (display (tm:padding (+ (date-second date) 1) pad-with 2) port)
                        (display (tm:padding (date-second date) pad-with 2) port))
                    (let* ((ns (tm:fractional-part (/ (date-nanosecond date) tm:nano 1.0)))
                           (le (string-length ns)))
                      (if (> le 2)
                          (begin (display tm:locale-number-separator port)
                                 (display (substring ns 2 le) port))))))
        (cons #\h (lambda (date pad-with port) (display (date->string date "~b") port)))
        (cons #\H (lambda (date pad-with port)
                    (display (tm:padding (date-hour date) pad-with 2) port)))
        (cons #\I (lambda (date pad-with port)
                    (let ((hr (date-hour date)))
                      (if (> hr 12)
                          (display (tm:padding (- hr 12) pad-with 2) port)
                          (display (tm:padding hr pad-with 2) port)))))
        (cons #\j (lambda (date pad-with port)
                    (display (tm:padding (date-year-day date) pad-with 3) port)))
        (cons #\k (lambda (date pad-with port)
                    (display (tm:padding (date-hour date) #\0 2) port)))
        (cons #\l (lambda (date pad-with port)
                    (let ((hr (if (> (date-hour date) 12)
                                  (- (date-hour date) 12)
                                  (date-hour date))))
                      (display (tm:padding hr  #\space 2) port))))
        (cons #\m (lambda (date pad-with port)
                    (display (tm:padding (date-month date) pad-with 2) port)))
        (cons #\M (lambda (date pad-with port)
                    (display (tm:padding (date-minute date) pad-with 2) port)))
        (cons #\n (lambda (date pad-with port) (newline port)))
        (cons #\N (lambda (date pad-with port)
                    (display (tm:padding (date-nanosecond date) pad-with 9) port)))
        (cons #\p (lambda (date pad-with port) (display (tm:locale-am/pm (date-hour date)) port)))
        (cons #\r (lambda (date pad-with port) (display (date->string date "~I:~M:~S ~p") port)))
        (cons #\s (lambda (date pad-with port) (display (time-second (date->time-utc date)) port)))
        (cons #\S (lambda (date pad-with port)
                    (if (> (date-nanosecond date) tm:nano)
                        (display (tm:padding (+ (date-second date) 1) pad-with 2) port)
                        (display (tm:padding (date-second date) pad-with 2) port))))
        (cons #\t (lambda (date pad-with port) (display (integer->char 9) port)))
        (cons #\T (lambda (date pad-with port) (display (date->string date "~H:~M:~S") port)))
        (cons #\U (lambda (date pad-with port)
                    (if (> (tm:days-before-first-week date 0) 0)
                        (display (tm:padding (+ (date-week-number date 0) 1) #\0 2) port)
                        (display (tm:padding (date-week-number date 0) #\0 2) port))))
        (cons #\V (lambda (date pad-with port)
                    (display (tm:padding (date-week-number date 1) #\0 2) port)))
        (cons #\w (lambda (date pad-with port) (display (date-week-day date) port)))
        (cons #\x (lambda (date pad-with port)
                    (display (date->string date tm:locale-short-date-format) port)))
        (cons #\X (lambda (date pad-with port)
                    (display (date->string date tm:locale-time-format) port)))
        (cons #\W (lambda (date pad-with port)
                    (if (> (tm:days-before-first-week date 1) 0)
                        (display (tm:padding (+ (date-week-number date 1) 1) #\0 2) port)
                        (display (tm:padding (date-week-number date 1) #\0 2) port))))
        (cons #\y (lambda (date pad-with port)
                    (display (tm:padding (tm:last-n-digits (date-year date) 2) pad-with 2) port)))
        (cons #\Y (lambda (date pad-with port)
                    (display (tm:padding (date-year date) pad-with 4) port)))
        (cons #\z (lambda (date pad-with port)
                    (tm:tz-printer (date-zone-offset date) port)))
        (cons #\Z (lambda (date pad-with port)
                    (tm:locale-print-time-zone date port)))
        (cons #\1 (lambda (date pad-with port)
                    (display (date->string date "~Y-~m-~d") port)))
        (cons #\2 (lambda (date pad-with port)
                    (display (date->string date "~k:~M:~S~z") port)))
        (cons #\3 (lambda (date pad-with port)
                    (display (date->string date "~k:~M:~S") port)))
        (cons #\4 (lambda (date pad-with port)
                    (display (date->string date "~Y-~m-~dT~k:~M:~S~z") port)))
        (cons #\5 (lambda (date pad-with port)
                    (display (date->string date "~Y-~m-~dT~k:~M:~S") port)))))

    (define (tm:get-formatter char)
      (let ((associated (assoc char tm:directives)))
        (if associated (cdr associated) #f)))

    (define (tm:date-printer date index formatstr str-len port)
      (if (>= index str-len)
          (void)
          (let ((current-char (string-ref formatstr index)))
            (if (not (char=? current-char #\~))
                (begin (display current-char port)
                       (tm:date-printer date (+ index 1) formatstr str-len port))
                (if (= (+ index 1) str-len) ; bad format string.
                    (error "tm:date-printer: bad date format string" formatstr)
                    (let ((pad-char? (string-ref formatstr (+ index 1))))
                      (cond ((char=? pad-char? #\-)
                               (if (= (+ index 2) str-len) ; bad format string.
                                   (error "tm:date-printer: bad date format string" formatstr)
                                   (let ((formatter (tm:get-formatter
                                                      (string-ref formatstr (+ index 2)))))
                                     (if (not formatter)
                                         (error "tm:date-printer: bad date format string" formatstr)
                                         (begin (formatter date #f port)
                                                (tm:date-printer date
                                                                 (+ index 3)
                                                                 formatstr str-len port))))))
                            ((char=? pad-char? #\_)
                               (if (= (+ index 2) str-len) ; bad format string.
                                   (error "tm:date-printer: bad date format string" formatstr)
                                   (let ((formatter (tm:get-formatter 
                                                      (string-ref formatstr (+ index 2)))))
                                     (if (not formatter)
                                         (error "tm:date-printer: bad date format string" formatstr)
                                         (begin (formatter date #\space port)
                                                (tm:date-printer date
                                                                 (+ index 3)
                                                                 formatstr str-len port))))))
                            (else
                               (let ((formatter (tm:get-formatter 
                                                  (string-ref formatstr (+ index 1)))))
                                 (if (not formatter)
                                     (error "tm:date-printer: bad date format string" formatstr)
                                     (begin (formatter date #\0 port)
                                            (tm:date-printer date
                                                             (+ index 2)
                                                             formatstr str-len port))))))))))))

    (define (date->string date .  format-string)
      (let ((str-port (open-output-string))
            (fmt-str (if (null? format-string) "~c" (car format-string))))
        (tm:date-printer date 0 fmt-str (string-length fmt-str) str-port)
        (get-output-string str-port)))

    (define (tm:char->int ch)
      (cond ((char=? ch #\0) 0)
            ((char=? ch #\1) 1)
            ((char=? ch #\2) 2)
            ((char=? ch #\3) 3)
            ((char=? ch #\4) 4)
            ((char=? ch #\5) 5)
            ((char=? ch #\6) 6)
            ((char=? ch #\7) 7)
            ((char=? ch #\8) 8)
            ((char=? ch #\9) 9)
            (else (error "string->date: bad date template string; non-digit character" ch))))

    ;; read an integer upto n characters long on port; upto -> #f if any length
    (define (tm:integer-reader upto port)
      (let loop ((accum 0)
                 (nchars 0))
        (let ((ch (peek-char port)))
          (if (or (eof-object? ch) (not (char-numeric? ch)) (and upto (>= nchars  upto )))
              accum
              (loop (+ (* accum 10) (tm:char->int (read-char port))) (+ nchars 1))))))

    (define (tm:make-integer-reader upto)
      (lambda (port) (tm:integer-reader upto port)))

    ;; read an fractional integer upto n characters long on port; upto -> #f if any length
    ;; 
    ;; The return value is normalized to upto decimal places. For example, if upto is 9 and 
    ;; the string read is "123", the return value is 123000000.
    (define (tm:fractional-integer-reader upto port)
      (let loop ((accum 0)
                 (nchars 0))
        (let ((ch (peek-char port)))
          (if (or (eof-object? ch) (not (char-numeric? ch))	(and upto (>= nchars  upto )))
              (* accum (expt 10 (- upto nchars)))
              (loop port (+ (* accum 10) (tm:char->int (read-char port))) (+ nchars 1))))))

    (define (tm:make-fractional-integer-reader upto)
      (lambda (port) (tm:fractional-integer-reader upto port)))

    ;; read *exactly* n characters and convert to integer; could be padded
    (define (tm:integer-reader-exact n port)
      (let loop ((padding-ok #t)
                 (accum 0)
                 (nchars 0))
        (let ((ch (peek-char port)))
          (cond ((>= nchars n) accum)
                ((eof-object? ch) 
                  (error "tm:integer-reader-exact: premature ending to integer read"))
                ((char-numeric? ch)
                  (loop #f (+ (* accum 10) (tm:char->int (read-char port))) (+ nchars 1)))
                (padding-ok
                  (read-char port) ; consume padding
                  (loop padding-ok accum (+ nchars 1)))
                (else ; padding where it shouldn't be
                  (error "tm:integer-reader-exact: non-numeric characters in integer read"))))))

    (define (tm:make-integer-exact-reader n)
      (lambda (port) (tm:integer-reader-exact n port)))

    (define (tm:zone-reader port) 
      (let ((offset 0) 
            (positive? #f))
        (let ((ch (read-char port)))
          (if (eof-object? ch)
              (error "tm:zone-reader: invalid time zone +/-"))
          (if (or (char=? ch #\Z) (char=? ch #\z))
              0
              (begin (cond ((char=? ch #\+) (set! positive? #t))
                           ((char=? ch #\-) (set! positive? #f))
                           (else
                              (error "tm:zone-reader: invalid time zone +/-" ch)))
                     (let ((ch (read-char port)))
                       (if (eof-object? ch)
                           (error "tm:zone-reader: invalid time zone number" ch))
                       (set! offset (* (tm:char->int ch) 10 60 60)))
                     (let ((ch (read-char port)))
                       (if (eof-object? ch)
                           (error "tm:zone-reader: invalid time zone number" ch))
                       (set! offset (+ offset (* (tm:char->int ch) 60 60))))
                     (let ((ch (read-char port)))
                       (if (eof-object? ch)
                           (error "tm:zone-reader: invalid time zone number" ch))
                       (set! offset (+ offset (* (tm:char->int ch) 10 60))))
                     (let ((ch (read-char port)))
                       (if (eof-object? ch)
                           (error "tm:zone-reader: invalid time zone number" ch))
                       (set! offset (+ offset (* (tm:char->int ch) 60))))
                     (if positive? offset (- offset)))))))

    ;; looking at a char, read the char string, run thru indexer, return index
    (define (tm:locale-reader port indexer)
      (letrec ((string-port (open-output-string))
               (read-char-string (lambda () 
                                   (let ((ch (peek-char port)))
                                     (if (char-alphabetic? ch)
                                         (begin (write-char (read-char port) string-port) 
                                                (read-char-string))
                                         (get-output-string string-port))))))
        (or (indexer (read-char-string)) (error "tm:locale-reader: invalid string for " indexer))))

    (define (tm:make-locale-reader indexer)
      (lambda (port) (tm:locale-reader port indexer)))

    (define (tm:make-char-id-reader char)
      (lambda (port)
        (if (char=? char (read-char port))
            char
            (error "tm:make-char-id-reader: invalid character match" char))))

    ;; A List of formatted read directives.
    ;; Each entry is a list.
    ;; 1. the character directive; 
    ;; 2. a procedure, which takes a character as input & returns #t as soon as a character
    ;;    on the input port is acceptable for input,
    ;; 3. a port reader procedure that knows how to read the current port for a value.
    ;;    Its one parameter is the port.
    ;; 4. a action procedure, that takes the value (from 3.) and some object (here, always
    ;;    the date) and (probably) side-effects it. In some cases (e.g., ~A) the action is
    ;;    to do nothing

    (define tm:read-directives 
      (let ((ireader4                   (tm:make-integer-reader 4))
            (ireader2                   (tm:make-integer-reader 2))
            (fireader9                  (tm:make-fractional-integer-reader 9))
            (ireaderf                   (tm:make-integer-reader #f))
            (eireader2                  (tm:make-integer-exact-reader 2))
            (eireader4                  (tm:make-integer-exact-reader 4))
            (locale-reader-abbr-weekday (tm:make-locale-reader tm:locale-abbr-weekday->index))
            (locale-reader-long-weekday (tm:make-locale-reader tm:locale-long-weekday->index))
            (locale-reader-abbr-month   (tm:make-locale-reader tm:locale-abbr-month->index))
            (locale-reader-long-month   (tm:make-locale-reader tm:locale-long-month->index))
            (char-fail                  (lambda (ch) #t))
            (do-nothing                 (lambda (val object) (void))))    
        (list
         (list #\~ char-fail        (tm:make-char-id-reader #\~) do-nothing)
         (list #\a char-alphabetic? locale-reader-abbr-weekday do-nothing)
         (list #\A char-alphabetic? locale-reader-long-weekday do-nothing)
         (list #\b char-alphabetic? locale-reader-abbr-month
                                    (lambda (val object) (tm:set-date-month! object val)))
         (list #\B char-alphabetic? locale-reader-long-month
                                    (lambda (val object) (tm:set-date-month! object val)))
         (list #\d char-numeric?    ireader2
                                    (lambda (val object) (tm:set-date-day! object val)))
         (list #\e char-fail        eireader2
                                    (lambda (val object) (tm:set-date-day! object val)))
         (list #\h char-alphabetic? locale-reader-abbr-month
                                    (lambda (val object) (tm:set-date-month! object val)))
         (list #\H char-numeric?    ireader2
                                    (lambda (val object) (tm:set-date-hour! object val)))
         (list #\k char-fail        eireader2
                                    (lambda (val object) (tm:set-date-hour! object val)))
         (list #\m char-numeric?    ireader2
                                    (lambda (val object) (tm:set-date-month! object val)))
         (list #\M char-numeric?    ireader2
                                    (lambda (val object) (tm:set-date-minute! object val)))
         (list #\N char-numeric?    fireader9
                                    (lambda (val object) (tm:set-date-nanosecond! object val)))
         (list #\S char-numeric?    ireader2
                                    (lambda (val object) (tm:set-date-second! object val)))
         (list #\y char-fail        eireader2 
                                    (lambda (val object)
                                      (tm:set-date-year! object (tm:natural-year val))))
         (list #\Y char-numeric?    ireader4
                                    (lambda (val object) (tm:set-date-year! object val)))
         (list #\z (lambda (c) (or (char=? c #\Z) (char=? c #\z) (char=? c #\+) (char=? c #\-)))
                   tm:zone-reader
                   (lambda (val object) (tm:set-date-zone-offset! object val))))))

    (define (tm:string->date date index format-string str-len port template)
      (letrec ((skip-until (lambda (skipper)
                 (let ((ch (peek-char port)))
                   (if (eof-object? ch)
                       (error "tm:string->date: bad template string" template)
                       (if (not (skipper ch))
                           (begin (read-char port)
                                  (skip-until skipper))))))))
        (if (>= index str-len)
            (void)
            (let ((current-char (string-ref format-string index)))
              (if (not (char=? current-char #\~))
                  (let ((port-char (read-char port)))
                    (if (or (eof-object? port-char) (not (char=? current-char port-char)))
                        (error "tm:string->date: bad date format string" template))
                    (tm:string->date date (+ index 1) format-string str-len port template))
                  ;; otherwise, it's an escape, we hope
                  (if (> (+ index 1) str-len)
                      (error "tm:string->date: bad date format string" template)
                      (let* ((format-char (string-ref format-string (+ index 1)))
                             (format-info (assoc format-char tm:read-directives)))
                        (if (not format-info)
                            (error "tm:string->date: bad date format string" template)
                            (begin (let ((skipper (cadr format-info))
                                         (reader  (caddr format-info))
                                         (actor   (cadddr format-info)))
                                     (display "1-\n")
                                     (skip-until skipper)
                                     (display "2-\n")
                                     (let ((val (reader port)))
                                       (if (eof-object? val)
                                           (error "tm:string->date: bad date" template)
                                           (actor val date)))
                                     (tm:string->date date
                                                      (+ index 2)
                                                      format-string
                                                      str-len
                                                      port
                                                      template)))))))))))

    (define (string->date input-string template)
      (let ((newdate (make-date 0 0 0 0 #f #f #f (tm:local-tz-offset))))
        (tm:string->date newdate
                         0
                         template
                         (string-length template)
                         (open-input-string input-string)
                         template)
        (if (and (date-nanosecond newdate)
                 (date-second newdate)
                 (date-minute newdate)
                 (date-hour newdate)
                 (date-day newdate)
                 (date-month newdate)
                 (date-year newdate)
                 (date-zone-offset newdate))
            newdate
            (error "string->date: incomplete date read" newdate template))))))
;;; SRFI 194
;;; Random data generators
;;;
;;; This SRFI defines a set of SRFI 158 generators and generator makers that yield random data
;;; of specific ranges and distributions. It is intended to be implemented on top of SRFI 27,
;;; which provides the underlying source of random integers and floats.
;;; 
;;; Copyright © 2020 Shiro Kawai, Arvydas Silanskas, Linas Vepštas, John Cowan.
;;; All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 194)
  
  (export clamp-real-number
          current-random-source
          with-random-source
          make-random-integer-generator
          make-random-u1-generator
          make-random-u8-generator
          make-random-s8-generator
          make-random-u16-generator
          make-random-s16-generator
          make-random-u32-generator
          make-random-s32-generator
          make-random-u64-generator
          make-random-s64-generator
          make-random-boolean-generator
          make-random-char-generator
          make-random-string-generator
          make-random-real-generator
          make-random-rectangular-generator
          make-random-polar-generator
          make-bernoulli-generator
          make-binomial-generator
          make-categorical-generator
          make-normal-generator
          make-exponential-generator
          make-geometric-generator
          make-poisson-generator
          make-zipf-generator
          make-sphere-generator
          make-ellipsoid-generator
          make-ball-generator
          make-random-source-generator
          gsampling)

  (import (except (lispkit base) vector-map!)
          (srfi 27)
          (srfi 133)
          (srfi 158))

  (begin
    
    ;;
    ;; Parameters
    ;;
    (define current-random-source (make-parameter default-random-source))
    
    (define (with-random-source random-source thunk)
      (unless (random-source? random-source)
        (error "expected random source"))
      (parameterize ((current-random-source random-source))
                    (thunk)))
    
    ;;
    ;; Carefully return consecutive substreams of the s'th
    ;; SRFI 27 stream of random numbers.  See Sections 1.2 and
    ;; 1.3 of "An object-oriented random-number package with many
    ;; long streams and substreams", by Pierre L'Ecuyer, Richard
    ;; Simard, E. Jack Chen, and W. David Kelton, Operations Research,
    ;; vol. 50 (2002), pages 1073-1075.
    ;; https://doi.org/10.1287/opre.50.6.1073.358
    ;;
    
    (define (make-random-source-generator s)
      (if (not (and (exact? s)
                    (integer? s)
                    (not (negative? s))))
          (error "make-random-source-generator: Expect nonnegative exact integer argument: " s)
          (let ((substream 0))
            (lambda ()
              (let ((new-source (make-random-source))) ;; deterministic
                (random-source-pseudo-randomize! new-source s substream)
                (set! substream (+ substream 1))
                new-source)))))
    
    ;;
    ;; Primitive randoms
    ;;
    
    (define (make-random-integer-generator low-bound up-bound)
      (unless (and (integer? low-bound)
                   (exact? low-bound))
        (error "expected exact integer for lower bound"))
      (unless (and (integer? up-bound)
                   (exact? up-bound))
        (error "expected exact integer for upper bound"))
      (unless (< low-bound up-bound)
        (error "upper bound should be greater than lower bound"))
      (let ((rand-int-proc (random-source-make-integers (current-random-source)))
            (range (- up-bound low-bound)))
        (lambda ()
          (+ low-bound (rand-int-proc range)))))
    
    (define (make-random-u1-generator)
      (make-random-integer-generator 0 2))
    (define (make-random-u8-generator)
      (make-random-integer-generator 0 256))
    (define (make-random-s8-generator)
      (make-random-integer-generator -128 128))
    (define (make-random-u16-generator)
      (make-random-integer-generator 0 65536))
    (define (make-random-s16-generator)
      (make-random-integer-generator -32768 32768))
    (define (make-random-u32-generator)
      (make-random-integer-generator 0 (expt 2 32)))
    (define (make-random-s32-generator)
      (make-random-integer-generator (- (expt 2 31)) (expt 2 31)))
    (define (make-random-u64-generator)
      (make-random-integer-generator 0 (expt 2 64)))
    (define (make-random-s64-generator)
      (make-random-integer-generator (- (expt 2 63)) (expt 2 63)))
    
    (define (clamp-real-number lower-bound upper-bound value)
      (cond ((not (real? lower-bound))
             (error "expected real number for lower bound"))
            ((not (real? upper-bound))
             (error "expected real number for upper bound"))
            ((not (<= lower-bound upper-bound))
             (error "lower bound must be <= upper bound"))
            ((< value lower-bound) lower-bound)
            ((> value upper-bound) upper-bound)
            (else value)))
    
    (define (make-random-real-generator low-bound up-bound)
      (unless (and (real? low-bound)
                   (finite? low-bound))
        (error "expected finite real number for lower bound"))
      (unless (and (real? up-bound)
                   (finite? up-bound))
         (error "expected finite real number for upper bound"))
      (unless (< low-bound up-bound)
         (error "lower bound must be < upper bound"))
      (let ((rand-real-proc (random-source-make-reals (current-random-source))))
       (lambda ()
         (define t (rand-real-proc))
         ;; alternative way of doing lowbound + t * (up-bound - low-bound)
         ;; is susceptible to rounding errors and would require clamping to be safe
         ;; (which in turn requires 144 for adjacent float function)
         (+ (* t low-bound)
            (* (- 1.0 t) up-bound)))))
    
    (define (make-random-rectangular-generator
              real-lower-bound real-upper-bound
              imag-lower-bound imag-upper-bound)
      (let ((real-gen (make-random-real-generator real-lower-bound real-upper-bound))
            (imag-gen (make-random-real-generator imag-lower-bound imag-upper-bound)))
        (lambda ()
          (make-rectangular (real-gen) (imag-gen)))))
    
    (define make-random-polar-generator
      (case-lambda
        ((magnitude-lower-bound magnitude-upper-bound)
         (make-random-polar-generator 0+0i magnitude-lower-bound magnitude-upper-bound 0 (* 2 PI)))
        ((origin magnitude-lower-bound magnitude-upper-bound)
         (make-random-polar-generator origin magnitude-lower-bound
           magnitude-upper-bound 0 (* 2 PI)))
        ((magnitude-lower-bound magnitude-upper-bound angle-lower-bound angle-upper-bound)
         (make-random-polar-generator 0+0i magnitude-lower-bound magnitude-upper-bound
           angle-lower-bound angle-upper-bound))
        ((origin magnitude-lower-bound magnitude-upper-bound angle-lower-bound angle-upper-bound)
         (unless (complex? origin)
           (error "origin should be complex number"))
         (unless (and (real? magnitude-lower-bound)
                      (real? magnitude-upper-bound)
                      (real? angle-lower-bound)
                      (real? angle-upper-bound))
           (error "magnitude and angle bounds should be real numbers"))
         (unless (and (<= 0 magnitude-lower-bound)
                      (<= 0 magnitude-upper-bound))
           (error "magnitude bounds should be positive"))
         (unless (< magnitude-lower-bound magnitude-upper-bound)
           (error "magnitude lower bound should be less than upper bound"))
         (when (= angle-lower-bound angle-upper-bound)
           (error "angle bounds shouldn't be equal"))
         (let* ((b (square magnitude-lower-bound))
                (m (- (square magnitude-upper-bound) b))
                (t-gen (make-random-real-generator 0. 1.))
                (phi-gen (make-random-real-generator angle-lower-bound angle-upper-bound)))
           (lambda ()
             (let* ((t (t-gen))
                    (phi (phi-gen))
                    (r (sqrt (+ (* m t) b))))
              (+ origin (make-polar r phi))))))))
    
    (define (make-random-boolean-generator)
      (define u1 (make-random-u1-generator))
      (lambda ()
        (zero? (u1))))
    
    (define (make-random-char-generator str)
      (when (not (string? str))
        (error "expected string"))
      (unless (> (string-length str) 0)
        (error "given string is of length 0"))
      (let* ((int-gen (make-random-integer-generator 0 (string-length str))))
       (lambda ()
         (string-ref str (int-gen)))))
    
    (define (make-random-string-generator k str)
      (let ((char-gen (make-random-char-generator str))
            (int-gen (make-random-integer-generator 0 k)))
        (lambda ()
          (generator->string char-gen (int-gen)))))
    
    ;;
    ;; Non-uniform distributions
    ;;
    
    (define PI (* 4 (atan 1.0)))
    
    (define (make-bernoulli-generator p)
      (unless (real? p)
        (error "expected p to be real"))
      (unless (<= 0 p 1)
        (error "expected 0 <= p <= 1"))
      (let ((rand-real-proc (random-source-make-reals (current-random-source))))
       (lambda ()
         (if (<= (rand-real-proc) p)
             1
             0))))
    
    (define (make-categorical-generator weights-vec)
      (define weight-sum
        (vector-fold
          (lambda (sum p)
            (unless (and (number? p)
                         (> p 0))
              (error "parameter must be a vector of positive numbers"))
            (+ sum p))
          0
          weights-vec))
      (define length (vector-length weights-vec))
      (let ((real-gen (make-random-real-generator 0 weight-sum)))
       (lambda ()
         (define roll (real-gen))
         (let it ((sum 0)
                  (i 0))
           (define newsum (+ sum (vector-ref weights-vec i)))
           (if (or (< roll newsum)
                   ;; in case of rounding errors and no matches, return last element
                   (= i (- length 1)))
               i
               (it newsum
                   (+ i 1)))))))
    
    ;; Normal distribution (continuous - generates real numbers)
    ;; Box-Muller algorithm
    ;; NB: We tested Ziggurat method, too,
    ;; only to find out Box-Muller is faster about 12% - presumably
    ;; the overhead of each ops is larger in Gauche than C/C++, and
    ;; so the difference of cost of log or sin from the primitive
    ;; addition/multiplication are negligible.
    
    ;; NOTE: this implementation is not thread safe
    (define make-normal-generator
      (case-lambda
        (()
         (make-normal-generator 0.0 1.0))
        ((mean)
         (make-normal-generator mean 1.0))
        ((mean deviation)
         (let ((rand-real-proc (random-source-make-reals (current-random-source)))
               (state #f))
           (unless (and (real? mean)
                        (finite? mean))
             (error "expected mean to be finite real number"))
           (unless (and (real? deviation)
                        (finite? deviation)
                        (> deviation 0))
             (error "expected deviation to be positive finite real number"))
           (lambda ()
             (if state
                 (let ((result state))
                  (set! state #f)
                  result)
                 (let ((r (sqrt (* -2 (log (rand-real-proc)))))
                       (theta (* 2 PI (rand-real-proc))))
                   (set! state (+ mean (* deviation r (cos theta))))
                   (+ mean (* deviation r (sin theta))))))))))
    
    (define (make-exponential-generator mean)
      (unless (and (real? mean)
                   (finite? mean)
                   (positive? mean))
        (error "expected mean to be finite positive real number"))
      (let ((rand-real-proc (random-source-make-reals (current-random-source))))
       (lambda ()
         (- (* mean (log (rand-real-proc)))))))
    
    (define (make-geometric-generator p)
    
      (define (log1p x)
        ;; Adapted from SRFI 144
        (let ((u (+ 1.0 x)))
          (cond ((= u 1.0)
                 x) ;; gets sign of zero result correct
                ((= u x)
                 (log u)) ;; large arguments and infinities
                (else
                 (* (log u) (/ x (- u 1.0)))))))
    
      (unless (and (real? p)
                   (> p 0)
                   (<= p 1))
              (error "expected p to be real number, 0 < p <= 1"))
      (if (zero? (- p 1.))
          ;; p is indistinguishable from 1.
          (lambda () 1)
          (let ((c (/ (log1p (- p))))
                (rand-real-proc (random-source-make-reals (current-random-source))))
            (lambda ()
              (exact (ceiling (* c (log (rand-real-proc)))))))))
    
    ;; Draw from poisson distribution with mean L, variance L.
    ;; For small L, we use Knuth's method.  For larger L, we use rejection
    ;; method by Atkinson, The Computer Generation of Poisson Random Variables,
    ;; J. of the Royal Statistical Society Series C (Applied Statistics), 28(1),
    ;; pp29-35, 1979.  The code here is a port by John D Cook's C++ implementation
    ;; (http://www.johndcook.com/stand_alone_code.html )
    
    ;; NOTE: this implementation calculates and stores a table of log(n!) on first invocation
    ;; of L >= 36 and therefore is not entirely thread safe (should still produce correct result,
    ;; but with performance hit if table is recalculated multiple times)
    (define (make-poisson-generator L)
      (unless (and (real? L)
                   (finite? L)
                   (> L 0))
        (error "expected L to be finite positive real number"))
      (let ((rand-real-proc (random-source-make-reals (current-random-source))))
       (if (< L 30)
           (make-poisson/small rand-real-proc L)
           (make-poisson/large rand-real-proc L))))
    
    ;; private
    (define (make-poisson/small rand-real-proc L)
      (lambda ()
        (do ((exp-L (exp (- L)))
             (k 0 (+ k 1))
             (p 1.0 (* p (rand-real-proc))))
            ((<= p exp-L) (- k 1)))))
    
    ;; private
    (define (make-poisson/large rand-real-proc L)
      (let* ((c (- 0.767 (/ 3.36 L)))
             (beta (/ PI (sqrt (* 3 L))))
             (alpha (* beta L))
             (k (- (log c) L (log beta))))
        (define (loop)
          (let* ((u (rand-real-proc))
                 (x (/ (- alpha (log (/ (- 1.0 u) u))) beta))
                 (n (exact (floor (+ x 0.5)))))
            (if (< n 0)
                (loop)
                (let* ((v (rand-real-proc))
                       (y (- alpha (* beta x)))
                       (t (+ 1.0 (exp y)))
                       (lhs (+ y (log (/ v (* t t)))))
                       (rhs (+ k (* n (log L)) (- (log-of-fact n)))))
                  (if (<= lhs rhs)
                      n
                      (loop))))))
        loop))
    
    ;; private
    ;; log(n!) table for n 1 to 256. Vector, where nth index corresponds to log((n+1)!)
    ;; Computed on first invocation of `log-of-fact`
    (define log-fact-table #f)
    
    ;; private
    ;; computes log-fact-table
    ;; log(n!) = log((n-1)!) + log(n)
    (define (make-log-fact-table!)
      (define table (make-vector 256))
      (vector-set! table 0 0)
      (do ((i 1 (+ i 1)))
          ((> i 255) #t)
          (vector-set! table i (+ (vector-ref table (- i 1))
                                  (log (+ i 1)))))
      (set! log-fact-table table))
    
    ;; private
    ;; returns log(n!)
    ;; adapted from https://www.johndcook.com/blog/2010/08/16/how-to-compute-log-factorial/
    (define (log-of-fact n)
      (when (not log-fact-table)
        (make-log-fact-table!))
      (cond
        ((<= n 1) 0)
        ((<= n 256) (vector-ref log-fact-table (- n 1)))
        (else (let ((x (+ n 1)))
               (+ (* (- x 0.5)
                     (log x))
                  (- x)
                  (* 0.5
                     (log (* 2 PI)))
                  (/ 1.0 (* x 12.0)))))))
    
    
    
    (define (gsampling . generators-lst)
      (let ((gen-vec (list->vector generators-lst))
            (rand-int-proc (random-source-make-integers (current-random-source))))
    
        ;remove exhausted generator at index
        (define (remove-gen index)
          (define new-vec (make-vector (- (vector-length gen-vec) 1)))
          ;when removing anything but first, copy all elements before index
          (when (> index 0)
            (vector-copy! new-vec 0 gen-vec 0 index))
          ;when removing anything but last, copy all elements after index
          (when (< index (- (vector-length gen-vec) 1))
            (vector-copy! new-vec index gen-vec (+ 1 index)))
          (set! gen-vec new-vec))
    
        ;randomly pick generator. If it's exhausted remove it, and pick again
        ;returns value (or eof, if all generators are exhausted)
        (define (pick)
          (let* ((index (rand-int-proc (vector-length gen-vec)))
                 (gen (vector-ref gen-vec index))
                 (value (gen)))
            (if (eof-object? value)
                (begin
                  (remove-gen index)
                  (if (= (vector-length gen-vec) 0)
                      (eof-object)
                      (pick)))
                value)))
    
        (lambda ()
          (if (= 0 (vector-length gen-vec))
              (eof-object)
              (pick)))))
    
    
    ;;; Code for binomial random variable generation.
    
    ;;; binomial-geometric is somewhat classical, the
    ;;; "First waiting time algorithm" from page 525 of
    ;;; Devroye, L. (1986), Non-Uniform Random Variate
    ;;; Generation, Springer-Verlag, New York.
    
    ;;; binomial-rejection is algorithm BTRS from
    ;;; Hormann, W. (1993), The generation of binomial
    ;;; random variates, Journal of Statistical Computation
    ;;; and Simulation, 46:1-2, 101-110,
    ;;; DOI: https://doi.org/10.1080/00949659308811496
    ;;; stirling-tail is also from that paper.
    
    ;;; Another implementation of the same algorithm is at
    ;;; https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/random_binomial_op.cc
    ;;; That implementation pointed out at least two bugs in the
    ;;; BTRS paper.
    
    (define (stirling-tail k)
      ;; Computes
      ;;
      ;; \log(k!)-[\log(\sqrt{2\pi})+(k+\frac12)\log(k+1)-(k+1)]
      ;;
      (let ((small-k-table
             ;; Computed using computable reals package
             ;; Matches values in paper, which are given
             ;; for 0\leq k < 10
             '#(.08106146679532726
                .0413406959554093
                .02767792568499834
                .020790672103765093
                .016644691189821193
                .013876128823070748
                .01189670994589177
                .010411265261972096
                .009255462182712733
                .00833056343336287
                .007573675487951841
                .00694284010720953
                .006408994188004207
                .0059513701127588475
                .005554733551962801
                .0052076559196096404
                .004901395948434738
                .004629153749334028
                .004385560249232324
                .004166319691996922)))
        (if (< k 20)
            (vector-ref small-k-table k)
            ;; the correction term (+ (/ (* 12 (+ k 1))) ...)
            ;; in Stirling's approximation to log(k!)
            (let* ((inexact-k+1 (inexact (+ k 1)))
                   (inexact-k+1^2 (square inexact-k+1)))
              (/ (- #i1/12
                    (/ (- #i1/360
                          (/ #i1/1260 inexact-k+1^2))
                       inexact-k+1^2))
                 inexact-k+1)))))
    
    (define (make-binomial-generator n p)
      (if (not (and (real? p)
                    (<= 0 p 1)
                    (exact-integer? n)
                    (positive? n)))
           (error "make-binomial-generator: Bad parameters: " n p)
           (cond ((< 1/2 p)
                  (let ((complement (make-binomial-generator n (- 1 p))))
                    (lambda ()
                      (- n (complement)))))
                 ((zero? p)
                  (lambda () 0))
                 ((< (* n p) 10)
                  (binomial-geometric n p))
                 (else
                  (binomial-rejection n p)))))
    
    (define (binomial-geometric n p)
      (let ((geom (make-geometric-generator p)))
        (lambda ()
          (let loop ((X -1)
                     (sum 0))
            (if (< n sum)
                X
                (loop (+ X 1)
                      (+ sum (geom))))))))
    
    (define (binomial-rejection n p)
      ;; call when p <= 1/2 and np >= 10
      ;; Use notation from the paper
      (let* ((spq
              (inexact (sqrt (* n p (- 1 p)))))
             (b
              (+ 1.15 (* 2.53 spq)))
             (a
              (+ -0.0873
                 (* 0.0248 b)
                 (* 0.01 p)))
             (c
              (+ (* n p) 0.5))
             (v_r
              (- 0.92
                 (/ 4.2 b)))
             (alpha
              ;; The formula in BTRS has 1.5 instead of 5.1;
              ;; The formula for alpha in algorithm BTRD and Table 1
              ;; and the tensorflow code uses 5.1, so we use 5.1
              (* (+ 2.83 (/ 5.1 b)) spq))
             (lpq
              (log (/ p (- 1 p))))
             (m
              (exact (floor (* (+ n 1) p))))
             (rand-real-proc
              (random-source-make-reals (current-random-source))))
        (lambda ()
          (let loop ((u (rand-real-proc))
                     (v (rand-real-proc)))
            (let* ((u
                    (- u 0.5))
                   (us
                    (- 0.5 (abs u)))
                   (k
                    (exact
                     (floor
                      (+ (* (+ (* 2. (/ a us)) b) u) c)))))
              (cond ((or (< k 0)
                         (< n k))
                     (loop (random-real)
                           (random-real)))
                    ((and (<= 0.07 us)
                          (<= v v_r))
                     k)
                    (else
                     (let ((v
                            ;; The tensorflow code notes that BTRS doesn't have
                            ;; this logarithm; BTRS is incorrect (see BTRD, step 3.2)
                            (log (* v (/ alpha
                                         (+ (/ a (square us)) b))))))
                       (if (<=  v
                                (+ (* (+ m 0.5)
                                      (log (* (/ (+ m 1.)
                                                 (- n m -1.)))))
                                   (* (+ n 1.)
                                      (log (/ (- n m -1.)
                                              (- n k -1.))))
                                   (* (+ k 0.5)
                                      (log (* (/ (- n k -1.)
                                                 (+ k 1.)))))
                                   (* (- k m) lpq)
                                   (- (+ (stirling-tail m)
                                         (stirling-tail (- n m)))
                                      (+ (stirling-tail k)
                                         (stirling-tail (- n k))))))
                           k
                           (loop (random-real)
                                 (random-real)))))))))))
  )
  
  (begin

    ; zipf-zri.scm
    ; Create a Zipf random distribution.
    ;
    ; Created by Linas Vepstas 10 July 2020
    ; Nominated for inclusion in srfi-194
    ;
    ; Not optimized for speed!
    ;
    ; Implementation from ZRI algorithm presented in the paper:
    ; "Rejection-inversion to generate variates from monotone discrete
    ; distributions", Wolfgang Hörmann and Gerhard Derflinger
    ; ACM TOMACS 6.3 (1996): 169-184
    ;
    ; Hörmann and Derflinger use "q" everywhere, when they really mean "s".
    ; Thier "q" is not the standard q-series deformation. Its just "s".
    ; The notation in the code below differs from the article to reflect
    ; conventional usage.
    ;
    ;------------------------------------------------------------------
    ;
    ; The Hurwicz zeta distribution 1 / (k+q)^s for 1 <= k <= n integer
    ; The Zipf distribution is recovered by setting q=0.
    ;
    ; The exponent `s` must be a real number not equal to 1.
    ; Accuracy is diminished for |1-s|< 1e-6. The accuracy is roughly
    ; equal to 1e-15 / |1-s| where 1e-15 == 64-bit double-precision ULP.

    (define (make-zipf-generator/zri n s q)
    
      ; The hat function h(x) = 1 / (x+q)^s
      (define (hat x)
        (expt (+ x q) (- s)))
    
      (define _1-s (- 1 s))
      (define oms (/ 1 _1-s))
    
      ; The integral of hat(x)
      ; H(x) = (x+q)^{1-s} / (1-s)
      ; Note that H(x) is always negative.
      (define (big-h x)
        (/ (expt (+ q x) _1-s) _1-s))
    
      ; The inverse function of H(x)
      ; H^{-1}(y) = -q + (y(1-s))^{1/(1-s)}
      (define (big-h-inv y)
        (- (expt (* y _1-s) oms) q))
    
      ; Lower and upper bounds for the uniform random generator.
      (define big-h-half (- (big-h 1.5) (hat 1)))
      (define big-h-n (big-h (+ n 0.5)))
    
      ; Rejection cut
      (define cut (- 1 (big-h-inv (- (big-h 1.5) (hat 1)))))
    
      ; Uniform distribution
      (define dist (make-random-real-generator big-h-half big-h-n))
    
      ; Attempt to hit the dartboard. Return #f if we fail,
      ; otherwise return an integer between 1 and n.
      (define (try)
        (define u (dist))
        (define x (big-h-inv u))
        (define kflt (floor (+ x 0.5)))
        (define k (exact kflt))
        (if (and (< 0 k)
                 (or
                   (<= (- k x) cut)
                   (>= u (- (big-h (+ k 0.5)) (hat k))))) k #f))
    
      ; Did we hit the dartboard? If not, try again.
      (define (loop-until)
        (define k (try))
        (if k k (loop-until)))
    
      ; Return the generator.
      loop-until)
    
    ; The Hurwicz zeta distribution 1 / (k+q)^s for 1 <= k <= n integer
    ; The Zipf distribution is recovered by setting q=0.
    ;
    ; The exponent `s` must be a real number close to 1.
    ; Accuracy is diminished for |1-s|> 2e-4. The accuracy is roughly
    ; equal to 0.05 * |1-s|^4 due to exp(1-s) being expanded to 4 terms.
    ;
    ; This handles the special case of s==1 perfectly.
    (define (make-zipf-generator/one n s q)
    
      (define _1-s (- 1 s))
    
      ; The hat function h(x) = 1 / (x+q)^s
      ; Written for s->1 i.e. 1/(x+q)(x+q)^{s-1}
      (define (hat x)
        (define xpq (+ x q))
        (/ (expt xpq _1-s) xpq))
    
      ; Expansion of exn(y) = [exp(y(1-s))-1]/(1-s) for s->1
      ; Expanded to 4th order.
      ; Should equal this:
      ;;; (define (exn lg) (/ (- (exp (* _1-s lg)) 1) _1-s))
      ; but more accurate for s near 1.0
      (define (exn lg)
        (define (trm n u lg) (* lg (+ 1 (/ (* _1-s u) n))))
        (trm 2 (trm 3 (trm 4 1 lg) lg) lg))
    
      ; Expansion of lg(y) = [log(1 + y(1-s))] / (1-s) for s->1
      ; Expanded to 4th order.
      ; Should equal this:
      ;;; (define (lg y) (/ (log (+ 1 (* y _1-s))) _1-s))
      ; but more accurate for s near 1.0
      (define (lg y)
        (define yms (* y _1-s))
        (define (trm n u r) (- (/ 1 n) (* u r)))
        (* y (trm 1 yms (trm 2 yms (trm 3 yms (trm 4 yms 0))))))
    
      ; The integral of hat(x) defined at s==1
      ; H(x) = [exp{(1-s) log(x+q)} - 1]/(1-s)
      ; Should equal this:
      ;;;  (define (big-h x) (/ (- (exp (* _1-s (log (+ q x)))) 1)  _1-s))
      ; but expanded so that it's more accurate for s near 1.0
      (define (big-h x)
        (exn (log (+ q x))))
    
      ; The inverse function of H(x)
      ; H^{-1}(y) = -q + (1 + y(1-s))^{1/(1-s)}
      ; Should equal this:
      ;;; (define (big-h-inv y) (- (expt (+ 1 (* y _1-s)) (/ 1 _1-s)) q ))
      ; but expanded so that it's more accurate for s near 1.0
      (define (big-h-inv y)
        (- (exp (lg y)) q))
    
      ; Lower and upper bounds for the uniform random generator.
      (define big-h-half (- (big-h 1.5) (hat 1)))
    
      (define big-h-n (big-h (+ n 0.5)))
    
      ; Rejection cut
      (define cut (- 1 (big-h-inv (- (big-h 1.5) (/ 1 (+ 1 q))))))
    
      ; Uniform distribution
      (define dist (make-random-real-generator big-h-half big-h-n))
    
      ; Attempt to hit the dartboard. Return #f if we fail,
      ; otherwise return an integer between 1 and n.
      (define (try)
        (define u (dist))
        (define x (big-h-inv u))
        (define kflt (floor (+ x 0.5)))
        (define k (exact kflt))
        (if (and (< 0 k)
                 (or
                   (<= (- k x) cut)
                   (>= u (- (big-h (+ k 0.5)) (hat k))))) k #f))
    
      ; Did we hit the dartboard? If not, try again.
      (define (loop-until)
        (define k (try))
        (if k k (loop-until)))
    
      ; Return the generator.
      loop-until)
    
    ; (make-zipf-generator n [s [q]])
    ;
    ; The Hurwicz zeta distribution 1 / (k+q)^s for 1 <= k <= n integer
    ; The Zipf distribution is recovered by setting q=0.
    ; If `q` is not specified, 0 is assumed.
    ; If `s` is not specified, 1 is assumed.
    ;
    ; Valid for real -10 < s < 100 (otherwise overflows likely)
    ; Valid for real -0.5 < q < 2e8 (otherwise overflows likely)
    ; Valid for integer 1 <= k < int-max
    ;
    ; Example usage:
    ;    (define zgen (make-zipf-generator 50 1.01 0))
    ;    (generator->list zgen 10)

    (define make-zipf-generator
      (case-lambda
        ((n)
         (make-zipf-generator n 1.0 0.0))
        ((n s)
         (make-zipf-generator n s 0.0))
        ((n s q)
         (if (< 1e-5 (abs (- 1 s)))
             (make-zipf-generator/zri n s q)
             (make-zipf-generator/one n s q)))))
  )
  
  (begin
    
    ; sphere.scm
    ; Uniform distributions on a sphere, and a ball.
    ; Submitted for inclusion in srfi-194
    ;
    ; Algorithm based on BoxMeuller as described in
    ; http://extremelearning.com.au/how-to-generate-uniformly-random-points-on-n-spheres-and-n-balls/
    ;
    
    ; make-sphere-generator N - return a generator of points uniformly
    ; distributed on an N-dimensional sphere.
    ; This implements the BoxMeuller algorithm, that is, of normalizing
    ; N+1 Gaussian random variables.
    (define (make-sphere-generator arg)
      (cond
        ((integer? arg) (make-ellipsoid-generator* (make-vector (+ 1 arg) 1.0)))
        (else (error "expected argument to be an integer dimension"))))
    
    (define (make-ellipsoid-generator arg)
      (cond
        ((vector? arg) (make-ellipsoid-generator* arg))
        (else (error "expected argument to be a vector of axis lengths"))))
    
    ; Generator of points uniformly distributed on an N-dimensional ellipsoid.
    ;
    ; The `axes` should be a vector of floats, specifying the axes of the
    ; ellipsoid. The algorithm used is an accept/reject sampling algo,
    ; wherein the acceptance rate is proportional to the measure of a
    ; surface element on the ellipsoid. The measure is straight-forward to
    ; arrive at, and the 3D case is described by `mercio` in detail at
    ; https://math.stackexchange.com/questions/973101/how-to-generate-points-uniformly-distributed-on-the-surface-of-an-ellipsoid
    ;
    ; Note that sampling means that performance goes as
    ; O(B/A x C/A x D/A x ...) where `A` is the shorest axis,
    ; and `B`, `C`, `D`, ... are the other axes. Maximum performance
    ; achieved on spheres.
    
    (define (make-ellipsoid-generator* axes)
    
      ; A vector of normal gaussian generators
      (define gaussg-vec
        (make-vector (vector-length axes) (make-normal-generator 0 1)))
    
      ; Banach l2-norm of a vector
      (define (l2-norm VEC)
        (sqrt (vector-fold
                (lambda (sum x) (+ sum (* x x)))
                0
                VEC)))
    
      ; Generate one point on a sphere
      (define (sph)
        ; Sample a point
        (define point
          (vector-map (lambda (gaussg) (gaussg)) gaussg-vec))
        ; Project it to the unit sphere (make it unit length)
        (define norm (/ 1.0 (l2-norm point)))
        (vector-map (lambda (x) (* x norm)) point))
    
      ; Distance from origin to the surface of the
      ; ellipsoid along direction RAY.
      (define (ellipsoid-dist RAY)
        (sqrt (vector-fold
                (lambda (sum x a) (+ sum (/ (* x x) (* a a))))
                0 RAY axes)))
    
      ; Find the shortest axis.
      (define minor
        (vector-fold
            (lambda (mino l) (if (< l mino) l mino))
            1e308 axes))
    
      ; Uniform generator [0,1)
      (define uni (make-random-real-generator 0.0 1.0))
    
      ; Return #t if the POINT can be kept; else must resample.
      (define (keep POINT)
        (< (uni) (* minor (ellipsoid-dist POINT))))
    
      ; Sample until a good point is found. The returned sample is a
      ; vector of unit length (we already normed up above).
      (define (sample)
        (define vect (sph))
        (if (keep vect) vect (sample)))
    
      (lambda ()
      ; Find a good point, and rescale to ellipsoid.
        (vector-map
             (lambda (x a) (* x a)) (sample) axes))
    )
    
    ; make-ball-generator N - return a generator of points uniformly
    ; distributed inside an N-dimensional ball.
    ; This implements the Harman-Lacko-Voelker Dropped Coordinate method.
    (define (make-ball-generator arg)
      (define dim-sizes
        (cond
          ((integer? arg) (make-vector (+ 2 arg) 1.0))
          ((vector? arg) (vector-append arg (vector 1.0 1.0)))
          (else (error "expected argument to either be a number (dimension), or vector (axis length for the dimensions)"))))
      (define N (- (vector-length dim-sizes) 2))
      (define sphereg (make-sphere-generator (+ N 2)))
      ; Create a vector of N+2 values, and drop the last two.
      ; (The sphere already added one, so we only add one more)
      (lambda ()
        (vector-map
          (lambda (el dim-size _) (* el dim-size))
          (sphereg)
          dim-sizes
          (make-vector N #f))))
  )
)

;;; SRFI 195
;;; Multiple-value boxes
;;;
;;; Boxes are objects with a single mutable state. Several Schemes have them, sometimes
;;; called cells. A constructor, predicate, accessor, and mutator are provided.
;;; This SRFI extends the specification of the boxes of SRFI 111 so that they are
;;; multiple-values aware. Whereas a SRFI 111 box is limited in that it can only
;;; box a single value, multiple values can be boxed with this SRFI.
;;;
;;; Copyright © 2020 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 195)
  (export box?
          box
          unbox
          set-box!)
  (import (lispkit base)))
;;; SRFI 196
;;; Range Objects
;;;
;;; Ranges are immutable collections that can be enumerated but are represented
;;; algorithmically rather than by a per-element data structure. This SRFI defines
;;; a large subset of the sequence operations defined on lists, vectors, and other
;;; collections. If necessary, ranges can be converted to a list of its elements
;;; or a generator that will lazily produce each element in the range.
;;;
;;; Copyright © 2020 Wolfgang Corcoran-Mathe. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 196)

  (export range
          numeric-range
          range?
          range-contains?
          range-includes?
          range-empty?
          range-element-comparator
          range-length
          range-indexer
          range-ref
          range-start
          range-end
          range-split-at
          range-take
          range-take-right
          range-drop
          range-drop-right
          range-count
          range-map->list
          range-for-each
          range-fold
          range-fold-right
          range-any
          range-every
          range-filter->list
          range-remove->list
          range-reverse
          range-index
          range-index-right
          range-take-while
          range-drop-while
          range-take-while-right
          range-drop-while-right
          range->list
          range->generator)

  (import (lispkit base)
          (srfi 128)
          (srfi 145))

  (begin

    ;;; Utility

    (define (natural? x)
      (and (integer? x) (not (negative? x))))

    (define unspecified (if #f #f))

    ;;; Constructors

    (define-record-type <range>
      (raw-range comparator lower-bound length indexer)
      range?
      (comparator range-element-comparator)
      (lower-bound range-lower-bound)
      (length range-length)
      (indexer range-indexer))

    ;; The primary range constructor does some extra consistency checking.
    (define (range comparator lower-bound length indexer)
      (assume (comparator? comparator))
      (assume (natural? length))
      (assume (procedure? indexer))
      (unless ((comparator-type-test-predicate comparator) lower-bound)
        (error "range: invalid lower bound" comparator lower-bound))
      (raw-range comparator lower-bound length indexer))

    ;; Utility
    (define (empty-range-from r)
      (range (range-element-comparator r)
             (range-lower-bound r)
             0
             (range-indexer r)))

    ;; How do we deal with the case in which the length computed from
    ;; `start' and `end' isn't a positive integer?
    (define numeric-range
      (case-lambda
        ((start end) (numeric-range start end 1))
        ((start end step)
         (let ((len (/ (- end start) step)))
           (unless (natural? len)
             (error "numeric-range: invalid parameters" end start step))
           (range (make-comparator real? = < (lambda (x) (exact (abs x))))
                  start
                  (exact len)
                  (lambda (b n) (+ b (* n step))))))))

    ;;; Predicates

    (define (range-contains? r value)
      (assume (range? r))
      (let ((cmp (range-element-comparator r)))
        (and (range-index (lambda (x) (=? cmp x value)) r) #t)))

    (define (range-includes? r value)
      (let ((cmp (range-element-comparator r)))
        (and (>=? cmp value (range-start r))
             (<=? cmp value (range-end r)))))

    (define (range-empty? r)
      (<= (range-length r) 0))

    ;;; Accessors

    (define (range-ref r index)
      (if (and (integer? index) (<= 0 index) (< index (range-length r)))
          ((range-indexer r) (range-lower-bound r) index)
          (error "invalid index" r index)))

    (define (range-start r) (range-ref r 0))

    (define (range-end r) (range-ref r (- (range-length r) 1)))

    ;;; Iteration

    ;; FIXME?: `range-split-at' is *not* equivalent to
    ;;   (values (range-take r n) (range-drop r n)),
    ;; it seems.  This might be a bit surprising.
    (define (range-split-at r index)
      (let ((cmp (range-element-comparator r))
            (indexer (range-indexer r)))
        (if (>= index (range-length r))
            (error "index out of bounds" r index)
            (values
             (range cmp (range-start r) index indexer)
             (range cmp (range-ref r index) (- (range-length r) index) indexer)))))

    ;; If the `count' argument of `range-take[-right]' is greater
    ;; than or equal to the length of the input range `r', an exception is
    ;; raised.

    (define (range-take r count)
      (assume (range? r))
      (assume (natural? count))
      (if (>= count (range-length r))
          (error "count out of bounds" r count)
          (range (range-element-comparator r)
                 (range-lower-bound r)
                 count
                 (range-indexer r))))

    (define (range-take-right r count)
      (assume (range? r))
      (assume (natural? count))
      (cond ((>= count (range-length r)) (error "count out of bounds" r count))
            ((zero? count) (empty-range-from r))
            (else (range (range-element-comparator r)
                         (range-ref r (- (range-length r) count))
                         count
                         (range-indexer r)))))

    ;; If the `count' argument of `range-drop[-right]' is greater
    ;; than or equal to the length of the input range `r', an exception is
    ;; raised.

    (define (range-drop r count)
      (assume (range? r))
      (assume (natural? count))
      (let ((len (range-length r)))
        (if (>= count len)
            (error "count out of bounds" r count)
            (range (range-element-comparator r)
                   (range-ref r count)
                   (- (range-length r) count)
                   (range-indexer r)))))

    (define (range-drop-right r count)
      (assume (range? r))
      (assume (natural? count))
      (let ((len (range-length r)))
        (if (>= count len)
            (error "count out of bounds" r count)
            (range (range-element-comparator r)
                   (range-lower-bound r)
                   (- (range-length r) count)
                   (range-indexer r)))))

    (define (range-count pred r)
      (assume (procedure? pred))
      (range-fold (lambda (x c) (if (pred x) (+ c 1) c)) 0 r))

    (define (range-any pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (range-fold (lambda (x last) (or (pred x) last)) #f r))

    (define (range-every pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (call-with-current-continuation
       (lambda (return)
         (range-fold (lambda (x _) (or (pred x) (return #f))) #t r))))

    (define (range-map->list proc r)
      (assume (procedure? proc))
      (range-fold-right (lambda (elem xs) (cons (proc elem) xs))
                        '()
                        r))

    (define (range-for-each proc r)
      (assume (procedure? proc))
      (let ((len (range-length r)))
        (let lp ((i 0))
          (if (>= i len)
              unspecified
              (begin
               (proc (range-ref r i))
               (lp (+ i 1)))))))

    (define (range-fold proc nil r)
      (assume (range? r))
      (assume (procedure? proc))
      (let ((len (range-length r)))
        (let lp ((i 0) (acc nil))
          (if (>= i len)
              acc
              (lp (+ i 1) (proc (range-ref r i) acc))))))

    (define (range-fold-right proc nil r)
      (assume (range? r))
      (assume (procedure? proc))
      (let ((len (range-length r)))
        (let rec ((i 0))
          (if (>= i len)
              nil
              (proc (range-ref r i) (rec (+ i 1)))))))

    (define (range-filter->list pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (range-fold-right (lambda (x xs)
                          (if (pred x) (cons x xs) xs))
                        '()
                        r))

    (define (range-remove->list pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (range-fold-right (lambda (x xs)
                          (if (pred x) xs (cons x xs)))
                        '()
                        r))

    (define (range-reverse r)
      (assume (range? r))
      (range (range-element-comparator r)
             (range-lower-bound r)
             (range-length r)
             (lambda (b n)
               ((range-indexer r) b (- (range-length r) 1 n)))))

    ;;; Searching

    (define (range-index pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (let ((len (range-length r)))
        (let lp ((i 0))
          (cond ((>= i len) #f)
                ((pred (range-ref r i)) i)
                (else (lp (+ i 1)))))))

    (define (range-index-right pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (let lp ((i (- (range-length r) 1)))
        (cond ((<= i 0) #f)
              ((pred (range-ref r i)) i)
              (else (lp (- i 1))))))

    (define (range-take-while pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (let ((count (range-index (lambda (x) (not (pred x))) r)))
        (if count (range-take r count) r)))

    (define (range-take-while-right pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (let ((idx (range-index-right (lambda (x) (not (pred x))) r)))
        (if idx (range-take-right r (- (range-length r) 1 idx)) r)))

    (define (range-drop-while pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (let ((count (range-index (lambda (x) (not (pred x))) r)))
        (if count (range-drop r count) (empty-range-from r))))

    (define (range-drop-while-right pred r)
      (assume (procedure? pred))
      (assume (range? r))
      (let ((idx (range-index-right (lambda (x) (not (pred x))) r)))
        (if idx
            (range-drop-right r (- (range-length r) 1 idx))
            (empty-range-from r))))

    ;;; Conversion

    (define (range->list r)
      (assume (range? r))
      (range-fold-right cons '() r))

    (define (range->generator r)
      (assume (range? r))
      (let ((i 0) (len (range-length r)))
        (lambda ()
          (if (>= i len)
              (eof-object)
              (begin
               (let ((v (range-ref r i)))
                 (set! i (+ i 1))
                 v))))))
  )
)
;;; SRFI 2
;;; AND-LET*: an AND with local bindings, a guarded LET* special form
;;;
;;; Like an ordinary AND, an AND-LET* special form evaluates its arguments - expressions - one
;;; after another in order, till the first one that yields #f. Unlike AND, however, a non-#f
;;; result of one expression can be bound to a fresh variable and used in the subsequent
;;; expressions. AND-LET* is a cross-breed between LET* and AND.
;;;
;;; Author of spec: Oleg Kiselyov
;;; 
;;; Copyright © 2017 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 2)

  (export and-let*)

  (import (lispkit base))

  (begin
    (define-syntax and-let*
      (syntax-rules ()
        ; no claws
        ((and-let* ())
          #t)
        ((and-let* () body ...)
          (begin body ...))
        ; claws but no body
        ((and-let* ((var expr)))
          (let ((var expr)) var))
        ((and-let* ((expr)))
          expr)
        ((and-let* (var))
          (begin (let ((var #f)) #f) var)) ; do this to check that `var` is an identifier
        ; both claws and body
        ((and-let* ((var expr) . bindings) . body)
          (let ((var expr)) (and var (and-let* bindings . body))))
        ((and-let* ((expr) . bindings) . body)
          (and expr (and-let* bindings . body)))
        ((and-let* (var . bindings) . body)
          (begin (let ((var #f)) #f) (and var (and-let* bindings . body))))))
  )
)
;;; SRFI 204
;;; Wright-Cartwright-Shinn Pattern Matcher
;;;
;;; Pattern matching decomposes a compound data structure into parts and assigns those
;;; parts to variables. This SRFI describes a pattern-matching library already in use
;;; by several scheme implementations which can match many common compound data structures.
;;;
;;; Copyright © 2020 Felix Thibault. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 204)
  
  (export match
          match-lambda
          match-lambda*
          match-let
          match-letrec
          match-let*
          ___
          **1
          =..
          *..
          ***
          ?
          $
          struct
          object
          get!)
  
  (import (except (lispkit base) object)
          (lispkit match))
  
  (begin
    
    (define-syntax define-auxiliary-keyword
      (syntax-rules ()
        ((_ name)
          (define-syntax name
            (syntax-rules ()
              ((xx head . tail)
                (syntax-error "invalid auxiliary syntax" head . tail)))))))
    
    (define-auxiliary-keyword ___)
    (define-auxiliary-keyword **1)
    (define-auxiliary-keyword =..)
    (define-auxiliary-keyword *..)
    (define-auxiliary-keyword ***)
    (define-auxiliary-keyword ?)
    (define-auxiliary-keyword $)
    (define-auxiliary-keyword struct)
    (define-auxiliary-keyword object)
    (define-auxiliary-keyword get!)
  )
)
;;; SRFI 208
;;; NaN procedures
;;;
;;; This SRFI provides procedures that dissect NaN (Not a Number) inexact values. 
;;; IEEE 754:2008 is a standard for floating point numbers used on essentially all modern
;;; CPUs that have hardware floating point support. It specifies a set of floating-point
;;; values known as NaNs, i.e. "Not A Number". They are generated by such operations
;;; as `(/ 0.0 0.0)`, the mathematical result of which could be any number whatsoever, and
;;; by `(flsqrt -1.0)` from SRFI 144, the result of which cannot be any floating-point
;;; number. Scheme implementations that conform to R7RS use the external representations
;;; `+nan.0` and `-nan.0` for NaNs, and the procedure `nan?` will return `#t` when applied
;;; to any inexact real number (on R7RS systems, any inexact number) that is a NaN.
;;; In fact, however, there are 252 - 1 possible NaN values, assuming the representation
;;; is an IEEE binary64 float. This SRFI makes it possible to dissect a NaN to see which
;;; of these internal representations it corresponds to.
;;; 
;;; Author of spec: Emmanuel Medernach, John Cowan
;;; 
;;; Copyright © 2022 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
;;; file except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under
;;; the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
;;; ANY KIND, either express or implied. See the License for the specific language
;;; governing permissions and limitations under the License.

(define-library (srfi 208)
  
  (export make-nan
          nan-negative?
          nan-quiet?
          nan-payload
          nan=?)
  
  (import (lispkit base)
          (rename (lispkit internal) (make-nan internal-make-nan)))
  
  (begin
    
    (define (make-nan neg quiet payload . args)
      (internal-make-nan neg quiet payload))
    
    (define (nan=? nan1 nan2)
      (assert (nan? nan1) (nan? nan2))
      (flbits=? nan1 nan2))
  )
)
;;; SRFI 209
;;; Enums and Enum Sets
;;; 
;;; Many procedures in many libraries accept arguments from a finite set (usually a fairly
;;; small one), or subsets of a finite set to describe one or more modes of operation.
;;; Offering a mechanism for dealing with such values fosters portable and readable code,
;;; much as records do for compound values, or multiple values for procedures computing
;;; several results.
;;;
;;; This SRFI provides abstractions similar to enums of Java version 5 and later. These
;;; are objects of a type disjoint from all others that are grouped into enum types
;;; (called enum classes in Java). In Java, each enum type declares the names and types
;;; of values associated with each object, but in this SRFI an enum object has exactly
;;; one value; this is useful when translating from C to record the numeric value, but
;;; has other uses as well.
;;; 
;;; Each enum has four properties: the enum type to which it belongs, its name (a symbol),
;;; its ordinal (an exact integer), and its value (any object). An enum type provides
;;; access to all the enums that belong to it by name or ordinal.
;;; 
;;; Enum sets are used to represent multiple enums that belong to the same type. They
;;; provide a subset of the operations provided by SRFI 113 general sets.
;;; 
;;; Copyright © 2020 Wolfgang Corcoran-Mathe. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
;;; CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;;
;;; LispKit Port:
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 209)
  
  (import (lispkit base)
          (srfi 1)
          (srfi 128)
          (except (srfi 151) bit-set? copy-bit)
          (srfi 145)
          (srfi 146)
          (srfi 162))
  
  (export enum-type?
          enum?
          enum-type-contains?
          enum=?
          enum<?
          enum>?
          enum<=?
          enum>=?
          make-enum-type
          enum-type
          enum-name
          enum-ordinal
          enum-value
          enum-name->enum
          enum-ordinal->enum
          enum-name->ordinal
          enum-name->value
          enum-ordinal->name
          enum-ordinal->value
          enum-type-size
          enum-min enum-max
          enum-type-enums
          enum-type-names
          enum-type-values
          enum-next
          enum-prev
          enum-type->enum-set
          enum-set
          list->enum-set
          enum-set-projection
          enum-set-copy
          enum-empty-set
          make-enumeration
          enum-set-universe
          enum-set-constructor
          enum-set-type
          enum-set-indexer
          enum-set?
          enum-set-contains?
          enum-set=?
          enum-set-member?
          enum-set-empty?
          enum-set-disjoint?
          enum-set<?
          enum-set>?
          enum-set<=?
          enum-set>=?
          enum-set-any?
          enum-set-every?
          enum-set-subset?
          enum-set-adjoin!
          enum-set-delete!
          enum-set-delete-all!
          enum-set-adjoin
          enum-set-delete
          enum-set-delete-all
          enum-set-size
          enum-set->list
          enum-set-map->list
          enum-set-for-each
          enum-set-filter
          enum-set-remove
          enum-set-count
          enum-set-fold
          enum-set->enum-list
          enum-set-union
          enum-set-intersection
          enum-set-difference
          enum-set-xor
          enum-set-complement
          enum-set-union!
          enum-set-intersection!
          enum-set-difference!
          enum-set-xor!
          enum-set-complement!
          make-enum-comparator
          define-enum
          define-enumeration)

  (begin
    
    ;;;; Utility

    (define (exact-natural? obj)
      (and (exact-integer? obj) (not (negative? obj))))
    
    ;;;; Types
    
    (define-record-type <enum-type>
      (make-raw-enum-type enum-vector name-table comparator)
      enum-type?
      (enum-vector enum-type-enum-vector set-enum-type-enum-vector!)
      (name-table enum-type-name-table set-enum-type-name-table!)
      (comparator enum-type-comparator set-enum-type-comparator!))
    
    (define-record-type <enum>
      (make-enum type name ordinal value)
      enum?
      (type enum-type)
      (name enum-name)
      (ordinal enum-ordinal)
      (value enum-value))
    
    (define (make-enum-type names+vals)
      (assume (or (pair? names+vals) (null? names+vals)))
      (let* ((type (make-raw-enum-type #f #f #f))
             (enums (generate-enums type names+vals)))
        (set-enum-type-enum-vector! type (list->vector enums))
        (set-enum-type-name-table! type (make-name-table enums))
        (set-enum-type-comparator! type (make-enum-comparator type))
        type))
    
    (define (generate-enums type names+vals)
      (map (lambda (elt ord)
             (cond ((and (pair? elt) (= 2 (length elt)) (symbol? (car elt)))
                    (make-enum type (car elt) ord (cadr elt)))
                   ((symbol? elt) (make-enum type elt ord ord))
                   (else (error "make-enum-type: invalid argument" elt))))
           names+vals
           (iota (length names+vals))))
    
    (define symbol-comparator
      (make-comparator symbol?
                       eqv?
                       (lambda (sym1 sym2)
                         (string<? (symbol->string sym1)
                                   (symbol->string sym2)))
                       symbol-hash))
    
    (define (make-name-table enums)
      (mapping-unfold null?
                      (lambda (enums)
                        (values (enum-name (car enums)) (car enums)))
                      cdr
                      enums
                      symbol-comparator))
    
    (define (%enum-type=? etype1 etype2)
      (eqv? etype1 etype2))
    
    (define (make-enum-comparator type)
      (make-comparator
       (lambda (obj) (and (enum? obj) (eq? (enum-type obj) type)))
       eq?
       (lambda (enum1 enum2) (< (enum-ordinal enum1) (enum-ordinal enum2)))
       (lambda (enum) (symbol-hash (enum-name enum)))))
    
    ;;;; Predicates
    
    (define (enum-type-contains? type enum)
      (assume (enum-type? type))
      (assume (enum? enum))
      ((comparator-type-test-predicate (enum-type-comparator type)) enum))
    
    (define (%enum-type-contains?/no-check type enum)
      ((comparator-type-test-predicate (enum-type-comparator type)) enum))
    
    (define (%well-typed-enum? type obj)
      (and (enum? obj) (%enum-type-contains?/no-check type obj)))
    
    (define (%compare-enums compare enums)
      (assume (and (pair? enums) (pair? (cdr enums)))
              "invalid number of arguments")
      (assume (enum? (car enums)))
      (let ((type (enum-type (car enums))))
        (assume (every (lambda (e) (%well-typed-enum? type e)) (cdr enums))
                "invalid arguments")
        (apply compare (enum-type-comparator type) enums)))
    
    (define (enum=? enum1 enum2 . enums)
      (assume (enum? enum1))
      (let* ((type (enum-type enum1))
             (comp (enum-type-comparator type)))
        (cond ((null? enums)                            ; fast path
               (assume (%well-typed-enum? type enum2) "enum=?: invalid argument")
               ((comparator-equality-predicate comp) enum1 enum2))
              (else                                     ; variadic path
               (assume (every (lambda (e) (%well-typed-enum? type e)) enums)
                       "enum=?: invalid arguments")
               (apply =? comp enum1 enum2 enums)))))
    
    (define (enum<? . enums) (%compare-enums <? enums))
    
    (define (enum>? . enums) (%compare-enums >? enums))
    
    (define (enum<=? . enums) (%compare-enums <=? enums))
    
    (define (enum>=? . enums) (%compare-enums >=? enums))
    
    ;;;; Enum finders
    
    ;;; Core procedures
    
    (define (enum-name->enum type name)
      (assume (enum-type? type))
      (assume (symbol? name))
      (mapping-ref/default (enum-type-name-table type) name #f))
    
    (define (enum-ordinal->enum enum-type ordinal)
      (assume (enum-type? enum-type))
      (assume (exact-natural? ordinal))
      (and (< ordinal (enum-type-size enum-type))
           (vector-ref (enum-type-enum-vector enum-type) ordinal)))
    
    ;;; Derived procedures
    
    (define (%enum-project type finder key proc)
      (assume (enum-type? type))
      (cond ((finder type key) => proc)
            (else (error "no enum found" type key))))
    
    (define (enum-name->ordinal type name)
      (assume (symbol? name))
      (%enum-project type enum-name->enum name enum-ordinal))
    
    (define (enum-name->value type name)
      (assume (symbol? name))
      (%enum-project type enum-name->enum name enum-value))
    
    (define (enum-ordinal->name type ordinal)
      (assume (exact-natural? ordinal))
      (%enum-project type enum-ordinal->enum ordinal enum-name))
    
    (define (enum-ordinal->value type ordinal)
      (assume (exact-natural? ordinal))
      (%enum-project type enum-ordinal->enum ordinal enum-value))
    
    ;;;; Enum type accessors
    
    (define (enum-type-size type)
      (assume (enum-type? type))
      (vector-length (enum-type-enum-vector type)))
    
    (define (enum-min type)
      (assume (enum-type? type))
      (vector-ref (enum-type-enum-vector type) 0))
    
    (define (enum-max type)
      (assume (enum-type? type))
      (let ((vec (enum-type-enum-vector type)))
        (vector-ref vec (- (vector-length vec) 1))))
    
    (define (enum-type-enums type)
      (assume (enum-type? type))
      (vector->list (enum-type-enum-vector type)))
    
    (define (enum-type-names type)
      (assume (enum-type? type))
      (let ((vec (enum-type-enum-vector type)))
        (list-tabulate (vector-length vec)
                       (lambda (n) (enum-name (vector-ref vec n))))))
    
    (define (enum-type-values type)
      (assume (enum-type? type))
      (let ((vec (enum-type-enum-vector type)))
        (list-tabulate (vector-length vec)
                       (lambda (n) (enum-value (vector-ref vec n))))))
    
    ;;;; Enum object procedures
    
    (define (enum-next enum)
      (assume (enum? enum))
      (enum-ordinal->enum (enum-type enum) (+ (enum-ordinal enum) 1)))
    
    (define (enum-prev enum)
      (assume (enum? enum))
      (let ((ord (enum-ordinal enum)))
        (and (> ord 0)
             (enum-ordinal->enum (enum-type enum) (- ord 1)))))
    
    ;;;; Enum set constructors
    
    (define-record-type <enum-set>
      (make-enum-set type bitmap)
      enum-set?
      (type enum-set-type)
      (bitmap enum-set-bitmap set-enum-set-bitmap!))
    
    (define (enum-empty-set type)
      (assume (enum-type? type))
      (make-enum-set type 0))
    
    (define (enum-type->enum-set type)
      (assume (enum-type? type))
      (make-enum-set type (- (expt 2 (enum-type-size type)) 1)))
    
    (define (enum-set type . enums) (list->enum-set type enums))
    
    (define (list->enum-set type enums)
      (assume (or (pair? enums) (null? enums)))
      (make-enum-set
       type
       (fold (lambda (e b)
               (assume (%well-typed-enum? type e) "ill-typed enum")
               (bitwise-ior b (expt 2 (enum-ordinal e))))
             0
             enums)))
    
    ;; Returns a set of enums drawn from the enum-type/-set src with
    ;; the same names as the enums of eset.
    (define (enum-set-projection src eset)
      (assume (or (enum-type? src) (enum-set? src)))
      (assume (enum-set? eset))
      (let ((type (if (enum-type? src) src (enum-set-type src))))
        (list->enum-set
         type
         (enum-set-map->list (lambda (enum)
                               (enum-name->enum type (enum-name enum)))
                             eset))))
    
    (define (enum-set-copy eset)
      (make-enum-set (enum-set-type eset) (enum-set-bitmap eset)))
    
    ;; [Deprecated]
    (define (make-enumeration names)
      (enum-type->enum-set (make-enum-type (zip names names))))
    
    ;; [Deprecated]
    (define (enum-set-universe eset)
      (assume (enum-set? eset))
      (enum-type->enum-set (enum-set-type eset)))
    
    ;; [Deprecated]  Returns a procedure which takes a list of symbols
    ;; and returns an enum set containing the corresponding enums.  This
    ;; extracts the type of eset, but otherwise ignores this argument.
    (define (enum-set-constructor eset)
      (assume (enum-set? eset))
      (let ((type (enum-set-type eset)))
        (lambda (names)
          (list->enum-set type
                          (map (lambda (sym) (enum-name->enum type sym))
                               names)))))
    
    ;; [Deprecated] Returns a procedure which takes a symbol and returns
    ;; the corresponding enum ordinal or #f.  This doesn't make any use
    ;; of eset, beyond pulling out its enum type.
    (define (enum-set-indexer eset)
      (assume (enum-set? eset))
      (let ((type (enum-set-type eset)))
        (lambda (name)
          (cond ((enum-name->enum type name) => enum-ordinal)
                (else #f)))))
    
    ;;;; Enum set predicates
    
    (define (enum-set-contains? eset enum)
      (assume (enum-set? eset))
      (assume (%well-typed-enum? (enum-set-type eset) enum)
              "enum-set-contains?: invalid argument")
      (not (zero? (bitwise-and (enum-set-bitmap eset)
                               (expt 2 (enum-ordinal enum))))))
    
    ;; FIXME: Avoid double (type, then set) lookup.
    (define (enum-set-member? name eset)
      (assume (symbol? name))
      (assume (enum-set? eset))
      (let ((ord (enum-name->ordinal (enum-set-type eset) name)))
        (not (zero? (bitwise-and (enum-set-bitmap eset) (expt 2 ord))))))
    
    (define (%enum-set-type=? eset1 eset2)
      (%enum-type=? (enum-set-type eset1) (enum-set-type eset2)))
    
    (define (enum-set-empty? eset)
      (assume (enum-set? eset))
      (zero? (enum-set-bitmap eset)))
    
    (define (enum-set-disjoint? eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-type=? (enum-set-type eset1) (enum-set-type eset2)))
      (zero? (bitwise-and (enum-set-bitmap eset1) (enum-set-bitmap eset2))))
    
    (define (enum-set=? eset1 eset2)
      (= (enum-set-bitmap eset1) (enum-set-bitmap eset2)))
    
    (define (enum-set<? eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-type=? (enum-set-type eset1) (enum-set-type eset2)))
      (not (zero? (bitwise-andc1 (enum-set-bitmap eset1)
                                 (enum-set-bitmap eset2)))))
    
    (define (enum-set>? eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-type=? (enum-set-type eset1) (enum-set-type eset2)))
      (not (zero? (bitwise-andc2 (enum-set-bitmap eset1)
                                 (enum-set-bitmap eset2)))))
    
    (define (enum-set<=? eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-type=? (enum-set-type eset1) (enum-set-type eset2)))
      (zero? (bitwise-andc2 (enum-set-bitmap eset1)
                            (enum-set-bitmap eset2))))
    
    (define (enum-set>=? eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-type=? (enum-set-type eset1) (enum-set-type eset2)))
      (zero? (bitwise-andc1 (enum-set-bitmap eset1)
                            (enum-set-bitmap eset2))))
    
    (define (%enum-set->name-mapping eset)
      (mapping-unfold null?
                      (lambda (syms) (values (car syms) #t))
                      cdr
                      (enum-set-map->list enum-name eset)
                      symbol-comparator))
    
    (define (enum-set-subset? eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (mapping<=? symbol-comparator
                  (%enum-set->name-mapping eset1)
                  (%enum-set->name-mapping eset2)))
    
    (define (enum-set-any? pred eset)
      (assume (procedure? pred))
      (call-with-current-continuation
       (lambda (return)
         (enum-set-fold (lambda (e _) (and (pred e) (return #t)))
                        #f
                        eset))))
    
    (define (enum-set-every? pred eset)
      (assume (procedure? pred))
      (call-with-current-continuation
       (lambda (return)
         (enum-set-fold (lambda (e _) (or (pred e) (return #f)))
                        #t
                        eset))))
    
    ;;;; Enum set mutators
    
    ;; Fold a list of enums into a bitmap of their ordinals.
    (define (%enum-list->bitmap type enums)
      (fold (lambda (enum b)
              (assume (%well-typed-enum? type enum))
              (bitwise-ior b (expt 2 (enum-ordinal enum))))
            0
            enums))
    
    (define enum-set-adjoin
      (case-lambda
        ((eset enum)                 ; fast path
         (assume (enum-set? eset))
         (let ((type (enum-set-type eset)))
           (assume (%well-typed-enum? type enum)
                   "enum-set-adjoin: invalid argument"
                   enum)
           (make-enum-set
            type
            (bitwise-ior (enum-set-bitmap eset)
                         (expt 2 (enum-ordinal enum))))))
        ((eset . enums)              ; variadic path
         (assume (enum-set? eset))
         (let ((type (enum-set-type eset)))
           (make-enum-set
            type
            (bitwise-ior (enum-set-bitmap eset)
                         (%enum-list->bitmap type enums)))))))
    
    (define enum-set-adjoin!
      (case-lambda
        ((eset enum)                 ; fast path
         (assume (enum-set? eset))
         (assume (%well-typed-enum? (enum-set-type eset) enum))
         (set-enum-set-bitmap!
          eset
          (bitwise-ior (enum-set-bitmap eset)
                       (expt 2 (enum-ordinal enum))))
         eset)
        ((eset . enums)              ; variadic path
         (assume (enum-set? eset))
         (set-enum-set-bitmap!
          eset
          (bitwise-ior (enum-set-bitmap eset)
                       (%enum-list->bitmap (enum-set-type eset) enums)))
         eset)))
    
    (define enum-set-delete
      (case-lambda
        ((eset enum)                ; fast path
         (assume (enum-set? eset))
         (let ((type (enum-set-type eset)))
           (assume (%well-typed-enum? type enum) "ill-typed enum" enum type)
           (make-enum-set type
                          (bitwise-andc2 (enum-set-bitmap eset)
                                         (expt 2 (enum-ordinal enum))))))
        ((eset . enums)             ; variadic path
         (enum-set-delete-all eset enums))))
    
    (define enum-set-delete!
      (case-lambda
        ((eset enum)                ; fast path
         (assume (enum-set? eset))
         (let ((type (enum-set-type eset)))
           (assume (%well-typed-enum? type enum) "ill-typed enum" enum type)
           (set-enum-set-bitmap!
            eset
            (bitwise-andc2 (enum-set-bitmap eset)
                           (expt 2 (enum-ordinal enum))))
           eset))
        ((eset . enums)             ; variadic path
         (enum-set-delete-all! eset enums))))
    
    (define (enum-set-delete-all eset enums)
      (assume (enum-set? eset))
      (assume (or (pair? enums) (null? enums)))
      (let ((type (enum-set-type eset)))
        (make-enum-set type
                       (bitwise-andc2 (enum-set-bitmap eset)
                                      (%enum-list->bitmap type enums)))))
    
    (define (enum-set-delete-all! eset enums)
      (assume (enum-set? eset))
      (assume (or (pair? enums) (null? enums)))
      (if (null? enums)
          eset
          (begin
           (set-enum-set-bitmap!
            eset
            (bitwise-andc2 (enum-set-bitmap eset)
                           (%enum-list->bitmap (enum-set-type eset) enums)))
           eset)))
    
    ;;;; Enum set operations
    
    (define (enum-set-size eset)
      (assume (enum-set? eset))
      (bit-count (enum-set-bitmap eset)))
    
    (define (enum-set->enum-list eset)
      (assume (enum-set? eset))
      (enum-set-fold cons '() eset))
    
    (define (enum-set->list eset)
      (enum-set-map->list enum-name eset))
    
    (define (enum-set-map->list proc eset)
      (assume (procedure? proc))
      (enum-set-fold (lambda (e res) (cons (proc e) res)) '() eset))
    
    (define (enum-set-count pred eset)
      (assume (procedure? pred))
      (enum-set-fold (lambda (e n) (if (pred e) (+ n 1) n)) 0 eset))
    
    ;; TODO: Optimize this.
    (define (enum-set-filter pred eset)
      (assume (enum-set? eset))
      (let ((type (enum-set-type eset))
            (bitmap (enum-set-bitmap eset)))
        (make-enum-set
         type
         (fold (lambda (p m)
                 (let ((i (car p)) (b (cadr p)))
                   (if (and b (pred (enum-ordinal->enum type i)))
                       (bitwise-ior m (expt 2 i))
                       m)))
               0
               (zip (iota (integer-length bitmap))
                    (bits->list bitmap))))))
    
    ;; TODO: Optimize this.
    (define (enum-set-remove pred eset)
      (assume (enum-set? eset))
      (let ((type (enum-set-type eset))
            (bitmap (enum-set-bitmap eset)))
        (make-enum-set
         type
         (fold (lambda (p m)
                 (let ((i (car p)) (b (cadr p)))
                   (if (and b (pred (enum-ordinal->enum type i)))
                       m
                       (bitwise-ior m (expt 2 i)))))
               0
               (zip (iota (integer-length bitmap))
                    (bits->list bitmap))))))
    
    (define (enum-set-for-each proc eset)
      (assume (procedure? proc))
      (enum-set-fold (lambda (e _) (proc e)) '() eset))
    
    ;; TODO: Optimize this.
    (define (enum-set-fold proc nil eset)
      (assume (procedure? proc))
      (assume (enum-set? eset))
      (let ((type (enum-set-type eset))
            (bitmap (enum-set-bitmap eset)))
        (cadr
         (fold-right (lambda (b p)
                       (let ((i (car p)) (state (cadr p)))
                         (if b
                             (list (- i 1)
                                   (proc (enum-ordinal->enum type i) state))
                             (list (- i 1) state))))
                     (list (- (integer-length bitmap) 1) nil)
                     (bits->list bitmap)))))
    
    ;;;; Enum set logical operations
    
    (define (%enum-set-logical-op proc eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-set-type=? eset1 eset2) "enum sets have different types")
      (make-enum-set
       (enum-set-type eset1)
       (proc (enum-set-bitmap eset1) (enum-set-bitmap eset2))))
    
    (define (%enum-set-logical-op! proc eset1 eset2)
      (assume (enum-set? eset1))
      (assume (enum-set? eset2))
      (assume (%enum-set-type=? eset1 eset2) "enum sets have different types")
      (set-enum-set-bitmap! eset1
                            (proc (enum-set-bitmap eset1)
                                  (enum-set-bitmap eset2)))
      eset1)
    
    (define (enum-set-union eset1 eset2)
      (%enum-set-logical-op bitwise-ior eset1 eset2))
    
    (define (enum-set-intersection eset1 eset2)
      (%enum-set-logical-op bitwise-and eset1 eset2))
    
    (define (enum-set-difference eset1 eset2)
      (%enum-set-logical-op bitwise-andc2 eset1 eset2))
    
    (define (enum-set-xor eset1 eset2)
      (%enum-set-logical-op bitwise-xor eset1 eset2))
    
    (define (enum-set-union! eset1 eset2)
      (%enum-set-logical-op! bitwise-ior eset1 eset2))
    
    (define (enum-set-intersection! eset1 eset2)
      (%enum-set-logical-op! bitwise-and eset1 eset2))
    
    (define (enum-set-difference! eset1 eset2)
      (%enum-set-logical-op! bitwise-andc2 eset1 eset2))
    
    (define (enum-set-xor! eset1 eset2)
      (%enum-set-logical-op! bitwise-xor eset1 eset2))
    
    (define (enum-set-complement eset)
      (assume (enum-set? eset))
      (%enum-set-logical-op bitwise-andc1 eset (enum-set-universe eset)))
    
    (define (enum-set-complement! eset)
      (assume (enum-set? eset))
      (%enum-set-logical-op! bitwise-andc1 eset (enum-set-universe eset)))
    
    ;;;; Syntax
    
    ;; Defines a new enum-type T, binds type-name to a macro which
    ;; takes a symbol to an enum in T, and binds constructor to a
    ;; macro taking symbols to an enum set of type T.
    (define-syntax define-enum
      (syntax-rules ()
        ((_ type-name (name-val ...) constructor)
         (begin
          (define etype (make-enum-type '(name-val ...)))
          (define-syntax type-name
            (syntax-rules ()
              ((_ name)
               (enum-name->enum etype 'name))))
          (define-syntax constructor
            (syntax-rules ()
              ((_ . names)
               (list->enum-set etype
                               (map (lambda (s)
                                      (enum-name->enum etype s))
                                    'names)))))))))
    
    ;; [Deprecated] As define-enum, except that type-name is bound to
    ;; a macro that returns its symbol argument if the corresponding
    ;; enum is in the new type.
    (define-syntax define-enumeration
      (syntax-rules ()
        ((_ type-name (name-val ...) constructor)
         (begin
          (define etype (make-enum-type '(name-val ...)))
          (define-syntax type-name
            (syntax-rules ()
              ((_ name)
               (and (enum-name->enum etype 'name) 'name))))
          (define-syntax constructor
            (syntax-rules ()
              ((_ . names)
               (list->enum-set etype
                               (map (lambda (s)
                                      (enum-name->enum etype s))
                                    'names)))))))))
  )
)

;;; SRFI 210
;;; Procedures and Syntax for Multiple Values
;;;
;;; This SRFI extends the Scheme standard with a number of procedures and syntax
;;; dealing with multiple values, including syntax to create lists and vectors
;;; from expressions returning multiple values and procedures returning the elements
;;; of a list or vector as multiple values.
;;; 
;;; Copyright © 2020 Marc Nieper-Wißkirchen. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 210)
  
  (export apply/mv
          call/mv
          list/mv
          vector/mv
          box/mv
          value/mv
          arity
          set!-values
          with-values
          case-receive
          bind/mv
          list-values
          vector-values
          box-values
          value
          identity
          compose
          map-values
          bind/list
          bind/box
          bind)
  
  (import (except (lispkit base) value identity))

  (begin
    
    ;;;;;;;;;;;;
    ;; Syntax ;;
    ;;;;;;;;;;;;
    
    (define-syntax apply/mv
      (syntax-rules ()
        ((apply/mv operator operand1 ... producer)
         (letrec-syntax
             ((aux (syntax-rules ::: ()
                     ((aux %operator () ((%operand1 arg1) :::) %producer)
                      (let-values (((proc) %operator)
                                   ((arg1) %operand1) :::
                                   (args %producer))
                        (apply proc arg1 ::: args)))
                     ((aux %operator (%operand1 operand2 :::) (temp :::) %producer)
                      (aux %operator (operand2 :::) (temp ::: (%operand1 arg1))
                           %producer)))))
           (aux operator (operand1 ...) () producer)))))
    
    (define-syntax call/mv
      (syntax-rules ()
        ((call/mv consumer producer1 ...)
         (letrec-syntax
             ((aux (syntax-rules ::: ()
                     ((aux %consumer () ((%producer1 args1) :::))
                      (let-values (((proc) %consumer)
                                   (args1 %producer1) :::)
                        (apply proc (append args1 :::))))
                     ((aux %consumer (%producer1 producer2 :::) (temp :::))
                      (aux %consumer (producer2 :::) (temp ::: (%producer1 args1)))))))
           (aux consumer (producer1 ...) ())))))
    
    (define-syntax list/mv
      (syntax-rules ()
        ((list/mv element1 ... producer)
         (apply/mv list element1 ... producer))))
    
    (define-syntax vector/mv
      (syntax-rules ()
        ((vector/mv element1 ... producer)
         (apply/mv vector element1 ... producer))))
    
    (define-syntax box/mv
      (syntax-rules ()
        ((box/mv element1 ... producer)
         (apply/mv box element1 ... producer))))
    
    (define-syntax value/mv
      (syntax-rules ()
        ((value/mv index operand1 ... producer)
         (apply/mv value index operand1 ... producer))))
    
    (define-syntax arity
      (syntax-rules ()
        ((arity producer)
         (let-values ((res producer))
           (length res)))))
    
    (define-syntax set!-values
      (syntax-rules ()
        ((set!-values (var1 ...) producer)
         (letrec-syntax
             ((aux (syntax-rules ::: ()
                     ((aux () ((%var1 temp1) :::) %producer)
                      (let-values (((temp1 ::: . temp*) %producer))
                        (set! %var1 temp1) :::))
                     ((aux (%var1 var2 :::) (temp :::) %producer)
                      (aux (var2 :::) (temp ::: (%var1 temp1)) %producer)))))
           (aux (var1 ... ) () producer)))
        ((set!-values (var1 ... . var*) producer)
         (letrec-syntax
             ((aux (syntax-rules ::: ()
                     ((aux () ((%var1 temp1) ::: (%var* temp*)) %producer)
                      (let-values (((temp1 ::: . temp*) %producer))
                        (set! %var1 temp1) :::
                        (set! %var* temp*)))
                     ((aux (%var1 var2 :::) (temp :::) %producer)
                      (aux (var2 :::) (temp ::: (%var1 temp1)) %producer)))))
           (aux (var1 ... var*) () producer)))
        ((set!-values var* producer)
         (let-values ((temp*) producer)
           (set! var* temp*)))))
    
    (define-syntax with-values
      (syntax-rules ()
        ((with-values producer consumer)
         (apply/mv consumer producer))))
    
    (define-syntax case-receive
      (syntax-rules ()
        ((case-receive producer clause ...)
         (with-values producer
           (case-lambda clause ...)))))
    
    (define-syntax bind/mv
      (syntax-rules ()
        ((bind/mv producer transducer ...)
         (bind/list (list/mv producer) transducer ...))))
    
    ;;;;;;;;;;;;;;;;
    ;; Procedures ;;
    ;;;;;;;;;;;;;;;;
    
    (define (list-values lis)
      (apply values lis))
    
    (define (vector-values vec)
      (list-values (vector->list vec)))
    
    (define box-values unbox)
    
    (define (value k . objs)
      (list-ref objs k))
    
    (define identity values)
    
    (define compose
      (case-lambda
        (() identity)
        ((transducer . transducers)
         (let f ((transducer transducer) (transducers transducers))
           (if (null? transducers)
               transducer
               (let ((composition (f (car transducers) (cdr transducers))))
                 (lambda args
                   (apply/mv composition (apply transducer args)))))))))
    
    (define (map-values proc)
      (lambda args
        (list-values (map proc args))))
    
    (define (bind/list lis . transducers)
      (list-values (fold-left (lambda (lis transducer)
                                (list/mv (apply transducer lis)))
                              lis
                              transducers)))
    
    (define (bind/box bx . transducers)
      (apply bind/list (list/mv (unbox bx)) transducers))
    
    (define (bind obj . transducers)
      (apply bind/list (list obj) transducers))
  )
)
;;; SRFI 214
;;; Flexvectors
;;; 
;;; A flexvector, also known as a dynamic array or an arraylist, is a mutable vector-like
;;; data structure with an adjustable size. Flexvectors allow fast random access and fast
;;; insertion/removal at the end. This SRFI defines a suite of operations on flexvectors,
;;; modeled after SRFI 133's vector operations.
;;; 
;;; Copyright © 2020-2021 Adam Nelson. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 214)
  
  (export ; Constructors
          make-flexvector
          flexvector
          flexvector-unfold
          flexvector-unfold-right
          flexvector-copy
          flexvector-reverse-copy
          flexvector-append
          flexvector-concatenate
          flexvector-append-subvectors
          ; Predicates
          flexvector?
          flexvector-empty?
          flexvector=?
          ; Selectors
          flexvector-ref
          flexvector-front
          flexvector-back
          flexvector-length
          ; Mutators
          flexvector-add!
          flexvector-add-front!
          flexvector-add-back!
          flexvector-remove!
          flexvector-remove-front!
          flexvector-remove-back!
          flexvector-add-all!
          flexvector-remove-range!
          flexvector-clear!
          flexvector-set!
          flexvector-swap!
          flexvector-fill!
          flexvector-reverse!
          flexvector-copy!
          flexvector-reverse-copy!
          flexvector-append!
          ; Iteration
          flexvector-fold
          flexvector-fold-right
          flexvector-map
          flexvector-map!
          flexvector-map/index
          flexvector-map/index!
          flexvector-append-map
          flexvector-append-map/index
          flexvector-filter
          flexvector-filter!
          flexvector-filter/index
          flexvector-filter/index!
          flexvector-for-each
          flexvector-for-each/index
          flexvector-count
          flexvector-cumulate
          ; Searching
          flexvector-index
          flexvector-index-right
          flexvector-skip
          flexvector-skip-right
          flexvector-binary-search
          flexvector-any
          flexvector-every
          flexvector-partition 
          ; Conversion
          flexvector->vector
          flexvector->list
          flexvector->string
          vector->flexvector
          list->flexvector
          string->flexvector
          reverse-flexvector->list
          reverse-list->flexvector
          generator->flexvector
          flexvector->generator)
        
  (import (lispkit base)
          (srfi 1)
          (srfi 145))
  
  (begin
    
    (define-record-type Flexvector
      (%make-flexvector fv-vector fv-length)
      flexvector?
      (fv-vector vec set-vec!)
      (fv-length flexvector-length set-flexvector-length!))
    
    (define (cap fv)
      (vector-length (vec fv)))
    
    (define (grow! fv)
      (define old-vec (vec fv))
      (define new-vec (make-vector (quotient (* (vector-length old-vec) 3) 2)))
      (vector-copy! new-vec 0 old-vec)
      (set-vec! fv new-vec)
      new-vec)
    
    (define make-flexvector
      (case-lambda
        ((size)
          (assume (>= size 0))
          (%make-flexvector (make-vector (max size 4)) size))
        ((size fill)
          (assume (>= size 0))
          (%make-flexvector (make-vector (max size 4) fill) size))))
    
    (define (flexvector . xs)
      (if (null? xs)
          (%make-flexvector (make-vector 4) 0)
          (list->flexvector xs)))
    
    (define (flexvector-ref fv index)
      (assume (flexvector? fv))
      (assume (integer? index))
      (assume (< -1 index (flexvector-length fv)))
      (vector-ref (vec fv) index))
    
    (define (flexvector-set! fv index x)
      (assume (flexvector? fv))
      (assume (integer? index))
      (assume (< -1 index (flexvector-length fv)))
      (let ((last-value (vector-ref (vec fv) index)))
        (vector-set! (vec fv) index x)
        last-value))
    
    (define flexvector-add!
      (case-lambda
        ((fv i x)
          (assume (flexvector? fv))
          (assume (integer? i))
          (let* ((len (flexvector-length fv))
                 (v (if (< len (cap fv)) (vec fv) (grow! fv))))
            (assume (<= 0 i len))
            (vector-copy! v (+ i 1) v i len)
            (vector-set! v i x)
            (set-flexvector-length! fv (+ len 1))
            fv))
        ((fv i . xs)
          (flexvector-add-all! fv i xs))))
    
    (define flexvector-add-back!
      (case-lambda
        ((fv x)
          (assume (flexvector? fv))
          (let* ((len (flexvector-length fv))
                 (v (if (< len (cap fv)) (vec fv) (grow! fv))))
            (vector-set! v len x)
            (set-flexvector-length! fv (+ len 1))
            fv))
        ((fv x . xs)
          (flexvector-add-back! fv x)
          (apply flexvector-add-back! fv xs))))
    
    (define (flexvector-add-all! fv i xs)
      (assume (flexvector? fv))
      (assume (integer? i))
      (assume (list? xs))
      (let* ((len (flexvector-length fv))
             (xv (list->vector xs))
             (xvlen (vector-length xv))
             (v (let lp ((v (vec fv)))
                  (if (< (+ len xvlen) (vector-length v)) v (lp (grow! fv))))))
        (assume (<= 0 i len))
        (vector-copy! v (+ i xvlen) v i len)
        (vector-copy! v i xv 0 xvlen)
        (set-flexvector-length! fv (+ len xvlen))
        fv))
    
    (define (flexvector-remove! fv i)
      (assume (flexvector? fv))
      (assume (integer? i))
      (assume (<= 0 i (- (flexvector-length fv) 1)))
      (let ((removed (flexvector-ref fv i)))
        (flexvector-remove-range! fv i (+ i 1))
        removed))
    
    (define (flexvector-remove-range! fv start end)
      (assume (flexvector? fv))
      (let ((len (flexvector-length fv)))
        (when (< start 0) (set! start 0))
        (when (>= end len) (set! end len))
        (assume (<= start end))
        (vector-copy! (vec fv) start (vec fv) end)
        (let ((new-len (- len (- end start))))
          (vector-fill! (vec fv) #f new-len len)
          (set-flexvector-length! fv new-len)))
      fv)
    
    (define (flexvector-clear! fv)
      (assume (flexvector? fv))
      (set-vec! fv (make-vector 4))
      (set-flexvector-length! fv 0)
      fv)
    
    (define vector->flexvector
      (case-lambda
        ((vec)
          (assume (vector? vec))
          (vector->flexvector vec 0 (vector-length vec)))
        ((vec start)
          (assume (vector? vec))
          (vector->flexvector vec start (vector-length vec)))
        ((vec start end)
          (assume (vector? vec))
          (assume (<= 0 start end (vector-length vec)))
          (let ((len (- end start)))
            (cond
              ((< len 4)
                (let ((new-vec (make-vector 4)))
                  (vector-copy! new-vec 0 vec start end)
                  (%make-flexvector new-vec len)))
              (else
                (%make-flexvector (vector-copy vec start end) len)))))))
    
    (define flexvector->vector
      (case-lambda
        ((fv)
          (assume (flexvector? fv))
          (flexvector->vector fv 0 (flexvector-length fv)))
        ((fv start)
          (assume (flexvector? fv))
          (flexvector->vector fv start (flexvector-length fv)))
        ((fv start end)
          (assume (flexvector? fv))
          (assume (<= 0 start end (flexvector-length fv)))
          (vector-copy (vec fv) start end))))
    
    (define (list->flexvector xs)
      (let* ((vec (list->vector xs))
             (len (vector-length vec)))
        (cond
          ((< len 4)
            (let ((new-vec (make-vector 4)))
              (vector-copy! new-vec 0 vec)
              (%make-flexvector new-vec len)))
          (else
            (%make-flexvector vec len)))))
    
    (define flexvector-filter/index!
      (case-lambda
        ((pred? fv)
          (assume (flexvector? fv))
          (let ((v (vec fv)) (len (flexvector-length fv)))
            (let lp ((i 0) (j 0))
              (cond
                ((>= i len)
                  (set-flexvector-length! fv j)
                  fv)
                ((pred? i (vector-ref v i))
                  (unless (= i j) (vector-set! v j (vector-ref v i)))
                  (lp (+ i 1) (+ j 1)))
                (else
                  (lp (+ i 1) j))))))
        ((pred? fv . fvs)
          (assume (flexvector? fv))
          (let ((v (vec fv)) (len (flexvector-length fv)))
            (let lp ((i 0) (j 0))
              (cond
                ((>= i len)
                  (set-flexvector-length! fv j)
                  fv)
                ((apply pred?
                        i
                        (vector-ref v i)
                        (map (lambda (fv) (flexvector-ref fv i)) fvs))
                  (unless (= i j) (vector-set! v j (vector-ref v i)))
                  (lp (+ i 1) (+ j 1)))
                (else
                  (lp (+ i 1) j))))))))
    
    (define flexvector-copy
      (case-lambda
        ((fv)
          (assume (flexvector? fv))
          (%make-flexvector (vector-copy (vec fv))
                            (flexvector-length fv)))
        ((fv start)
          (assume (flexvector? fv))
          (flexvector-copy fv start (flexvector-length fv)))
        ((fv start end)
          (assume (flexvector? fv))
          (assume (<= 0 start end (flexvector-length fv)))
          (vector->flexvector (vector-copy (vec fv) start end)))))
    
    (define flexvector-copy!
      (case-lambda
        ((to at from)
          (assume (flexvector? from))
          (flexvector-copy! to at from 0 (flexvector-length from)))
        ((to at from start)
          (assume (flexvector? from))
          (flexvector-copy! to at from start (flexvector-length from)))
        ((to at from start end)
          (assume (flexvector? to))
          (assume (<= 0 at (flexvector-length to)))
          (assume (<= 0 start end (flexvector-length from)))
          (let* ((vf (vec from))
                 (lt (+ (flexvector-length to) (- end start)))
                 (vt (let lp ((v (vec to)))
                       (if (< lt (vector-length v)) v (lp (grow! to))))))
            (vector-copy! vt at vf start end)
            (set-flexvector-length! to
                                    (max (flexvector-length to) (+ at (- end start))))))))  
  )
  
  (begin
    (define flexvector-unfold
      (case-lambda
        ((p f g seed)
          (let ((fv (flexvector)))
            (assume (procedure? p))
            (assume (procedure? f))
            (assume (procedure? g))
            (do ((seed seed (g seed))) ((p seed) fv)
              (flexvector-add-back! fv (f seed)))))
        ((p f g . seeds)
          (let ((fv (flexvector)))
            (assume (procedure? p))
            (assume (procedure? f))
            (assume (procedure? g))
            (do ((seeds seeds (let-values ((seeds (apply g seeds))) seeds)))
              ((apply p seeds) fv)
              (flexvector-add-back! fv (apply f seeds)))))))
    
    (define (flexvector-unfold-right . args)
      (let ((fv (apply flexvector-unfold args)))
        (flexvector-reverse! fv)
        fv))
    
    (define flexvector-fill!
      (case-lambda
        ((fv fill)
          (flexvector-fill! fv fill 0 (flexvector-length fv)))
        ((fv fill start)
          (flexvector-fill! fv fill start (flexvector-length fv)))
        ((fv fill start end)
          (let ((actual-end (min end (flexvector-length fv))))
            (do ((i (max 0 start) (+ i 1)))
              ((>= i actual-end))
              (flexvector-set! fv i fill))))))
    
    (define (flexvector-reverse-copy . args)
      (let ((fv (apply flexvector-copy args)))
        (flexvector-reverse! fv)
        fv))
    
    (define flexvector-reverse-copy!
      (case-lambda
        ((to at from)
          (assume (flexvector? from))
          (flexvector-reverse-copy! to at from 0 (flexvector-length from)))
        ((to at from start)
          (assume (flexvector? from))
          (flexvector-reverse-copy! to at from start (flexvector-length from)))
        ((to at from start end)
          (flexvector-copy! to at from start end)
          (flexvector-reverse! to at (+ at (- end start))))))
    
    (define (flexvector-append! fv . fvs)
      (assume (flexvector? fv))
      (assume (every flexvector? fvs))
      (for-each
        (lambda (fv2) (flexvector-copy! fv (flexvector-length fv) fv2))
        fvs)
      fv)
    
    (define (flexvector-front fv)
      (assume (flexvector? fv))
      (assume (not (flexvector-empty? fv)))
      (flexvector-ref fv 0))
    
    (define (flexvector-back fv)
      (assume (flexvector? fv))
      (assume (not (flexvector-empty? fv)))
      (flexvector-ref fv (- (flexvector-length fv) 1)))
    
    (define flexvector-add-front!
      (case-lambda
        ((fv x) (flexvector-add! fv 0 x))
        ((fv . xs) (apply flexvector-add! fv 0 xs))))
    
    (define (flexvector-remove-front! fv)
      (assume (flexvector? fv))
      (assume (not (flexvector-empty? fv)))
      (flexvector-remove! fv 0))
    
    (define (flexvector-remove-back! fv)
      (assume (flexvector? fv))
      (assume (not (flexvector-empty? fv)))
      (flexvector-remove! fv (- (flexvector-length fv) 1)))
    
    (define (flexvector=? eq . o)
      (cond
        ((null? o) #t)
        ((null? (cdr o)) #t)
        (else
          (and (let* ((fv1 (car o))
                      (fv2 (cadr o))
                      (len (flexvector-length fv1)))
                 (and (= len (flexvector-length fv2))
                      (let lp ((i 0))
                        (or (>= i len)
                            (and (eq (flexvector-ref fv1 i) (flexvector-ref fv2 i))
                                 (lp (+ i 1)))))))
               (apply flexvector=? eq (cdr o))))))
    
    (define (flexvector-fold kons knil fv1 . o)
      (assume (procedure? kons))
      (assume (flexvector? fv1))
      (let ((len (flexvector-length fv1)))
        (if (null? o)
            (let lp ((i 0) (acc knil))
              (if (>= i len) acc (lp (+ i 1) (kons acc (flexvector-ref fv1 i)))))
            (let lp ((i 0) (acc knil))
              (if (>= i len)
                  acc
                  (lp (+ i 1)
                      (apply kons acc (flexvector-ref fv1 i)
                             (map (lambda (fv) (flexvector-ref fv i)) o))))))))
    
    (define (flexvector-fold-right kons knil fv1 . o)
      (assume (procedure? kons))
      (assume (flexvector? fv1))
      (let ((len (flexvector-length fv1)))
        (if (null? o)
            (let lp ((i (- len 1)) (acc knil))
              (if (negative? i) acc (lp (- i 1) (kons acc (flexvector-ref fv1 i)))))
            (let lp ((i (- len 1)) (acc knil))
              (if (negative? i)
                  acc
                  (lp (- i 1)
                      (apply kons acc (flexvector-ref fv1 i)
                             (map (lambda (fv) (flexvector-ref fv i)) o))))))))
    
    (define flexvector-for-each/index
      (case-lambda
        ((proc fv)
          (assume (procedure? proc))
          (assume (flexvector? fv))
          (let ((len (flexvector-length fv)))
            (do ((i 0 (+ i 1))) ((= i len))
              (proc i (flexvector-ref fv i)))))
        ((proc . fvs)
          (assume (procedure? proc))
          (let ((len (apply min (map flexvector-length fvs))))
            (do ((i 0 (+ i 1))) ((= i len))
              (apply proc i (map (lambda (fv) (flexvector-ref fv i)) fvs)))))))
    
    (define flexvector-for-each
      (case-lambda
        ((proc fv)
          (assume (procedure? proc))
          (flexvector-for-each/index (lambda (i x) (proc x)) fv))
        ((proc . fvs)
          (assume (procedure? proc))
          (apply flexvector-for-each/index (lambda (i . xs) (apply proc xs)) fvs))))
    
    (define flexvector-map/index!
      (case-lambda
        ((proc fv)
          (assume (procedure? proc))
          (assume (flexvector? fv))
          (flexvector-for-each/index
            (lambda (i x) (flexvector-set! fv i (proc i x)))
            fv)
          fv)
        ((proc fv . fvs)
          (assume (procedure? proc))
          (assume (flexvector? fv))
          (apply flexvector-for-each/index
                 (lambda (i . xs) (flexvector-set! fv i (apply proc i xs)))
                 fv
                 fvs)
          fv)))
    
    (define flexvector-map!
      (case-lambda
        ((proc fv)
          (assume (procedure? proc))
          (flexvector-map/index! (lambda (i x) (proc x)) fv))
        ((proc . fvs)
          (assume (procedure? proc))
          (apply flexvector-map/index! (lambda (i . xs) (apply proc xs)) fvs))))
    
    (define (flexvector-map/index proc fv . fvs)
      (assume (flexvector? fv))
      (apply flexvector-map/index! proc (flexvector-copy fv) fvs))
    
    (define (flexvector-map proc fv . fvs)
      (assume (flexvector? fv))
      (apply flexvector-map! proc (flexvector-copy fv) fvs))
    
    (define (flexvector-append-map/index proc fv . fvs)
      (define out (flexvector))
      (flexvector-for-each
        (lambda (x) (flexvector-append! out x))
        (apply flexvector-map/index proc fv fvs))
      out)
    
    (define (flexvector-append-map proc fv . fvs)
      (define out (flexvector))
      (flexvector-for-each
        (lambda (x) (flexvector-append! out x))
        (apply flexvector-map proc fv fvs))
      out)
    
    (define flexvector-filter!
      (case-lambda
        ((pred? fv)
          (assume (procedure? pred?))
          (assume (flexvector? fv))
          (flexvector-filter/index! (lambda (i x) (pred? x)) fv))
        ((pred? . fvs)
          (assume (procedure? pred?))
          (apply flexvector-filter/index! (lambda (i . xs) (apply pred? xs)) fvs))))
    
    (define (flexvector-filter/index proc fv . fvs)
      (assume (flexvector? fv))
      (apply flexvector-filter/index! proc (flexvector-copy fv) fvs))
    
    (define (flexvector-filter proc fv . fvs)
      (assume (flexvector? fv))
      (apply flexvector-filter! proc (flexvector-copy fv) fvs))
    
    (define (flexvector-index pred? fv1 . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv1))
      (let ((len (flexvector-length fv1)))
        (let lp ((i 0))
          (and (< i len)
               (if (apply pred?
                          (flexvector-ref fv1 i)
                          (map (lambda (fv) (flexvector-ref fv i)) o))
                   i
                   (lp (+ i 1)))))))
    
    (define (flexvector-index-right pred? fv1 . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv1))
      (let ((len (flexvector-length fv1)))
        (let lp ((i (- len 1)))
          (and (>= i 0)
               (if (apply pred?
                          (flexvector-ref fv1 i)
                          (map (lambda (fv) (flexvector-ref fv i)) o))
                   i
                   (lp (- i 1)))))))
    
    (define (complement f)
      (lambda args (not (apply f args))))
    
    (define (flexvector-skip pred? fv1 . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv1))
      (apply flexvector-index (complement pred?) fv1 o))
    
    (define (flexvector-skip-right pred? fv1 . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv1))
      (apply flexvector-index-right (complement pred?) fv1 o))
    
    (define flexvector-binary-search
      (case-lambda
        ((fv value cmp)
          (flexvector-binary-search fv value cmp 0 (flexvector-length fv)))
        ((fv value cmp start)
          (flexvector-binary-search fv value cmp start (flexvector-length fv)))
        ((fv value cmp start end)
          (assume (flexvector? fv))
          (assume (procedure? cmp))
          (assume (integer? start))
          (assume (integer? end))
          (assume (<= start end))
          (let lp ((lo (max start 0))
                   (hi (- (min end (flexvector-length fv)) 1)))
            (and (<= lo hi)
                 (let* ((mid (quotient (+ lo hi) 2))
                        (x (flexvector-ref fv mid))
                        (y (cmp value x)))
                   (cond
                     ((< y 0) (lp lo (- mid 1)))
                     ((> y 0) (lp (+ mid 1) hi))
                     (else mid))))))))
    
    (define (flexvector-any pred? fv . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv))
      (let ((len (apply min (flexvector-length fv) (map flexvector-length o))))
        (let lp ((i 0))
          (and (< i len)
               (or (apply pred?
                          (flexvector-ref fv i)
                          (map (lambda (v) (flexvector-ref v i)) o))
                   (lp (+ i 1)))))))
    
    (define (flexvector-every pred? fv . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv))
      (let ((len (apply min (flexvector-length fv) (map flexvector-length o))))
        (or (zero? len)
            (let lp ((i 0))
              (let ((x (apply pred?
                              (flexvector-ref fv i)
                              (map (lambda (v) (flexvector-ref v i)) o))))
                (if (= i (- len 1))
                    x
                    (and x (lp (+ i 1)))))))))
    
    (define (flexvector-swap! fv i j)
      (assume (flexvector? fv))
      (assume (integer? i))
      (assume (integer? j))
      (let ((tmp (flexvector-ref fv i)))
        (flexvector-set! fv i (flexvector-ref fv j))
        (flexvector-set! fv j tmp)))
    
    (define (flexvector-reverse! fv . o)
      (assume (flexvector? fv))
      (let lp ((left (if (pair? o) (car o) 0))
               (right (- (if (and (pair? o) (pair? (cdr o)))
                             (cadr o)
                             (flexvector-length fv))
                         1)))
        (cond
          ((>= left right) (if #f #f))
          (else
            (flexvector-swap! fv left right)
            (lp (+ left 1) (- right 1))))))
    
    (define (flexvector-append fv . fvs)
      (assume (flexvector? fv))
      (apply flexvector-append! (flexvector-copy fv) fvs))
    
    (define (flexvector-concatenate ls)
      (apply flexvector-append ls))
    
    (define (flexvector-append-subvectors . o)
      (let lp ((ls o) (vecs '()))
        (if (null? ls)
            (flexvector-concatenate (reverse vecs))
            (lp (cdr (cddr ls))
                (cons (flexvector-copy (car ls) (cadr ls) (car (cddr ls))) vecs)))))
    
    (define (flexvector-empty? fv)
      (assume (flexvector? fv))
      (zero? (flexvector-length fv)))
    
    (define (flexvector-count pred? fv1 . o)
      (assume (procedure? pred?))
      (assume (flexvector? fv1))
      (apply flexvector-fold
             (lambda (count . x) (+ count (if (apply pred? x) 1 0)))
             0
             fv1 o))
    
    (define (flexvector-cumulate f knil fv)
      (assume (procedure? f))
      (assume (flexvector? fv))
      (let* ((len (flexvector-length fv))
             (res (make-vector len)))
        (let lp ((i 0) (acc knil))
          (if (>= i len)
              (vector->flexvector res)
              (let ((acc (f acc (flexvector-ref fv i))))
                (vector-set! res i acc)
                (lp (+ i 1) acc))))))
    
    (define (flexvector-partition pred? fv)
      (assume (procedure? pred?))
      (assume (flexvector? fv))
      (let ((left (flexvector)) (right (flexvector)))
        (flexvector-for-each
          (lambda (x) (flexvector-add-back! (if (pred? x) left right) x))
          fv)
        (values left right)))
    
    (define (flexvector->list fv)
      (assume (flexvector? fv))
      (flexvector-fold-right (lambda (x y) (cons y x)) '() fv))
    
    (define (reverse-flexvector->list fv . o)
      (assume (flexvector? fv))
      (flexvector->list (apply flexvector-reverse-copy fv o)))
    
    (define (reverse-list->flexvector ls)
      (assume (list? ls))
      (let ((fv (list->flexvector ls)))
        (flexvector-reverse! fv)
        fv))
    
    (define (string->flexvector s . o)
      (assume (string? s))
      (vector->flexvector (apply string->vector s o)))
    
    (define (flexvector->string fv . o)
      (assume (flexvector? fv))
      (vector->string (apply flexvector->vector fv o)))
    
    (define (generator->flexvector g)
      (assume (procedure? g))
      (flexvector-unfold eof-object? (lambda (x) x) (lambda (_) (g)) (g)))
    
    (define (flexvector->generator fv)
      (assume (flexvector? fv))
      (let ((i 0))
        (lambda ()
          (if (< i (flexvector-length fv))
              (let ((element (flexvector-ref fv i)))
                (set! i (+ i 1))
                element)
              (eof-object)))))
  )
)

;;; SRFI 215
;;; Central Log Exchange
;;; 
;;; This SRFI specifies a central log exchange for Scheme that connects log producers
;;; with log consumers. It allows multiple logging systems to interoperate and co-exist
;;; in the same program. Library code can produce log messages without knowledge of
;;; which log system is actually used. Simple applications can easily get logs on
;;; standard output, while more advanced applications can send them to a full
;;; logging system.
;;; 
;;; Copyright © 2020 Göran Weinholt. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 215)
  
  (export send-log
          current-log-fields
          current-log-callback
          EMERGENCY
          ALERT
          CRITICAL
          ERROR
          WARNING
          NOTICE
          INFO
          DEBUG)
  
  (import (lispkit base))
  
  (begin
    
    ;; This queue code is based on public domain code from SLIB,
    ;; originally written by Andrew Wilcox in 1992. Here it has been
    ;; reduced in size and rewritten to use mutable pairs.
    
    (define (make-queue)
      (mcons '() '()))
    
    (define (enqueue! q datum)
      (let ((new-pair (mcons datum '())))
        (if (null? (mcar q))
            (set-mcar! q new-pair)
            (set-mcdr! (mcdr q) new-pair))
        (set-mcdr! q new-pair)))
    
    (define (dequeue! q)
      (let ((first-pair (mcar q)))
        (if (null? first-pair)
            (error "attempt to dequeue an empty queue"))
        (let ((first-cdr (mcdr first-pair)))
          (set-mcar! q first-cdr)
          (when (null? first-cdr)
            (set-mcdr! q '()))
          (mcar first-pair))))
    
    (define (queue-empty? q)
      (null? (mcar q)))
    
    ;; These severities are from RFC 5424 ("The Syslog Protocol").
    (define EMERGENCY 0)              ; system is unusable
    (define ALERT     1)              ; action must be taken immediately
    (define CRITICAL  2)              ; critical conditions
    (define ERROR     3)              ; error conditions
    (define WARNING   4)              ; warning conditions
    (define NOTICE    5)              ; normal but significant condition
    (define INFO      6)              ; informational messages
    (define DEBUG     7)              ; debug-level messages
    
    (define (field-list->alist plist)
      (let f ((fields plist))
        (cond ((null? fields)
               '())
              ((or (not (pair? fields)) (not (pair? (cdr fields))))
               (error "short field list" plist))
              (else
               (let ((k (car fields)) (v (cadr fields)))
                 (if (not v)
                     (f (cddr fields))
                     (let ((k^ (cond ((symbol? k) k)
                                     (else
                                      (error "invalid key" k plist))))
                           (v^ (cond ((string? v) v)
                                     ((and (integer? v) (exact? v)) v)
                                     ((bytevector? v) v)
                                     ;; ((condition?) v) ;R6RS
                                     ((error-object? v) v) ;R7RS
                                     (else
                                      (let ((p (open-output-string)))
                                        (write v p)
                                        (get-output-string p))))))
                       (cons (cons k^ v^)
                             (f (cddr fields))))))))))
    
    (define current-log-fields
      (make-parameter '()
                      (lambda (plist)
                        (field-list->alist plist)
                        plist)))
    
    (define current-log-callback
      (let ((num-pending-logs 0)
            (pending-logs (make-queue)))
        (make-parameter (lambda (log-entry)
                          (enqueue! pending-logs log-entry)
                          (if (eqv? num-pending-logs 100)
                              (dequeue! pending-logs)
                              (set! num-pending-logs (+ num-pending-logs 1))))
                        (lambda (hook)
                          (unless (procedure? hook)
                            (error "current-log-hook: expected a procedure" hook))
                          (let ((q pending-logs))
                            (set! num-pending-logs 0)
                            (set! pending-logs (make-queue))
                            (let lp ()
                              (unless (queue-empty? q)
                                (hook (dequeue! q))
                                (lp))))
                          hook))))
    
    ;; Send a log entry with the given severity and message. This
    ;; procedure also takes a list of extra keys and values.
    (define (send-log severity message . plist)
      (unless (and (exact? severity) (integer? severity) (<= 0 severity 7))
        (error "send-log: expected a severity from 0 to 7"
               severity message plist))
      (unless (string? message)
        (error "send-log: expected message to be a string"
               severity message plist))
      (let* ((fields (append plist (current-log-fields)))
             (alist (field-list->alist fields)))
        ((current-log-callback) `((SEVERITY . ,severity)
                                  (MESSAGE . ,message)
                                  ,@alist))))
  )
)
;;; SRFI 216
;;; SICP Prerequisites
;;;
;;; This SRFI provides "out-of-the-box" support for hosting the exercises suggested by
;;; "Structure and Interpretation of Computer Programs". It primarily provides procedures
;;; for working with time data and streams, as well as SICP names for true and false.
;;; Support for multi-threading is omitted due to LispKit currently not supporting threads.
;;; None of the provided procedures are fit for production use. They are only designed for
;;; pedagogical purposes. Students are expected to be able to just write
;;;
;;;   (include (srfi sicp))
;;;
;;; and have the code from the book run without problems (apart from those intended by the
;;; book authors).
;;;
;;; Companion website of SICP: https://mitpress.mit.edu/sites/default/files/sicp/index.html
;;;
;;; Copyright © 2020 Vladimir Nikishkin. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 216)

  (export runtime
          random
          parallel-execute
          test-and-set!
          cons-stream
          stream-null?
          the-empty-stream
          true
          false
          nil)

  (import (lispkit base)
          (except (lispkit stream) stream-null?)
          ; (only (srfi 27) random-integer random-real)
          (only (srfi 18)
                thread-start! make-thread thread-join! make-mutex mutex-lock! mutex-unlock!))

  (begin

    ;;; r4rs booleans

    (define true #t)
    (define false #f) ;; luckily, SICP does not use '() as false

    ;;; Empty list
    (define nil '())

    ;;; Random numbers
    ; now implemented by (lispkit math)
    ; (define (random x) ;; srfi-27
    ;   (if (exact-integer? x)
    ;       (random-integer x)
    ;       (* x (random-real))))

    ;;; Timing

    (define (runtime) ;; r7rs
      (round (* (current-jiffy) (jiffies-per-second) #e1e6))) ;; microseconds

    ;;; Multi-threading
    (define (parallel-execute . forms) ;; srfi-18
      (let ((myo (open-output-string)))
        (define (create-threads . forms)
          (if (null? forms)
              (list)
              (let ((ctxi (thread-start!
                            (make-thread
                              (lambda () (parameterize ((current-output-port myo))
                                                       ((car forms))))))))
                (cons ctxi (apply create-threads (cdr forms))))))
        (define (wait-threads thread-list)
          (if (null? thread-list)
              #t
              (begin (thread-join! (car thread-list))
                     (wait-threads (cdr thread-list)))))
        (wait-threads (apply create-threads forms))
        (display (get-output-string myo)))) ;; return value is not specified by SICP
   
    (define central-old-mutex (make-mutex 'global-sicp)) ;; not exported
   
    (define (test-and-set! cell) ;; srfi-18
      (mutex-lock! central-old-mutex)
      (let ((output (if (car cell) #t (begin (set-car! cell #t) #f))))
        (mutex-unlock! central-old-mutex)
        output))
    
    ;;; Streams

    (define-syntax cons-stream ;; r7rs
      (syntax-rules ()
        ((cons-stream a b) (cons a (delay b)))))

    (define stream-null? null?)

    (define the-empty-stream '())
  )
)
;;; SRFI 217
;;; Integer Sets
;;; 
;;; Integer sets, or isets, are unordered collections of fixnums. Fixnums are
;;; exact integers within certain implementation-specified bounds.
;;; 
;;; While it is perfectly practical to store integers in SRFI-113 sets, other
;;; algorithms can be used to represent sets of exact integers. This SRFI is
;;; almost a drop-in replacement for SRFI 113, except that set is replaced by
;;; iset in procedure names. However, comparators are not useful for integer sets,
;;; and in iset, iset-unfold, iset-map, and iset-copy, the comparator argument
;;; is omitted.
;;; 
;;; Author of spec: John Cowan
;;; 
;;; Copyright © 2020 Wolfgang Corcoran-Mathe. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;; 
;;; The above copyright notice and this permission notice shall be included in all
;;; copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;;; FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
;;; COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
;;; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;; 
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 217)

  (export iset list->iset
          list->iset!
          iset-unfold make-range-iset
          iset-member
          iset-min iset-max
          iset? iset-contains?
          iset-empty? iset-disjoint?
          iset-adjoin iset-adjoin! iset-delete iset-delete! iset-delete-all
          iset-delete-all!
          iset-search
          iset-search!
          iset-delete-min iset-delete-max
          iset-delete-min! iset-delete-max!
          iset-size
          iset-find
          iset-any? iset-every?
          iset-count iset-fold
          iset-fold-right
          iset-map iset-for-each
          iset-filter iset-remove
          iset-partition iset-partition!
          iset-copy
          iset->list
          iset=?
          iset<? iset>? iset<=? iset>=?
          iset-union iset-union!
          iset-intersection iset-intersection!
          iset-difference iset-difference!
          iset-xor iset-xor!
          iset-open-interval iset-closed-interval iset-open-closed-interval
          iset-closed-open-interval isubset= isubset< isubset<=
          isubset> isubset>=
          ;; debug
          iset-trie
          highest-set-bit
          highest-bit-mask
          lowest-bit-mask)
  
  (import (scheme base)
          (scheme case-lambda)
          (scheme inexact)
          (only (srfi 1) fold every xcons)
          (srfi 143)
          (only (srfi 151) bit-count)
          (srfi 145))

  (begin
    ;;; This section implements integers sets as compressed binary radix trees
    ;;; (AKA Patricia tries), as described by Chris Okasaki and Andrew Gill in
    ;;; "Fast Mergeable Integer Maps" (1998).  Integers in big-endian binary encoding
    ;;; are stored in a trie structure which allows fast lookup, insertion, and
    ;;; set-theoretical operations (union, intersection, etc.)
    ;;;
    ;;; To make efficient use of space, "buddy compression" is used to store runs of
    ;;; adjacent integers as bitmaps in single leaves. Integers are broken up into a
    ;;; prefix and a string of low-order bits; the latter are represented by setting
    ;;; the appropriate bit in a leaf's bitmap.  Since a bitmap is represented by
    ;;; a single fixnum, we can represent a 5-bit suffix on most 64-bit Schemes,
    ;;; and a 4-bit suffix on most 32-bit implementations.  (We pay a tax for dynamic
    ;;; typing.)
    ;;;
    ;;; A trie is represented by #f (the empty trie), a leaf, or a branch.
    ;;;
    ;;; Throughout this code, the empty trie (#f) is always returned as an explicit
    ;;; value, not, e.g. as the default value of an (and ...) expression, to clarify
    ;;; its use as a trie value.
    ;;;
    ;;; The interface procedures of this library are the `trie-' forms not prefixed
    ;;; with '%'.  This flimsy naming scheme is no substitute for a real submodule,
    ;;; but not every Scheme supports those.
    
    ;;;; Types and constructors
    
    ;;; Leaves and branches are constructed so as to maintain the following
    ;;; invariant: Every leaf and every subtrie contains at least one value.
    ;;; This means that the empty trie (#f) never appears as a subtrie.
    
    (define-record-type <leaf>
      (raw-leaf prefix bitmap)
      leaf?
      (prefix leaf-prefix)
      (bitmap leaf-bitmap))
    
    ;; The primary leaf constructor creates a leaf only if `bitmap'
    ;; contains at least one value.
    (define (leaf prefix bitmap)
      (if (fxpositive? bitmap)
          (raw-leaf prefix bitmap)
          #f))
    
    ;; Shorthand for extracting leaf elements.
    (define-syntax let*-leaf
      (syntax-rules ()
        ((_ () e1 e2 ...) (begin e1 e2 ...))
        ((_ (((p b) expr) . binds) . body)
         (let ((lf expr))
           (let ((p (leaf-prefix lf)) (b (leaf-bitmap lf)))
             (let*-leaf binds . body))))))
    
    (define-record-type <branch>
      (raw-branch prefix branching-bit left right)
      branch?
      (prefix branch-prefix)
      (branching-bit branch-branching-bit)
      (left branch-left)
      (right branch-right))
    
    ;; The primary branch constructor creates a branch only if the subtrees are non-empty.
    (define (branch prefix mask trie1 trie2)
      (cond ((not trie1) trie2)
            ((not trie2) trie1)
            (else (raw-branch prefix mask trie1 trie2))))
    
    ;; Shorthand for extracting branch elements.
    (define-syntax let*-branch
      (syntax-rules ()
        ((_ () e1 e2 ...) (begin e1 e2 ...))
        ((_ (((p m l r) expr) . binds) . body)
         (let ((b expr))
           (let ((p (branch-prefix b))
                 (m (branch-branching-bit b))
                 (l (branch-left b))
                 (r (branch-right b)))
             (let*-branch binds . body))))))
    
    ;;;; Bitwise constants and procedures
    
    ;; Constant.  Gives the maximum number of integers storable in a single leaf.
    (define leaf-bitmap-size (expt 2 (exact (floor (log (- fx-width 1) 2)))))
    (define suffix-mask (- leaf-bitmap-size 1))
    (define prefix-mask (fxnot suffix-mask))
    
    (define (valid-integer? x) (fixnum? x))
    
    ;; Zero the bits of k at and below (BE) the set bit of m.
    (define (mask k m)
      (if (fx=? m fx-least)
          0
          (fxand k (fxxor (fxnot (fx- m 1)) m))))
    
    ;; Does the m-masked prefix of k match p?
    (define (match-prefix? k p m)
      (fx=? (mask k m) p))
    
    (define (branching-bit p1 m1 p2 m2)
      (if (fxnegative? (fxxor p1 p2))
          fx-least        ; different signs
          (highest-bit-mask (fxxor p1 p2) (fxmax 1 (fx* 2 (fxmax m1 m2))))))
    
    ;; Two's-complement trick.
    (define (lowest-bit-mask b)
      (fxand b (fxneg b)))
    
    (define (highest-bit-mask k guess-m)
      (let lp ((x (fxand k (fxnot (fx- guess-m 1)))))
        (let ((m (lowest-bit-mask x)))
          (if (fx=? x m)
              m
              (lp (fx- x m))))))
    
    ;; FIXME: To improve.
    (define (highest-set-bit k)
      (fxfirst-set-bit (highest-bit-mask k 1)))
    
    (define (zero-bit? k m)
      (fxzero? (fxand k m)))
    
    (define (isuffix k)
      (fxand k suffix-mask))
    
    (define (iprefix k)
      (fxand k prefix-mask))
    
    (define (ibitmap k)
      (fxarithmetic-shift 1 (isuffix k)))
    
    (define (bitmap-delete bitmap key)
      (fxand bitmap (fxnot (ibitmap key))))
    
    (define (bitmap-delete-min b)
      (fxand b (fxnot (lowest-bit-mask b))))
    
    (define (bitmap-delete-max b)
      (fxand b (fxnot (highest-bit-mask b (lowest-bit-mask b)))))
    
    ;;;; Predicates and accessors
    
    (define (trie-contains? trie key)
      (and trie
           (if (leaf? trie)
               (and (fx=? (iprefix key) (leaf-prefix trie))
                    (not (fxzero? (fxand (ibitmap key) (leaf-bitmap trie)))))
               (let*-branch (((p m l r) trie))
                 (and (match-prefix? key p m)
                      (if (zero-bit? key m)
                          (trie-contains? l key)
                          (trie-contains? r key)))))))
    
    (define (trie-min trie)
      (letrec
       ((search
         (lambda (t)
           (and t
                (if (leaf? t)
                    (fx+ (leaf-prefix t) (fxfirst-set-bit (leaf-bitmap t)))
                    (search (branch-left t)))))))
        (if (branch? trie)
            (if (fxnegative? (branch-branching-bit trie))
                (search (branch-right trie))
                (search (branch-left trie)))
            (search trie))))
    
    (define (trie-max trie)
      (letrec
       ((search
         (lambda (t)
           (and t
                (if (leaf? t)
                    (fx+ (leaf-prefix t) (highest-set-bit (leaf-bitmap t)))
                    (search (branch-right t)))))))
        (if (branch? trie)
            (if (fxnegative? (branch-branching-bit trie))
                (search (branch-left trie))
                (search (branch-right trie)))
            (search trie))))
    
    ;;;; Insert
    
    (define (%trie-insert-parts trie prefix bitmap)
      (letrec
       ((ins
         (lambda (t)
           (cond ((not t) (raw-leaf prefix bitmap))
                 ((leaf? t)
                  (let*-leaf (((p b) t))
                    (if (fx=? prefix p)
                        (raw-leaf prefix (fxior b bitmap))
                        (%trie-join prefix 0 (raw-leaf prefix bitmap) p 0 t))))
                 (else
                  (let*-branch (((p m l r) t))
                    (if (match-prefix? prefix p m)
                        (if (zero-bit? prefix m)
                            (branch p m (ins l) r)
                            (branch p m l (ins r)))
                        (%trie-join prefix 0 (raw-leaf prefix bitmap) p m t))))))))
        (ins trie)))
    
    (define (trie-insert trie key)
      (%trie-insert-parts trie (iprefix key) (ibitmap key)))
    
    ;;;; Iterators and filters
    
    ;; Fold trie in increasing numerical order.
    (define (trie-fold proc nil trie)
      (letrec
       ((cata
         (lambda (b t)
           (cond ((not t) b)
                 ((leaf? t)
                  (fold-left-bits (leaf-prefix t) proc b (leaf-bitmap t)))
                 (else
                  (cata (cata b (branch-left t)) (branch-right t)))))))
        (if (branch? trie)
            (let*-branch (((p m l r) trie))
              (if (fxnegative? m)
                  (cata (cata nil r) l)
                  (cata (cata nil l) r)))
            (cata nil trie))))
    
    (define (fold-left-bits prefix proc nil bitmap)
      (let loop ((bm bitmap) (acc nil))
        (if (fxzero? bm)
            acc
            (let* ((mask (lowest-bit-mask bm))
                   (bi (fxfirst-set-bit mask)))
              (loop (fxxor bm mask) (proc (fx+ prefix bi) acc))))))
    
    ;; Fold trie in decreasing numerical order.
    (define (trie-fold-right proc nil trie)
      (letrec
       ((cata
         (lambda (b t)
           (cond ((not t) b)
                 ((leaf? t)
                  (fold-right-bits (leaf-prefix t) proc b (leaf-bitmap t)))
                 (else
                  (cata (cata b (branch-right t)) (branch-left t)))))))
        (if (branch? trie)
            (let*-branch (((p m l r) trie))
              (if (fxnegative? m)
                  (cata (cata nil l) r)
                  (cata (cata nil r) l)))
            (cata nil trie))))
    
    ;; This might benefit from tuning.
    (define (fold-right-bits prefix proc nil bitmap)
      (let loop ((bm bitmap) (acc nil))
        (if (fxzero? bm)
            acc
            (let* ((mask (highest-bit-mask bm (lowest-bit-mask bm)))
                   (bi (fxfirst-set-bit mask)))
              (loop (fxxor bm mask) (proc (fx+ prefix bi) acc))))))
    
    (define (bitmap-partition pred prefix bitmap)
      (let loop ((i 0) (in 0) (out 0))
        (cond ((fx=? i leaf-bitmap-size) (values in out))
              ((fxbit-set? i bitmap)
               (let ((bit (fxarithmetic-shift 1 i)))
                 (if (pred (fx+ prefix i))
                     (loop (fx+ i 1) (fxior in bit) out)
                     (loop (fx+ i 1) in (fxior out bit)))))
              (else (loop (fx+ i 1) in out)))))
    
    (define (trie-partition pred trie)
      (letrec
       ((part
         (lambda (t)
           (cond ((not t) (values #f #f))
                 ((leaf? t)
                  (let*-leaf (((p bm) t))
                    (let-values (((in out) (bitmap-partition pred p bm)))
                      (values (leaf p in) (leaf p out)))))
                 (else
                  (let-values (((p) (branch-prefix t))
                               ((m) (branch-branching-bit t))
                               ((il ol) (part (branch-left t)))
                               ((ir or) (part (branch-right t))))
                    (values (branch p m il ir) (branch p m ol or))))))))
        (part trie)))
    
    (define (bitmap-filter pred prefix bitmap)
      (let loop ((i 0) (res 0))
        (cond ((fx=? i leaf-bitmap-size) res)
              ((and (fxbit-set? i bitmap) (pred (fx+ prefix i)))
               (loop (fx+ i 1) (fxior res (fxarithmetic-shift 1 i))))
              (else (loop (fx+ i 1) res)))))
    
    (define (trie-filter pred trie)
      (cond ((not trie) #f)
            ((leaf? trie)
             (let*-leaf (((p bm) trie))
               (leaf p (bitmap-filter pred p bm))))
            (else
             (branch (branch-prefix trie)
                     (branch-branching-bit trie)
                     (trie-filter pred (branch-left trie))
                     (trie-filter pred (branch-right trie))))))
    
    ;;;; Update operations
    
    (define (trie-delete trie key)
      (letrec*
       ((prefix (iprefix key))
        (update
         (lambda (t)
           (cond ((not t) #f)
                 ((leaf? t)
                  (let*-leaf (((p bm) t))
                    (if (fx=? p prefix)
                        (leaf p (bitmap-delete bm key))
                        t)))
                 (else
                  (let*-branch (((p m l r) t))
                    (if (match-prefix? prefix p m)
                        (if (zero-bit? prefix m)
                            (branch p m (update l) r)
                            (branch p m l (update r)))
                        t)))))))
        (update trie)))
    
    (define (trie-delete-min trie)
      (letrec
       ((update/min
         (lambda (t)
           (cond ((not t) (error "Empty set"))
                 ((leaf? t)
                  (let*-leaf (((p bm) t))
                    (values (+ p (fxfirst-set-bit bm))
                            (leaf p (bitmap-delete-min bm)))))
                 (else
                  (let*-branch (((p m l r) t))
                    (let-values (((n l*) (update/min l)))
                      (values n (branch p m l* r)))))))))
        (if (branch? trie)
            (let*-branch (((p m l r) trie))
              (if (fxnegative? m)
                  (let-values (((n r*) (update/min r)))
                    (values n (branch p m l r*)))
                  (let-values (((n l*) (update/min l)))
                    (values n (branch p m l* r)))))
            (update/min trie))))
    
    (define (trie-delete-max trie)
      (letrec
       ((update/max
         (lambda (t)
           (cond ((not t) (error "Empty set"))
                 ((leaf? t)
                  (let*-leaf (((p bm) t))
                    (values (+ p (highest-set-bit bm))
                            (leaf p (bitmap-delete-max bm)))))
                 (else
                  (let*-branch (((p m l r) t))
                    (let-values (((n r*) (update/max r)))
                      (values n (branch p m l r*)))))))))
        (if (branch? trie)
            (let*-branch (((p m l r) trie))
              (if (fxnegative? m)
                  (let-values (((n l*) (update/max l)))
                    (values n (branch p m l* r)))
                  (let-values (((n r*) (update/max r)))
                    (values n (branch p m l r*)))))
            (update/max trie))))
    
    ;; Search trie for key, and construct a new trie using the results of
    ;; failure and success.
    (define (trie-search trie key failure success)
      (let* ((kp (iprefix key))
             (key-leaf (raw-leaf kp (ibitmap key))))
        (letrec
         ((search
           (lambda (t build)
             (cond ((not t)
                    (failure (lambda (obj) (build key-leaf obj))
                             (lambda (obj) (build #f obj))))
                   ((leaf? t)
                    (leaf-search t key failure success build))
                   (else
                    (let*-branch (((p m l r) t))
                      (if (match-prefix? key p m)
                          (if (zero-bit? key m)
                              (search l (lambda (l* obj)
                                          (build (branch p m l* r) obj)))
                              (search r (lambda (r* obj)
                                          (build (branch p m l r*) obj))))
                          (failure (lambda (obj)
                                     (build (%trie-join kp 0 key-leaf p m t)
                                            obj))
                                   (lambda (obj) (build t obj))))))))))
          (if (branch? trie)
              (let*-branch (((p m l r) trie))
                (if (fxnegative? m)
                    (if (fxnegative? key)
                        (let-values (((r* obj) (search r values)))
                          (values (branch p m l r*) obj))
                        (let-values (((l* obj) (search l values)))
                          (values (branch p m l* r) obj)))
                    (search trie values)))
              (search trie values)))))
    
    (define (leaf-search lf key failure success build)
      (let ((kp (iprefix key)) (kb (ibitmap key)))
        (let*-leaf (((p bm) lf))
          (if (fx=? kp p)
              (if (fxzero? (fxand kb bm))
                  (failure (lambda (obj)
                             (build (raw-leaf p (fxior kb bm)) obj))
                           (lambda (obj) (build lf obj)))
                  (success key
                           (lambda (elt obj)
                             (assume (eqv? key elt) "invalid new element")
                             (build lf obj))
                           (lambda (obj)
                             (build (leaf p (bitmap-delete bm key)) obj))))
              (failure (lambda (obj)
                         (build (%trie-join kp 0 (raw-leaf kp kb) p 0 lf)
                                obj))
                       (lambda (obj) (build lf obj)))))))
    
    ;;;; Set-theoretical operations
    
    (define (%trie-join prefix1 mask1 trie1 prefix2 mask2 trie2)
      (let ((m (branching-bit prefix1 mask1 prefix2 mask2)))
        (if (zero-bit? prefix1 m)
            (raw-branch (mask prefix1 m) m trie1 trie2)
            (raw-branch (mask prefix1 m) m trie2 trie1))))
    
    (define (branching-bit-higher? mask1 mask2)
      (if (negative? (fxxor mask1 mask2))  ; signs differ
          (negative? mask1)
          (fx>? mask1 mask2)))
    
    ;; Merge two tries.  The exact contents of the result depend on the
    ;; `insert-leaf' function, which is used to merge leaves into branches.
    ;; Taking the running time of `insert-leaf' to be constant, runs in
    ;; O(n+m) time.
    (define (%trie-merge insert-leaf trie1 trie2)
      (letrec
        ((merge
          (lambda (s t)
            (cond ((not s) t)
                  ((not t) s)
                  ((leaf? s) (insert-leaf t s))
                  ((leaf? t) (insert-leaf s t))
                  (else (merge-branches s t)))))
         (merge-branches
          (lambda (s t)
            (let*-branch (((p m s1 s2) s)
                          ((q n t1 t2) t))
              (cond ((and (fx=? m n) (fx=? p q))
                     ;; the prefixes match, so merge the subtries
                     (branch p m (merge s1 t1) (merge s2 t2)))
                    ((and (branching-bit-higher? m n) (match-prefix? q p m))
                     ;; p is a prefix of q, so merge t with a subtrie of s.
                     (if (zero-bit? q m)
                         (branch p m (merge s1 t) s2)
                         (branch p m s1 (merge s2 t))))
                    ((and (branching-bit-higher? n m) (match-prefix? p q n))
                     ;; q is a prefix of p, so merge s with a subtrie of t.
                     (if (zero-bit? p n)
                         (branch q n (merge s t1) t2)
                         (branch q n t1 (merge s t2))))
                    (else    ; the prefixes disagree
                     (%trie-join p m s q n t)))))))
        (merge trie1 trie2)))
    
    (define (trie-union trie1 trie2)
      (%trie-merge (lambda (s t) (insert-leaf/proc fxior s t))
                   trie1
                   trie2))
    
    (define (trie-xor trie1 trie2)
      (%trie-merge (lambda (s t) (insert-leaf/proc fxxor s t))
                   trie1
                   trie2))
    
    ;; Insert the elements of `lf' into `trie', combining bitmaps with
    ;; the binary bitwise operation `fxcombine'.
    (define (insert-leaf/proc fxcombine trie lf)
      (let*-leaf (((p bm) lf))
        (letrec
         ((ins
           (lambda (t)
             (cond ((not t) lf)  ; a whole new leaf
                   ((leaf? t)
                    (let*-leaf (((q bm*) t))
                      (if (fx=? p q)
                          (leaf p (fxcombine bm bm*))
                          (%trie-join p 0 lf q 0 t))))
                   (else         ; branch
                    (let*-branch (((q m l r) t))
                      (if (match-prefix? p q m)
                          (if (zero-bit? p m)
                              (raw-branch q m (ins l) r)
                              (raw-branch q m l (ins r)))
                          (%trie-join p 0 lf q 0 t))))))))
          (ins trie))))
    
    ;; Construct a trie which forms the intersection of the two tries.
    ;; Runs in O(n+m) time.
    (define (trie-intersection trie1 trie2)
      (letrec
       ((intersect
         (lambda (s t)
           (cond ((or (not s) (not t)) #f)
                 ((leaf? s) (intersect/leaf s t))
                 ((leaf? t) (intersect/leaf t s))
                 (else (intersect-branches s t)))))
        (intersect/leaf
         (lambda (l t)
           (let*-leaf (((p bm) l))
             (let lp ((t t))
               (cond ((not t) #f)
                     ((leaf? t)
                      (if (fx=? p (leaf-prefix t))
                          (leaf p (fxand bm (leaf-bitmap t)))
                          #f))          ; disjoint
                     (else              ; branch
                      (let*-branch (((q m l r) t))
                        (if (match-prefix? p q m)
                            (if (zero-bit? p m) (lp l) (lp r))
                            #f))))))))  ; disjoint
        (intersect-branches
         (lambda (s t)
           (let*-branch (((p m sl sr) s) ((q n tl tr) t))
             (cond ((branching-bit-higher? m n)
                    (and (match-prefix? q p m)
                         (if (zero-bit? q m)
                             (intersect sl t)
                             (intersect sr t))))
                   ((branching-bit-higher? n m)
                    (and (match-prefix? p q n)
                         (if (zero-bit? p n)
                             (intersect s tl)
                             (intersect s tr))))
                   ((fx=? p q)
                    (branch p m (intersect sl tl) (intersect sr tr)))
                   (else #f))))))
        (intersect trie1 trie2)))
    
    ;; Construct a trie containing the elements of trie1 not found in trie2.
    ;; Runs in O(n+m) time.
    (define (trie-difference trie1 trie2)
      (letrec
       ((difference
         (lambda (s t)
           (cond ((not s) #f)
                 ((not t) s)
                 ((leaf? s) (diff/leaf s t))
                 ((leaf? t)
                  (%trie-delete-bitmap s (leaf-prefix t) (leaf-bitmap t)))
                 (else (branch-difference s t)))))
        (diff/leaf
         (lambda (lf t)
           (let*-leaf (((p bm) lf))
             (let lp ((t t))
               (cond ((not t) lf)
                     ((leaf? t)
                      (let*-leaf (((q c) t))
                        (if (fx=? p q)
                            (leaf p (fxand bm (fxnot c)))
                            lf))) ; disjoint
                     (else        ; branch
                      (let*-branch (((q m l r) t))
                        (if (match-prefix? p q m)
                            (if (zero-bit? p m) (lp l) (lp r))
                            lf))))))))
        (branch-difference
         (lambda (s t)
           (let*-branch (((p m sl sr) s) ((q n tl tr) t))
             (cond ((and (fx=? m n) (fx=? p q))
                    (branch p m (difference sl tl) (difference sr tr)))
                   ((and (branching-bit-higher? m n) (match-prefix? q p m))
                    (if (zero-bit? q m)
                        (branch p m (difference sl t) sr)
                        (branch p m sl (difference sr t))))
                   ((and (branching-bit-higher? n m) (match-prefix? p q n))
                    (if (zero-bit? p n)
                        (difference s tl)
                        (difference s tr)))
                   (else s))))))
        (difference trie1 trie2)))
    
    ;; Delete all values described by `bitmap' from `trie'.
    (define (%trie-delete-bitmap trie prefix bitmap)
      (cond ((not trie) #f)
            ((leaf? trie)
             (if (fx=? prefix (leaf-prefix trie))
                 (leaf prefix (fxand (leaf-bitmap trie) (fxnot bitmap)))
                 trie))  ; disjoint
            (else        ; branch
             (let*-branch (((p m l r) trie))
               (if (match-prefix? prefix p m)
                   (if (zero-bit? prefix m)
                       (branch p m (%trie-delete-bitmap l prefix bitmap) r)
                       (branch p m l (%trie-delete-bitmap r prefix bitmap)))
                   trie)))))
    
    ;;;; Copying
    
    (define (copy-trie trie)
      (cond ((not trie) #f)
            ((leaf? trie) (raw-leaf (leaf-prefix trie) (leaf-bitmap trie)))
            (else
             (raw-branch (branch-prefix trie)
                         (branch-branching-bit trie)
                         (copy-trie (branch-left trie))
                         (copy-trie (branch-right trie))))))
    
    ;;;; Size
    
    (define (trie-size trie)
      (let accum ((siz 0) (t trie))
        (cond ((not t) siz)
              ((leaf? t) (+ siz (bit-count (leaf-bitmap t))))
              (else (accum (accum siz (branch-left t))
                           (branch-right t))))))
    
    ;;;; Comparisons
    
    (define (trie=? trie1 trie2)
      (cond ((not (or trie1 trie2)) #t)
            ((and (leaf? trie1) (leaf? trie2))
             (and (fx=? (leaf-prefix trie1) (leaf-prefix trie2))
                  (fx=? (leaf-bitmap trie1) (leaf-bitmap trie2))))
            ((and (branch? trie1) (branch? trie2))
             (let*-branch (((p m l1 r1) trie1) ((q n l2 r2) trie2))
               (and (fx=? m n) (fx=? p q) (trie=? l1 l2) (trie=? r1 r2))))
            (else #f)))
    
    (define (subset-compare-leaves l1 l2)
      (let*-leaf (((p b) l1) ((q c) l2))
        (if (fx=? p q)
            (if (fx=? b c)
                'equal
                (if (fxzero? (fxand b (fxnot c)))
                    'less
                    'greater))
            'greater)))  ; disjoint
    
    ;; Returns the symbol 'less' if trie1 is a proper subset of trie2,
    ;; 'equal' if they are the same, and 'greater' otherwise.  NB that
    ;; disjoint sets will compare as greater.
    ;;
    ;; FIXME: Simplify this.
    (define (trie-subset-compare trie1 trie2)
      (letrec
       ((compare
         (lambda (s t)
           (cond ((eqv? s t) 'equal)
                 ((not s) 'less)
                 ((not t) 'greater)  ; disjoint
                 ((and (leaf? s) (leaf? t)) (subset-compare-leaves s t))
                 ((leaf? s)             ; leaf / branch
                  (let*-leaf (((p _) s))
                    (let*-branch (((q m l r) t))
                      (if (match-prefix? p q m)
                          (case (compare s (if (zero-bit? p m) l r))
                            ((greater) 'greater)
                            (else 'less))
                          'greater))))       ; disjoint
                 ((leaf? t) 'greater)        ; branch / leaf
                 (else (compare-branches s t)))))
        (compare-branches
         (lambda (s t)
           (let*-branch (((p m sl sr) s) ((q n tl tr) t))
             (cond ((branching-bit-higher? m n) 'greater)
                   ((branching-bit-higher? n m)
                    (if (match-prefix? p q n)
                        (let ((comp (if (zero-bit? p n)
                                        (compare s tl)
                                        (compare s tr))))
                          (if (eqv? comp 'greater) comp 'less))
                        'greater))
                   ((fx=? p q)  ; same prefix, compare subtrees
                    (let ((cl (compare sl tl)) (cr (compare sr tr)))
                      (cond ((or (eqv? cl 'greater) (eqv? cr 'greater))
                             'greater)
                            ((and (eqv? cl 'equal) (eqv? cr 'equal))
                             'equal)
                            (else 'less))))
                   (else 'greater))))))  ; disjoint
        (compare trie1 trie2)))
    
    (define (trie-proper-subset? trie1 trie2)
      (eqv? (trie-subset-compare trie1 trie2) 'less))
    
    (define (trie-disjoint? trie1 trie2)
      (letrec
       ((disjoint?
         (lambda (s t)
           (or (not s)
               (not t)
               (cond ((and (leaf? s) (leaf? t)) (disjoint/leaf? s t))
                     ((leaf? s) (disjoint/leaf? s t))
                     ((leaf? t) (disjoint/leaf? t s))
                     (else (branches-disjoint? s t))))))
        (disjoint/leaf?
         (lambda (lf t)
           (let*-leaf (((p bm) lf))
             (let lp ((t t))
               (if (leaf? t)
                   (if (fx=? p (leaf-prefix t))
                       (fxzero? (fxand bm (leaf-bitmap t)))
                       #t)
                   (let*-branch (((q n l r) t))
                     (if (match-prefix? p q n)
                         (if (zero-bit? p n) (lp l) (lp r))
                         #t)))))))
        (branches-disjoint?
         (lambda (s t)
           (let*-branch (((p m sl sr) s) ((q n tl tr) t))
             (cond ((and (fx=? m n) (fx=? p q))
                    (and (disjoint? sl tl) (disjoint? sr tr)))
                   ((and (branching-bit-higher? m n) (match-prefix? q p m))
                    (if (zero-bit? q m)
                        (disjoint? sl t)
                        (disjoint? sr t)))
                   ((and (branching-bit-higher? n m) (match-prefix? p q n))
                    (if (zero-bit? p n)
                        (disjoint? s tl)
                        (disjoint? s tr)))
                   (else #t))))))      ; the prefixes disagree
        (disjoint? trie1 trie2)))
    
    ;;;; Subtrie operations
    
    ;; Return a trie containing all the elements of `trie' which are
    ;; less than k, if `inclusive' is false, or less than or equal to
    ;; k if `inclusive' is true.
    ;; Runs in O(min(n, W)) time.
    (define (subtrie< trie k inclusive)
      (letrec
        ((split
          (lambda (t)
            (cond ((not t) #f)
                  ((leaf? t)
                   (let*-leaf (((p bm) t))
                     (leaf p (bitmap-split< k inclusive p bm))))
                  (else
                   (let*-branch (((p m l r) t))
                     (if (match-prefix? k p m)
                         (if (zero-bit? k m)
                             (split l)
                             (trie-union l (split r)))
                         (and (fx<? p k) t))))))))
        (if (and (branch? trie) (fxnegative? (branch-branching-bit trie)))
            (if (fxnegative? k)
                (split (branch-right trie))
                (trie-union (split (branch-left trie)) (branch-right trie)))
            (split trie))))
    
    ;; Return a bitmap containing all elements in `bitmap' that are
    ;; less than/less than or equal to k.
    (define (bitmap-split< k inclusive prefix bitmap)
      (let ((kp (iprefix k)) (kb (ibitmap k)))
        (cond ((fx>? kp prefix) bitmap)
              ((fx=? kp prefix)
               (fxand bitmap
                      (fx- (if inclusive
                               (fxarithmetic-shift kb 1)
                               kb)
                           1)))
              (else 0))))
    
    ;; Return a trie containing all the elements of `trie' which are
    ;; greater than k, if `inclusive' is false, or greater than or equal
    ;; to k if `inclusive' is true.
    ;; Runs in O(min(n, W)) time.
    (define (subtrie> trie k inclusive)
      (letrec
       ((split
         (lambda (t)
           (cond ((not t) #f)
                 ((leaf? t)
                  (let*-leaf (((p bm) t))
                    (leaf p (bitmap-split> k inclusive p bm))))
                 (else
                  (let*-branch (((p m l r) t))
                    (if (match-prefix? k p m)
                        (if (zero-bit? k m)
                            (trie-union (split l) r)
                            (split r))
                        (and (fx>? p k) t))))))))
        (if (and (branch? trie) (fxnegative? (branch-branching-bit trie)))
            (if (fxnegative? k)
                (trie-union (split (branch-right trie)) (branch-left trie))
                (split (branch-left trie)))
            (split trie))))
    
    ;; Return a bitmap containing all elements in `bitmap' that are
    ;; greater than/greater than or equal to `k'.
    (define (bitmap-split> k inclusive prefix bitmap)
      (let ((kp (iprefix k)) (kb (ibitmap k)))
        (cond ((fx<? kp prefix) bitmap)
              ((fx=? kp prefix)
               (fxand bitmap
                      (fxneg (if inclusive
                                 kb
                                 (fxarithmetic-shift kb 1)))))
              (else 0))))
    
    ;; Return a trie containing all the elements of `trie' which are
    ;; greater than/greater than or equal to a and less than/less than
    ;; or equal to b, depending on the truth values of
    ;; low-/high-inclusive.
    (define (subtrie-interval trie a b low-inclusive high-inclusive)
      (letrec
       ((interval
         (lambda (t)
           (cond ((not t) #f)
                 ((leaf? t)
                  (let*-leaf (((p bm) t))
                    (leaf p
                          (bitmap-interval p bm a b low-inclusive high-inclusive))))
                 (else (branch-interval t)))))
        (branch-interval
         (lambda (t)
           (let*-branch (((p m l r) t))
             (if (match-prefix? a p m)
                 (if (zero-bit? a m)
                     (if (match-prefix? b p m)
                         (if (zero-bit? b m)
                             (interval l)  ; all x < b is in l
                             (trie-union (subtrie> l a low-inclusive)
                                         (subtrie< r b high-inclusive)))
                         ;; everything or nothing is less than b
                         (and (fx<? b p)
                              (trie-union (subtrie> l a low-inclusive) r)))
                     (interval r)) ; all x > b is in r
                 ;; everything or nothing is greater than a
                 (and (fx>? p a) (subtrie< t b high-inclusive)))))))
        (if (and (branch? trie) (fxnegative? (branch-branching-bit trie)))
            (cond ((and (fxnegative? a) (fxnegative? b))
                   (interval (branch-right trie)))
                  ((and (fxpositive? a) (fxpositive? b))
                   (interval (branch-left trie)))
                  ;; (a, 0) U (0, b)
                  (else (trie-union
                         (subtrie> (branch-right trie) a low-inclusive)
                         (subtrie< (branch-left trie) b high-inclusive))))
            (interval trie))))
    
    ;; Return a bitmap containing the elements of bitmap that are within
    ;; the interval defined by a, b.
    (define (bitmap-interval prefix bitmap low high low-inclusive high-inclusive)
      (let ((lp (iprefix low))
            (lb (ibitmap low))
            (hp (iprefix high))
            (hb (ibitmap high)))
        (let ((low-mask (fxneg (if low-inclusive    ; mask everything above `low'
                                   lb
                                   (fxarithmetic-shift lb 1))))
              (high-mask (fx- (if high-inclusive    ; mask everything below `high'
                                  (fxarithmetic-shift hb 1)
                                  hb)
                              1)))
          (cond ((fx<? prefix hp)
                 (cond ((fx<? prefix lp) 0)
                       ((fx>? prefix lp) bitmap)
                       (else (fxand low-mask bitmap))))
                ((fx>? prefix hp) 0)
                (else (fxand (fxand low-mask high-mask) bitmap))))))
  )
  
  (begin
    (define-record-type <iset>
      (raw-iset trie)
      iset?
      (trie iset-trie))
    
    ;;;; Constructors
    
    (define (iset . args)
      (list->iset args))
    
    (define (pair-or-null? x)
      (or (pair? x) (null? x)))
    
    (define (list->iset ns)
      (assume (pair-or-null? ns))
      (raw-iset
       (fold (lambda (n t)
               (assume (valid-integer? n))
               (trie-insert t n))
             #f
             ns)))
    
    (define (list->iset! set ns)
      (assume (iset? set))
      (assume (pair-or-null? ns))
      (raw-iset (fold (lambda (n t)
                        (assume (valid-integer? n))
                        (trie-insert t n))
                      (iset-trie set)
                      ns)))
    
    (define (iset-unfold stop? mapper successor seed)
      (assume (procedure? stop?))
      (assume (procedure? mapper))
      (assume (procedure? successor))
      (let lp ((trie #f) (seed seed))
        (if (stop? seed)
            (raw-iset trie)
            (let ((n (mapper seed)))
              (assume (valid-integer? n))
              (lp (trie-insert trie n) (successor seed))))))
    
    ;; TODO: Optimize step = 1 case.
    (define make-range-iset
      (case-lambda
        ((start end) (make-range-iset start end 1))  ; TODO: Tune this case.
        ((start end step)
         (assume (valid-integer? start))
         (assume (valid-integer? end))
         (assume (valid-integer? step))
         (assume (if (< end start)
                     (negative? step)
                     (not (zero? step)))
                 "Invalid step value.")
         (let ((stop? (if (positive? step)
                          (lambda (i) (>= i end))
                          (lambda (i) (<= i end)))))
           (iset-unfold stop?
                        values
                        (lambda (i) (+ i step))
                        start)))))
    
    ;;;; Predicates
    
    (define (iset-contains? set n)
      (assume (iset? set))
      (assume (valid-integer? n))
      (trie-contains? (iset-trie set) n))
    
    (define (iset-empty? set)
      (assume (iset? set))
      (not (iset-trie set)))
    
    (define (iset-disjoint? set1 set2)
      (assume (iset? set1))
      (assume (iset? set2))
      (trie-disjoint? (iset-trie set1) (iset-trie set2)))
    
    ;;;; Accessors
    
    (define (iset-member set elt default)
      (if (iset-contains? set elt)
          elt
          default))
    
    (define (iset-min set)
      (assume (iset? set))
      (trie-min (iset-trie set)))
    
    (define (iset-max set)
      (assume (iset? set))
      (trie-max (iset-trie set)))
    
    ;;;; Updaters
    
    (define iset-adjoin
      (case-lambda
        ((set n)
         (assume (iset? set))
         (assume (valid-integer? n))
         (raw-iset (trie-insert (iset-trie set) n)))
        ((set . ns)
         (raw-iset
          (fold (lambda (n t)
                  (assume (valid-integer? n))
                  (trie-insert t n))
                (iset-trie set)
                ns)))))
    
    (define (iset-adjoin! set . ns)
      (apply iset-adjoin set ns))
    
    (define iset-delete
      (case-lambda
        ((set n)
         (assume (iset? set))
         (assume (valid-integer? n))
         (raw-iset (trie-delete (iset-trie set) n)))
        ((set . ns) (iset-delete-all set ns))))
    
    (define (iset-delete! set n) (iset-delete set n))
    
    (define (iset-delete-all set ns)
      (assume (iset? set))
      (assume (or (pair? ns) (null? ns)))
      (iset-difference set (list->iset ns)))
    
    (define (iset-delete-all! set ns)
      (iset-delete-all set ns))
    
    ;; Thanks to the authors of SRFI 146 for providing examples
    ;; of how to implement this shoggoth.
    (define (iset-search set elt failure success)
      (assume (iset? set))
      (assume (valid-integer? elt))
      (assume (procedure? failure))
      (assume (procedure? success))
      (call-with-current-continuation
       (lambda (return)
         (let-values
          (((trie obj)
            (trie-search (iset-trie set)
                         elt
                         (lambda (insert ignore)
                           (failure insert
                                    (lambda (obj)
                                      (return set obj))))
                         (lambda (key update remove)
                           (success
                            key
                            (lambda (new obj)
                              (assume (valid-integer? new))
                              (if (fx=? key new)
                                  (update new obj)
                                  (return (iset-adjoin (iset-delete set key)
                                                       new)
                                          obj)))
                            remove)))))
           (values (raw-iset trie) obj)))))
    
    (define (iset-search! set elt failure success)
      (iset-search set elt failure success))
    
    (define (iset-delete-min set)
      (assume (iset? set))
      (let*-values (((trie) (iset-trie set))
                    ((n trie*) (trie-delete-min trie)))
        (values n (raw-iset trie*))))
    
    (define (iset-delete-max set)
      (assume (iset? set))
      (let*-values (((trie) (iset-trie set))
                    ((n trie*) (trie-delete-max trie)))
        (values n (raw-iset trie*))))
    
    (define (iset-delete-min! set) (iset-delete-min set))
    (define (iset-delete-max! set) (iset-delete-max set))
    
    ;;;; The whole iset
    
    (define (iset-size set)
      (assume (iset? set))
      (trie-size (iset-trie set)))
    
    (define (iset-find pred set failure)
      (assume (procedure? failure))
      (call-with-current-continuation
       (lambda (return)
         (or (iset-fold (lambda (n _)
                          (and (pred n) (return n)))
                        #f
                        set)
             (failure)))))
    
    (define (iset-count pred set)
      (assume (procedure? pred))
      (iset-fold (lambda (n acc)
                   (if (pred n) (+ 1 acc) acc))
                 0
                 set))
    
    (define (iset-any? pred set)
      (assume (procedure? pred))
      (call-with-current-continuation
       (lambda (return)
         (iset-fold (lambda (n _)
                      (and (pred n) (return #t)))
                    #f
                    set))))
    
    (define (iset-every? pred set)
      (assume (procedure? pred))
      (call-with-current-continuation
       (lambda (return)
         (iset-fold (lambda (n _)
                      (or (pred n) (return #f)))
                    #t
                    set))))
    
    ;;;; Mapping and folding
    
    (define (iset-map proc set)
      (assume (procedure? proc))
      (raw-iset
       (iset-fold (lambda (n t)
                    (let ((n* (proc n)))
                      (assume (valid-integer? n*))
                      (trie-insert t (proc n))))
                  #f
                  set)))
    
    (define (unspecified)
      (if #f #f))
    
    (define (iset-for-each proc set)
      (assume (procedure? proc))
      (iset-fold (lambda (n _)
                   (proc n)
                   (unspecified))
                 (unspecified)
                 set))
    
    (define (iset-fold proc nil set)
      (assume (procedure? proc))
      (assume (iset? set))
      (trie-fold proc nil (iset-trie set)))
    
    (define (iset-fold-right proc nil set)
      (assume (procedure? proc))
      (assume (iset? set))
      (trie-fold-right proc nil (iset-trie set)))
    
    (define (iset-filter pred set)
      (assume (procedure? pred))
      (assume (iset? set))
      (raw-iset (trie-filter pred (iset-trie set))))
    
    (define (iset-remove pred set)
      (assume (procedure? pred))
      (assume (iset? set))
      (raw-iset (trie-filter (lambda (n) (not (pred n))) (iset-trie set))))
    
    (define (iset-partition pred set)
      (assume (procedure? pred))
      (assume (iset? set))
      (let-values (((tin tout) (trie-partition pred (iset-trie set))))
        (values (raw-iset tin) (raw-iset tout))))
    
    (define (iset-partition! pred set)
      (iset-partition pred set))
    
    ;;;; Copying and conversion
    
    (define (iset-copy set)
      (assume (iset? set))
      (raw-iset (copy-trie (iset-trie set))))
    
    (define (iset->list set)
      (iset-fold-right cons '() set))
    
    ;;;; Comparison
    
    (define (iset=? set1 set2 . sets)
      (assume (iset? set1))
      (let ((iset-eq1 (lambda (set)
                        (assume (iset? set))
                        (or (eqv? set1 set)
                            (trie=? (iset-trie set1) (iset-trie set))))))
        (and (iset-eq1 set2)
             (or (null? sets)
                 (every iset-eq1 sets)))))
    
    (define (iset<? set1 set2 . sets)
      (assume (iset? set1))
      (assume (iset? set2))
      (let lp ((t1 (iset-trie set1)) (t2 (iset-trie set2)) (sets sets))
        (and (trie-proper-subset? t1 t2)
             (or (null? sets)
                 (lp t2 (iset-trie (car sets)) (cdr sets))))))
    
    (define (iset>? set1 set2 . sets)
      (assume (iset? set1))
      (assume (iset? set2))
      (let lp ((t1 (iset-trie set1)) (t2 (iset-trie set2)) (sets sets))
        (and (trie-proper-subset? t2 t1)
             (or (null? sets)
                 (lp t2 (iset-trie (car sets)) (cdr sets))))))
    
    (define (iset<=? set1 set2 . sets)
      (assume (iset? set1))
      (assume (iset? set2))
      (let lp ((t1 (iset-trie set1)) (t2 (iset-trie set2)) (sets sets))
        (and (memv (trie-subset-compare t1 t2) '(less equal))
             (or (null? sets)
                 (lp t2 (iset-trie (car sets)) (cdr sets))))))
    
    (define (iset>=? set1 set2 . sets)
         (assume (iset? set1))
         (assume (iset? set2))
         (let lp ((t1 (iset-trie set1)) (t2 (iset-trie set2)) (sets sets))
           (and (memv (trie-subset-compare t1 t2) '(greater equal))
                (or (null? sets)
                    (lp t2 (iset-trie (car sets)) (cdr sets))))))
    
    ;;;; Set theory operations
    
    (define iset-union
      (case-lambda
        ((set1 set2)
         (assume (iset? set1))
         (assume (iset? set2))
         (raw-iset (trie-union (iset-trie set1) (iset-trie set2))))
        ((set . rest)
         (raw-iset (fold (lambda (s t)
                           (assume (iset? s))
                           (trie-union (iset-trie s) t))
                         (iset-trie set)
                         rest)))))
    
    (define (iset-union! set . rest)
      (apply iset-union set rest))
    
    (define iset-intersection
      (case-lambda
        ((set1 set2)
         (assume (iset? set1))
         (assume (iset? set2))
         (raw-iset (trie-intersection (iset-trie set1) (iset-trie set2))))
        ((set . rest)
         (assume (iset? set))
         (raw-iset (fold (lambda (s t)
                           (assume (iset? s))
                           (trie-intersection (iset-trie s) t))
                   (iset-trie set)
                   rest)))))
    
    (define (iset-intersection! set . rest)
      (apply iset-intersection set rest))
    
    (define iset-difference
      (case-lambda
        ((set1 set2)              ; fast path
         (assume (iset? set1))
         (assume (iset? set2))
         (raw-iset (trie-difference (iset-trie set1) (iset-trie set2))))
        ((set . rest)
         (assume (iset? set))
         (raw-iset
          (trie-difference (iset-trie set)
                           (iset-trie (apply iset-union rest)))))))
    
    (define (iset-difference! set . rest)
      (apply iset-difference set rest))
    
    (define (iset-xor set1 set2)
      (assume (iset? set1))
      (assume (iset? set2))
      (if (eqv? set1 set2)  ; quick check
          (iset)
          (raw-iset
           (trie-xor (iset-trie set1) (iset-trie set2)))))
    
    (define (iset-xor! set1 set2) (iset-xor set1 set2))
    
    ;;;; Subsets
    
    (define (isubset= set k)
      (if (iset-contains? set k) (iset k) (iset)))
    
    (define (iset-open-interval set low high)
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-iset (subtrie-interval (iset-trie set) low high #f #f)))
    
    (define (iset-closed-interval set low high)
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-iset (subtrie-interval (iset-trie set) low high #t #t)))
    
    (define (iset-open-closed-interval set low high)
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-iset (subtrie-interval (iset-trie set) low high #f #t)))
    
    (define (iset-closed-open-interval set low high)
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-iset (subtrie-interval (iset-trie set) low high #t #f)))
    
    (define (isubset< set k)
      (assume (iset? set))
      (assume (valid-integer? k))
      (raw-iset (subtrie< (iset-trie set) k #f)))
    
    (define (isubset<= set k)
      (assume (iset? set))
      (assume (valid-integer? k))
      (raw-iset (subtrie< (iset-trie set) k #t)))
    
    (define (isubset> set k)
      (assume (iset? set))
      (assume (valid-integer? k))
      (raw-iset (subtrie> (iset-trie set) k #f)))
    
    (define (isubset>= set k)
      (assume (iset? set))
      (assume (valid-integer? k))
      (raw-iset (subtrie> (iset-trie set) k #t)))
  )
)
;;; SRFI 219
;;; Define higher-order lambda
;;;
;;; This SRFI codifies the following shorthand syntax, which some Scheme implementations
;;; have had for a long time:
;;;
;;; ```
;;; (define ((outer-name outer-args ...) inner-args ...)
;;;   inner-body ...)
;;; ```
;;;
;;; The syntax generalizes further: lambdas can be nested arbitrarily deep by adding more
;;; nested lists. The key is that each nested list always be at the head position of the
;;; containing list. Each inner list adds one outer lambda; this order is intuitive when
;;; reading the S-expression left-to-right. The identifier at the head position of the
;;; innermost list becomes the name of the definition.
;;;
;;; Apart from helping define higher-order functions, the additional shorthand syntax
;;; partially applies to the task of making partially applied functions in Scheme.
;;;
;;; Copyright © 2021 Lassi Kortela. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 219)
  (export define)

  (import (rename (lispkit base) (define define/native)))

  (begin
    (define-syntax define
      (syntax-rules ()
        ((define ((head . outer-args) . args) . body)
          (define (head . outer-args) (lambda args . body)))
        ((define (head . args) . body)
          (define head (lambda args . body)))
        ((define head . body)
          (define/native head . body))))
  )
)
;;; SRFI 221
;;; Generator/accumulator sub-library
;;;
;;; This is a set of convenience routines for generators and accumulators intended to blend
;;; in with SRFI 158. The authors recommend that they be added to the (srfi 158) library
;;; provided by users or implementations. If they are approved by the R7RS-large process,
;;; they can also be added to (r7rs generator).
;;;
;;; Copyright © 2020 John Cowan (text), Arvydas Silanskas (implementation). All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 221)
  
  (export accumulate-generated-values
          gdelete-duplicates
          genumerate
          gcompose-left
          gcompose-right
          gchoice
          generator->stream
          stream->generator)
  
  (import (lispkit base)
          (srfi 1)
          (srfi 41)
          (srfi 158))
  
  (begin
    
    (define (accumulate-generated-values acc gen)
      (let ((value (gen)))
        (if (eof-object? value)
            (acc value)
            (begin
              (acc value)
              (accumulate-generated-values acc gen)))))
    
    (define gdelete-duplicates
      (case-lambda
        ((gen) (gdelete-duplicates* gen equal?))
        ((gen =) (gdelete-duplicates* gen =))))
    
    (define (gdelete-duplicates* gen =)
      (define seen '())
      ;; first parameter should be older value than second. However in `member` it's other way
      ;; around. as such function is changed to switch parameters in places
      (define (=* a b) (= b a))
      (define (seen? value)
        (member value seen =*))
      (lambda ()
        (let loop ((value (gen)))
          (cond
            ((eof-object? value)
              value)
            ((seen? value)
              (loop (gen)))
            (else
              (begin
                (set! seen (cons value seen))
                value))))))
    
    (define (genumerate gen)
      (gmap
        cons
        (make-range-generator 0)
        gen))
    
    (define (gcompose-left constr . ops)
      (let loop ((gen (constr))
                 (ops ops))
        (if (null? ops)
            gen
            (let* ((op (car ops))
                   (new-gen (op gen)))
              (loop new-gen (cdr ops))))))
    
    (define (gcompose-right . args)
      (apply gcompose-left (reverse args)))
    
    (define (gchoice choice-gen . source-gens)
      (define source-gens-v (list->vector source-gens))
      (define l (vector-length source-gens-v))
      (define exhausted-count 0)
      (unless (procedure? choice-gen)
        (error "choice-gen must be a generator"))
      (for-each
        (lambda (g)
          (unless (procedure? g)
            (error "source-gens must be generators")))
        source-gens)
      (lambda ()
        (let loop ((i (choice-gen)))
          (cond
            ;; all source-gens have been exhausted
            ((= exhausted-count l) (eof-object))
            ;; choice-gen have been exhausted
            ((eof-object? i) (eof-object))
            ;; source-gen returned bad value
            ((or (not (integer? i))
                 (< i 0)
                 (>= i l))
              (error (string-append "choice-gen didn't return an integer in range 0 to "
                                    (number->string (- l 1)))))
            (else
              (let ((gen (vector-ref source-gens-v i)))
                (if (not gen)
                    ;; we picked exhausted generator -- pick again
                    (loop (choice-gen))
                    (let ((value (gen)))
                      (if (eof-object? value)
                          ;; picked generator was exhausted on this iteration -- mark it and pick again
                          (begin
                            (vector-set! source-gens-v i #f)
                            (set! exhausted-count (+ 1 exhausted-count))
                            (loop (choice-gen)))
                          value)))))))))
    
    (define (generator->stream gen)
      (define gen-stream
        (stream-lambda ()
          (stream-cons (gen) (gen-stream))))
      (stream-take-while
        (lambda (value) (not (eof-object? value)))
        (gen-stream)))
    
    (define (stream->generator stream)
      (lambda ()
        (if (stream-null? stream)
            (eof-object)
            (let ((value (stream-car stream)))
              (set! stream (stream-cdr stream))
              value))))
  )
)

;;; SRFI 221
;;; Compound objects
;;;
;;; Compound objects are analogous to R6RS compound conditions, and are suitable
;;; for use in creating and handling conditions on non-R6RS systems, among other
;;; purposes. They encapsulate an immutable sequence of subobjects, which can be
;;; any object except another compound object. It is possible to implement R6RS
;;; compound conditions on top of compound objects, but not vice versa.
;;; Note that this SRFI does not provide any analogue to R6RS simple conditions,
;;; which are just records.
;;;
;;; Compound objects serve as a kind of poor man's multiple inheritance without
;;; the usual complications of multiple inheritance. A compound object can be
;;; used to represent multiple otherwise unrelated aspects of a value or
;;; situation. Because they are sequences, they can be used to represent priorities
;;; of interpretation from higher to lower. Most of the operations described in
;;; this section treat a non-compound object identically to a compound object with
;;; the simple object as its sole component.
;;;
;;; Copyright © 2021 John Cowan (text), Arvydas Silanskas (implementation). All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 222)

  (export make-compound
          compound?
          compound-subobjects
          compound-length
          compound-ref
          compound-map
          compound-map->list
          compound-filter
          compound-predicate
          compound-access)

  (import (lispkit base))

  (begin

    (define-record-type <compound-object>
      (raw-compound-object subobjs)
      compound?
      (subobjs raw-object-subobjects))

    ;; private
    ;; flatten list of objects and potentially other compounds into simple list of
    ;; objects without compounds
    (define (assemble-subobjects in)
      (let loop ((in in)
                 (out '()))
        (if (null? in)
            (reverse out)
            (loop (cdr in)
                  (if (compound? (car in))
                      (append (reverse (compound-subobjects (car in))) out)
                      (cons (car in) out))))))

    (define (make-compound . subobjs)
      (raw-compound-object (assemble-subobjects subobjs)))

    (define (compound-subobjects obj)
      (if (compound? obj)
          (raw-object-subobjects obj)
          (list obj)))

    (define (compound-length obj)
      (if (compound? obj)
          (length (raw-object-subobjects obj))
          1))

    (define (compound-ref obj k)
      (if (compound? obj)
          (list-ref (compound-subobjects obj) k)
          obj))

    (define (compound-map mapper obj)
      (if (compound? obj)
          (apply make-compound (compound-map->list mapper obj))
          (make-compound (mapper obj))))

    (define (compound-map->list mapper obj)
      (map mapper (compound-subobjects obj)))

    (define (internal-filter pred list)
      (let loop ((list list) (result '()))
        (cond
          ((null? list)
            (reverse result))
          ((pred (car list))
            (loop (cdr list) (cons (car list) result)))
          (else
            (loop (cdr list) result)))))

    (define (compound-filter pred obj)
      (define subobjs (internal-filter pred (compound-subobjects obj)))
      (raw-compound-object subobjs))

    (define (compound-predicate pred obj)
      (and
        (or
          ;; compound itself satisfies pred
          (pred obj)
          ;; compound has subobj that satisfies pred
          (let loop ((subobjs (compound-subobjects obj)))
            (cond
              ((null? subobjs) #f)
              ((pred (car subobjs)) #t)
              (else (loop (cdr subobjs))))))
        ;; if matched pred, convert result to #t
        #t))

    (define (compound-access pred accessor default obj)
      (cond
        ((pred obj)
          (accessor obj))
        ((compound? obj)
          (let loop ((subobjs (compound-subobjects obj)))
            (cond
              ((null? subobjs) default)
              ((pred (car subobjs)) (accessor (car subobjs)))
              (else (loop (cdr subobjs))))))
        (else default)))
    )
  )
;;; SRFI 223
;;; Generalized binary search procedures
;;;
;;; Generalized procedures for binary search of vector-like data structures are provided
;;; which can be applied to any sequence type, including ones defined by the user,
;;; together with applications of these procedures for Scheme’s built-in vector and
;;; bytevector types.
;;;
;;; Copyright © 2021 Daphne Preston-Kendal. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 223)
  
  (export bisection
          bisect-left
          bisect-right
          vector-bisect-left
          vector-bisect-right)
  
  (import (lispkit base))
  
  (begin
    
    (define (bisect-left a val ref less? lo hi)
      (if (>= lo hi) lo
          (let ((mid (floor-quotient (+ lo hi) 2)))
            (if (less? (ref a mid) val)
                (bisect-left a val ref less? (+ mid 1) hi)
                (bisect-left a val ref less? lo mid)))))
    
    (define (bisect-right a val ref less? lo hi)
      (if (>= lo hi) lo
          (let ((mid (floor-quotient (+ lo hi) 2)))
            (if (less? val (ref a mid))
                (bisect-right a val ref less? lo mid)
                (bisect-right a val ref less? (+ mid 1) hi)))))
    
    (define bisection
      (case-lambda
        ((ref lo-hi-proc)
          (values
            (case-lambda
              ((a val less?)
                (let-values (((lo hi) (lo-hi-proc a)))
                  (bisect-left a val ref less? lo hi)))
              ((a val less? lo hi)
                (bisect-left a val ref less? lo hi)))
            (case-lambda
              ((a val less?)
                (let-values (((lo hi) (lo-hi-proc a)))
                  (bisect-right a val ref less? lo hi)))
              ((a val less? lo hi)
                (bisect-right a val ref less? lo hi)))))
        ((ref)
          (bisection ref
                     (lambda (a)
                       (error "both lo and hi arguments must be given to this procedure"))))))
    
    (define-values (vector-bisect-left vector-bisect-right)
      (bisection vector-ref (lambda (v) (values 0 (vector-length v)))))
  )
)
;;; SRFI 224
;;; Integer Mappings
;;;
;;; Integer maps, or `fxmappings`, are finite sets, where each element is an
;;; association between a fixnum (exact integer) key and an arbitrary Scheme
;;; object. They are similar to the general mappings of SRFI 146, but the
;;; restricted key-type allows implementations of fxmappings to benefit from
;;; optimized structures and algorithms.
;;; 
;;; This library provides a rich set of operations on fxmappings, including
;;; analogues of most of the forms provided by SRFI 146. Fxmappings have no
;;; intrinsic order, but may be treated as ordered sets, using the natural
;;; ordering on keys; a substantial sublibrary for working with fxmappings
;;; in this fashion is included.
;;; 
;;; Copyright © 2021 Wolfgang Corcoran-Mathe. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;; 
;;; The above copyright notice and this permission notice shall be included in all
;;; copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;;; FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
;;; COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
;;; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;; 
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi 224)
  
  (export ;; Constructors
          fxmapping
          fxmapping-unfold
          fxmapping-accumulate
          alist->fxmapping
          alist->fxmapping/combinator
          ;; Predicates
          fxmapping?
          fxmapping-contains?
          fxmapping-empty?
          fxmapping-disjoint?
          ;; Accessors
          fxmapping-min
          fxmapping-max
          fxmapping-ref
          fxmapping-ref/default
          ;; Updaters
          fxmapping-adjoin
          fxmapping-adjoin/combinator
          fxmapping-adjust
          fxmapping-set
          fxmapping-delete
          fxmapping-delete-all
          fxmapping-alter
          fxmapping-update
          fxmapping-delete-min
          fxmapping-delete-max
          fxmapping-update-min
          fxmapping-update-max
          fxmapping-pop-min
          fxmapping-pop-max
          ;; The whole fxmapping
          fxmapping-size
          fxmapping-count
          fxmapping-any?
          fxmapping-find
          fxmapping-every?
          ;; Traversal
          fxmapping-fold
          fxmapping-fold-right
          fxmapping-map
          fxmapping-map->list
          fxmapping-for-each
          fxmapping-relation-map
          ;; Filter
          fxmapping-filter
          fxmapping-remove
          fxmapping-partition
          ;; Copying and conversion
          fxmapping-keys
          fxmapping-values
          fxmapping->alist
          fxmapping->decreasing-alist
          fxmapping->generator
          fxmapping->decreasing-generator
          ;; Comparison
          fxmapping=?
          fxmapping<?
          fxmapping>?
          fxmapping<=?
          fxmapping>=?
          ;; Set theory operations
          fxmapping-union
          fxmapping-intersection
          fxmapping-difference
          fxmapping-xor
          fxmapping-union/combinator
          fxmapping-intersection/combinator
          ;; Submappings
          fxmapping-open-interval
          fxmapping-closed-interval
          fxmapping-open-closed-interval
          fxmapping-closed-open-interval
          fxsubmapping=
          fxsubmapping<
          fxsubmapping<=
          fxsubmapping>=
          fxsubmapping>
          fxmapping-split)
  
  (import (scheme base)
          (scheme case-lambda)
          (only (srfi 1) fold every)
          (only (srfi 128) comparator? =?)
          (srfi 143)
          (srfi 145)
          (only (srfi 158) make-coroutine-generator))

  (begin
    ;;; Pattern-matching macro for trie values.
    ;;;
    ;;; Based on William Byrd's pmatch modification of Oleg Kiselyov's
    ;;; simple linear pattern-matcher.
    
    ;;; Syntax:
    ;;;
    ;;; (tmatch exp <clause> ... [<else-clause>])
    ;;;
    ;;; <clause>      ::= (<pattern> [<guard>] exp ...)
    ;;; <else-clause> ::= (else exp ...)
    ;;; <guard>       ::= (guard boolean-exp ...)
    ;;; <pattern>     ::= empty
    ;;;                 | (leaf <pattern> <pattern>)
    ;;;                 | (branch <pattern> <pattern> <pattern> <pattern>)
    
    ;; (define-syntax tmatch
    ;;   (syntax-rules (else)
    ;;     ((tmatch exp (e ...) ...)
    ;;      (tmatch-aux #f exp (e ...) ...))
    ;;     ((tmatch name exp (e ...) ...)
    ;;      (tmatch-aux name exp (e ...) ...))))
    
    (define-syntax tmatch
      (syntax-rules (else guard)
        ((tmatch (f x ...) cs ...)
         (let ((v (f x ...)))
           (tmatch v cs ...)))
        ((tmatch v)
         (error "tmatch: no clause matched" v))
        ((tmatch _ (else e0 e1 ...)) (begin e0 e1 ...))
        ((tmatch v (pat (guard g ...) e0 e1 ...) cs ...)
         (let ((fk (lambda () (tmatch v cs ...))))
           (tpat v pat (if (and g ...) (begin e0 e1 ...) (fk)) (fk))))
        ((tmatch v (pat e0 e1 ...) cs ...)
         (let ((fk (lambda () (tmatch v cs ...))))
           (tpat v pat (begin e0 e1 ...) (fk))))))
    
    ;; Uses pmatch's `ppat' auxilliary macro, see below.
    (define-syntax tpat
      (syntax-rules (empty leaf branch unquote)
        ((tpat v empty kt kf) (if v kf kt))
        ((tpat v (leaf pkey pval) kt kf)
         (if (leaf? v)
             (let ((key (leaf-key v)) (value (leaf-value v)))
               (ppat key pkey (ppat value pval kt kf) kf))
             kf))
        ((tpat v (branch pp pm pl pr) kt kf)
         (if (branch? v)
             (let ((pfx (branch-prefix v))
                   (bit (branch-branching-bit v))
                   (left (branch-left v))
                   (right (branch-right v)))
               (ppat pfx
                     pp
                     (ppat bit pm (ppat left pl (ppat right pr kt kf) kf) kf)
                     kf))
             kf))))
    
    ;; Shorthands for a unary function that immediately pattern-matches
    ;; its trie parameter.
    (define-syntax tmatch-lambda
      (syntax-rules ()
        ((tmatch-lambda cs ...)
         (lambda (arg) (tmatch arg cs ...)))))
    
    ;;; pmatch, by Oleg Kiselyov, rev. Will Byrd.
    ;;; The original public-domain code can be found at
    ;;; http://okmij.org/ftp/Scheme/match-case-simple.scm
    
    ;; This is a new version of pmatch (August 8, 2012).
    ;; It has two important new features:
    ;; 1.  It allows for a name to be given to the pmatch if an error ensues.
    ;; 2.  A line from the specification has been removed. (see below).  Without
    ;; that line removed, it was impossible for a pattern to be (quote ,x),
    ;; which might be worth having especially when we write an interpreter
    ;; for Scheme, which includes quote as a language form.
    
    ;;; Code written by Oleg Kiselyov
    ;; (http://pobox.com/~oleg/ftp/)
    ;;;
    ;;; Taken from leanTAP.scm
    ;;; http://kanren.cvs.sourceforge.net/kanren/kanren/mini/leanTAP.scm?view=log
    
    ; A simple linear pattern matcher
    ; It is efficient (generates code at macro-expansion time) and simple:
    ; it should work on any R5RS (and R6RS) Scheme system.
    
    ; (pmatch exp <clause> ...[<else-clause>])
    ; <clause> ::= (<pattern> <guard> exp ...)
    ; <else-clause> ::= (else exp ...)
    ; <guard> ::= boolean exp | ()
    ; <pattern> :: =
    ;        ,var  -- matches always and binds the var
    ;                 pattern must be linear! No check is done
    ;         _    -- matches always
    ;        'exp  -- comparison with exp (using equal?)    REMOVED (August 8, 2012)
    ;        exp   -- comparison with exp (using equal?)
    ;        (<pattern1> <pattern2> ...) -- matches the list of patterns
    ;        (<pattern1> . <pattern2>)  -- ditto
    ;        ()    -- matches the empty list
    
    ;; We've removed the name parameter for now, since it seems to cause
    ;; problems for the expander in many Schemes.
    
    ;; (define-syntax pmatch
    ;;   (syntax-rules (else guard)
    ;;     ((pmatch v (e ...) ...)
    ;;      (pmatch-aux #f v (e ...) ...))
    ;;     ((pmatch v name (e ...) ...)
    ;;      (pmatch-aux name v (e ...) ...))))
    
    (define-syntax pmatch
      (syntax-rules (else guard)
        ((pmatch (rator rand ...) cs ...)
         (let ((v (rator rand ...)))     ; avoid multiple evals
           (pmatch v cs ...)))
        ((pmatch v)  ; no more clauses
         (error "pmatch failed" v))
        ((pmatch _ (else e0 e ...)) (begin e0 e ...))
        ((pmatch v (pat (guard g ...) e0 e ...) cs ...)
         (let ((fk (lambda () (pmatch v cs ...))))
           (ppat v pat (if (and g ...) (begin e0 e ...) (fk)) (fk))))
        ((pmatch v (pat e0 e ...) cs ...)
         (let ((fk (lambda () (pmatch v cs ...))))
           (ppat v pat (begin e0 e ...) (fk))))))
    
    (define-syntax ppat
      (syntax-rules (? unquote)
        ((ppat _ ? kt _) kt)  ; the ? wildcard always matches
        ((ppat v () kt kf) (if (null? v) kt kf))
    ;   ((ppat v (quote lit) kt kf) (if (equal? v (quote lit)) kt kf))
        ((ppat v (unquote var) kt _) (let ((var v)) kt))
        ((ppat v (x . y) kt kf)
         (if (pair? v)
           (let ((vx (car v)) (vy (cdr v)))
    	 (ppat vx x (ppat vy y kt kf) kf))
           kf))
        ((ppat v lit kt kf) (if (equal? v (quote lit)) kt kf))))
    
    ;;; Shorthands for functions that immediately pattern-match their
    ;;; parameter(s).
    
    ;; One-argument form.
    (define-syntax pmatch-lambda
      (syntax-rules ()
        ((pmatch-lambda cs ...)
         (lambda (arg) (pmatch arg cs ...)))))
    
    ;; Multi-argument form.
    (define-syntax pmatch-lambda*
      (syntax-rules ()
        ((pmatch-lambda* cs ...)
         (lambda args (pmatch args cs ...)))))
  )
  
  (begin
    ;;; This file implements integer maps as big-endian binary radix
    ;;; trees (AKA Patricia tries), as described by Chris Okasaki and
    ;;; Andrew Gill in "Fast Mergeable Integer Maps" (1998).  Integers
    ;;; in big-endian binary encoding are stored in a trie structure
    ;;; which allows fast lookup, insertion, and set-theoretical
    ;;; operations (union, intersection, etc.)
    ;;;
    ;;; A trie is represented by #f (the empty trie), a leaf, or a branch.
    ;;;
    ;;; Throughout this code, the empty trie (#f) is always returned
    ;;; as an explicit value, not, e.g. as the default value of an
    ;;; (and ...) expression, to clarify its use as a trie value.
    
    ;;;; Utility
    
    (define (swap-last-args proc)
      (lambda (k x y) (proc k y x)))
    
    (define the-empty-trie #f)
    
    (define (trie-empty? t) (not t))
    
    (define-record-type <leaf>
      (leaf key value)
      leaf?
      (key leaf-key)
      (value leaf-value))
    
    (define-record-type <branch>
      (raw-branch prefix branching-bit left right)
      branch?
      (prefix branch-prefix)
      (branching-bit branch-branching-bit)
      (left branch-left)
      (right branch-right))
    
    (define (valid-integer? x) (fixnum? x))
    
    ;; Zero the bits of k at and below (BE) the set bit of m.
    (define (mask k m)
      (if (fx=? m fx-least)
          0
          (fxand k (fxxor (fxnot (fx- m 1)) m))))
    
    ;; Does the m-masked prefix of k match p?
    (define (match-prefix? k p m)
      (fx=? (mask k m) p))
    
    (define (branching-bit p1 m1 p2 m2)
      (if (fxnegative? (fxxor p1 p2))
          fx-least        ; different signs
          (highest-bit-mask (fxxor p1 p2) (fxmax 1 (fx* 2 (fxmax m1 m2))))))
    
    ;; Two's-complement trick.
    (define (lowest-set-bit b)
      (fxand b (fxneg b)))
    
    (define (highest-bit-mask k guess-m)
      (let lp ((x (fxand k (fxnot (fx- guess-m 1)))))
        (let ((m (lowest-set-bit x)))
          (if (fx=? x m)
              m
              (lp (fx- x m))))))
    
    (define (zero-bit? k m)
      (fxzero? (fxand k m)))
    
    ;; Insert the association (key, value) into trie, replacing any old
    ;; association.
    (define (trie-insert trie key value)
      (trie-insert/combine trie key value (lambda (_k new _) new)))
    
    ;; Insert the association (key, value) into trie, preserving any old
    ;; association.
    (define (trie-adjoin trie key value)
      (trie-insert/combine trie key value (lambda (_k _new old) old)))
    
    ;; Insert (key, value) into trie if key doesn't already have an
    ;; association.  If it does, add a new association for key and
    ;; the result of calling combine on the key, new, and old values.
    (define (trie-insert/combine trie key value combine)
      (letrec
       ((new-leaf (leaf key value))
        (insert
         (lambda (t)
           (tmatch t
             (empty (leaf key value))
             ((leaf ,k ,v)
              (if (fx=? key k)
                  (leaf k (combine k value v))
                  (trie-join key 0 new-leaf k 0 t)))
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? key p m)
                  (if (zero-bit? key m)
                      (branch p m (insert l) r)
                      (branch p m l (insert r)))
                  (trie-join key 0 new-leaf p m t)))))))
        (assume (valid-integer? key) "invalid key")
        (insert trie)))
    
    (define (trie-join prefix1 mask1 trie1 prefix2 mask2 trie2)
      (let ((m (branching-bit prefix1 mask1 prefix2 mask2)))
        (if (zero-bit? prefix1 m)
            (branch (mask prefix1 m) m trie1 trie2)
            (branch (mask prefix1 m) m trie2 trie1))))
    
    ;; If (key, value) is an association in trie, then replace it
    ;; with (key, (proc key value)).  Otherwise, return a copy of trie.
    (define (trie-adjust trie key proc)
      (letrec
       ((update
         (lambda (t)
           (tmatch t
             (empty t)
             ((leaf ,k ,v)
              (if (fx=? key k) (leaf k (proc k v)) t))
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? key p m)
                  (if (zero-bit? key m)
                      (branch p m (update l) r)
                      (branch p m l (update r)))
                  t))))))
        (update trie)))
    
    (define (trie-update trie key proc failure wrapper)
      (letrec
       ((update
         (lambda (t build)
           (tmatch t
             (empty (failure))
             ((leaf ,k ,v)
              (if (fx=? key k)
                  (proc k
                        v
                        (lambda (v*) (wrapper (build (leaf k v*))))
                        (lambda () (wrapper (build the-empty-trie))))
                  (failure)))
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? key p m)
                  (if (zero-bit? key m)
                      (update l (lambda (l*) (build (branch p m l* r))))
                      (update r (lambda (r*) (build (branch p m l r*)))))
                  (failure)))))))
        (update trie values)))
    
    (define (trie-alter trie key failure success wrapper)
      (letrec
       ((update
         (lambda (t build)
           (tmatch t
             (empty
              (failure (lambda (v)
                         (wrapper (build (leaf key v))))     ; insert
                       (lambda ()
                         (wrapper (build the-empty-trie))))) ; ignore
             ((leaf ,k ,v)
              (if (fx=? key k)
                  (success k
                           v
                           (lambda (v*)                      ; replace
                             (wrapper (build (leaf k v*))))
                           (lambda ()                        ; delete
                             (wrapper (build the-empty-trie))))
                  (failure (lambda (u)                       ; insert
                             (wrapper
                              (build (trie-join key 0 (leaf key u) k 0 t))))
                           (lambda ()                        ; ignore
                             (wrapper (build t))))))
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? key p m)
                  (if (zero-bit? key m)
                      (update l (lambda (l*)
                                  (build (branch p m l* r))))
                      (update r (lambda (r*)
                                  (build (branch p m l r*)))))
                  (failure (lambda (v)                    ; insert
                             (wrapper
                              (build (trie-join key 0 (leaf key v) p m t))))
                           (lambda ()                     ; ignore
                             (wrapper (build t))))))))))
        (update trie values)))
    
    ;; If `key' has an association in `trie', then call `success' with
    ;; on the associated value.  Otherwise, call `failure'.
    (define (trie-assoc trie key failure success)
      (letrec
       ((search
         (tmatch-lambda
           ((leaf ,k ,v) (guard (fx=? k key)) (success v))
           ((branch ,p ,m ,l ,r) (guard (match-prefix? key p m))
            (if (zero-bit? key m) (search l) (search r)))
           (else (failure)))))
        (search trie)))
    
    ;; If `key' has an association in `trie', then return the associated
    ;; value.  Otherwise, return `default'.
    (define (trie-assoc/default trie key default)
      (letrec
       ((search
         (tmatch-lambda
           ((leaf ,k ,v) (guard (fx=? k key)) v)
           ((branch ,p ,m ,l ,r) (guard (match-prefix? key p m))
            (if (zero-bit? key m) (search l) (search r)))
           (else default))))
        (search trie)))
    
    ;; Return the number of associations in trie.
    (define (trie-size trie)
      (if (trie-empty? trie)
          0
          (let lp ((n 0) (t trie) (kont values))
            (cond ((leaf? t) (kont (+ n 1)))
                  (else (lp n
                            (branch-left t)
                            (lambda (m)
                              (lp m (branch-right t) kont))))))))
    
    (define (trie-contains? trie key)
      (letrec
       ((search
         (tmatch-lambda
           ((leaf ,k ,v) (fx=? k key))
           ((branch ,p ,m ,l ,r) (guard (match-prefix? key p m))
            (if (zero-bit? key m) (search l) (search r)))
           (else #f))))
        (search trie)))
    
    (define (trie-find pred trie failure success)
      (letrec
       ((search
         (lambda (t kont)
           (tmatch t
             ((leaf ,k ,v) (guard (pred k v)) (success k v))
             ((branch ? ? ,l ,r) (search l (lambda () (search r kont))))
             (else (kont))))))
        (tmatch trie
          ((branch ? ,m ,l ,r) (guard (negative? m))
           (search r (lambda () (search l failure))))
          (else (search trie failure)))))
    
    (define (branching-bit-higher? mask1 mask2)
      (if (negative? (fxxor mask1 mask2))  ; signs differ
          (negative? mask1)
          (fx>? mask1 mask2)))
    
    ;; Merge two tries.  `combine' is used to merge duplicated mappings.
    (define (trie-merge combine trie1 trie2)
      (letrec
        ((merge
          (lambda (s t)
            (cond ((trie-empty? s) t)
                  ((trie-empty? t) s)
                  ((leaf? s)
                   (trie-insert/combine t (leaf-key s) (leaf-value s) combine))
                  ((leaf? t)
                   (trie-insert/combine s
                                        (leaf-key t)
                                        (leaf-value t)
                                        (swap-last-args combine)))
                  ((and (branch? s) (branch? t)) (merge-branches s t)))))
         (merge-branches
          (lambda (s t)
            (tmatch s
              ((branch ,p ,m ,s1 ,s2)
               (tmatch t
                 ((branch ,q ,n ,t1 ,t2)
                  (cond ((and (fx=? m n) (fx=? p q))
                         (branch p m (merge s1 t1) (merge s2 t2)))
                        ((and (branching-bit-higher? m n)
                              (match-prefix? q p m))
                         (if (zero-bit? q m)
                             (branch p m (merge s1 t) s2)
                             (branch p m s1 (merge s2 t))))
                        ((and (branching-bit-higher? n m)
                              (match-prefix? p q n))
                         (if (zero-bit? p n)
                             (branch q n (merge s t1) t2)
                             (branch q n t1 (merge s t2))))
                        (else (trie-join p m s q n t))))))))))
        (merge trie1 trie2)))
    
    ;; Construct a branch only if the subtrees are non-empty.
    (define (branch prefix mask trie1 trie2)
      (cond ((not trie1) trie2)
            ((not trie2) trie1)
            (else (raw-branch prefix mask trie1 trie2))))
    
    (define (trie-union s t)
      (trie-merge trie-insert s t))
    
    (define (trie-partition pred trie)
      (letrec
       ((part
         (lambda (t)
           (tmatch t
             (empty (values the-empty-trie the-empty-trie))
             ((leaf ,k ,v)
              (if (pred k v)
                  (values t the-empty-trie)
                  (values the-empty-trie t)))
             ((branch ,p ,m ,l ,r)
              (let-values (((il ol) (part l))
                           ((ir or) (part r)))
                (values (branch p m il ir) (branch p m ol or))))))))
        (part trie)))
    
    ;;;; Map and fold
    
    (define (trie-map proc trie)
      (letrec
       ((tmap
         (tmatch-lambda
           (empty the-empty-trie)
           ((leaf ,k ,v)
            (leaf k (proc k v)))
           ((branch ,p ,m ,l ,r)
            (branch p m (tmap l) (tmap r))))))
        (tmap trie)))
    
    (define (trie-fold-left proc nil trie)
      (if (trie-empty? trie)
          nil
          (let lp ((t trie) (b nil) (kont values))
            (if (leaf? t)
                (kont (proc (leaf-key t) (leaf-value t) b))
                (lp (branch-left t)
                    b
                    (lambda (c)
                      (lp (branch-right t) c kont)))))))
    
    (define (trie-fold-right proc nil trie)
      (if (trie-empty? trie)
          nil
          (let lp ((t trie) (b nil) (kont values))
            (if (leaf? t)
                (kont (proc (leaf-key t) (leaf-value t) b))
                (lp (branch-right t)
                    b
                    (lambda (c)
                      (lp (branch-left t) c kont)))))))
    
    (define (trie-filter pred trie)
      (letrec ((filter
                (lambda (t)
                  (tmatch t
                    (empty the-empty-trie)
                    ((leaf ,k ,v) (guard (pred k v)) t)
                    ((leaf ? ?) the-empty-trie)
                    ((branch ,p ,m ,l ,r)
                     (branch p m (filter l) (filter r)))))))
        (filter trie)))
    
    (define (trie-min trie)
      (letrec
       ((search
         (tmatch-lambda
           ((leaf ,k ,v) (values k v))
           ((branch ? ? ,l ?) (search l)))))
        (tmatch trie
          (empty (error "empty trie"))
          ((leaf ,k ,v) (values k v))
          ((branch ? ,m ,l ,r)
           (if (fxnegative? m) (search r) (search l))))))
    
    (define (trie-update-min trie success wrapper)
      (letrec
       ((update
         (lambda (t build)
           (tmatch t
             (empty (wrapper (build the-empty-trie)))
             ((leaf ,k ,v)
              (success k
                       v
                       (lambda (v*)
                         (wrapper (build (leaf k v*))))
                       (lambda ()
                         (wrapper (build the-empty-trie)))))
             ((branch ,p ,m ,l ,r)
              (update l (lambda (l*)
                          (build (branch p m l* r)))))))))
        (tmatch trie
          ((branch ,p ,m ,l ,r)
           (if (negative? m)
               (update r (lambda (r*) (branch p m l r*)))
               (update l (lambda (l*) (branch p m l* r)))))
          (else (update trie values)))))
    
    (define (trie-pop-min trie)
      (letrec
       ((pop
         (tmatch-lambda
           (empty (error "trie-pop-min: empty trie"))
           ((leaf ,k ,v) (values k v the-empty-trie))
           ((branch ,p ,m ,l ,r)
            (let-values (((k v l*) (pop l)))
              (values k v (branch p m l* r)))))))
        (tmatch trie
          ((branch ,p ,m ,l ,r)
           (if (fxnegative? m)
               (let-values (((k v r*) (pop r)))
                 (values k v (branch p m l r*)))
               (let-values (((k v l*) (pop l)))
                 (values k v (branch p m l* r)))))
          (else (pop trie)))))
    
    (define (trie-max trie)
      (letrec
       ((search
         (tmatch-lambda
           ((leaf ,k ,v) (values k v))
           ((branch ? ? ? ,r) (search r)))))
        (tmatch trie
          (empty (error "empty trie"))
          ((branch ? ,m ,l ,r)
           (if (fxnegative? m) (search l) (search r)))
          ((leaf ,k ,v) (values k v)))))
    
    (define (trie-update-max trie success wrapper)
      (letrec
       ((update
         (lambda (t build)
           (tmatch t
             (empty (wrapper (build the-empty-trie)))
             ((leaf ,k ,v)
              (success k
                       v
                       (lambda (v*)
                         (wrapper (build (leaf k v*))))
                       (lambda ()
                         (wrapper (build the-empty-trie)))))
             ((branch ,p ,m ,l ,r)
              (update r (lambda (r*)
                          (build (branch p m l r*)))))))))
        (tmatch trie
          ((branch ,p ,m ,l ,r)
           (if (negative? m)
               (update l (lambda (l*) (branch p m l* r)))
               (update r (lambda (r*) (branch p m l r*)))))
          (else (update trie values)))))
    
    (define (trie-pop-max trie)
      (letrec
       ((pop
         (tmatch-lambda
           (empty (error "trie-pop-max: empty trie"))
           ((leaf ,k ,v) (values k v the-empty-trie))
           ((branch ,p ,m ,l ,r)
            (let-values (((k v r*) (pop r)))
              (values k v (branch p m l r*)))))))
        (tmatch trie
          ((branch ,p ,m ,l ,r)
           (if (fxnegative? m)
               (let-values (((k v l*) (pop l)))
                 (values k v (branch p m l* r)))
               (let-values (((k v r*) (pop r)))
                 (values k v (branch p m l r*)))))
          (else (pop trie)))))
    
    ;;;; Comparisons
    
    (define (trie=? comp trie1 trie2)
      (let loop ((s trie1) (t trie2))
        (cond ((and (trie-empty? s) (trie-empty? t)) #t)
              ((leaf? s)
               (and (leaf? t)
                    (fx=? (leaf-key s) (leaf-key t))
                    (=? comp (leaf-value s) (leaf-value t))))
              ((and (branch? s) (branch? t))
               (tmatch s
                ((branch ,p ,m ,l1 ,r1)
                 (tmatch t
                   ((branch ,q ,n ,l2 ,r2)
                    (and (fx=? m n)
                         (fx=? p q)
                         (loop l1 l2)
                         (loop r1 r2)))))))
              (else #f))))
    
    ;; Returns the symbol 'less' if trie1 is a proper subset of trie2,
    ;; 'equal' if they are the same, and 'greater' otherwise.  NB that
    ;; disjoint mappings will compare as greater.
    (define (trie-subset-compare comp trie1 trie2)
      (letrec
       ((compare
         (lambda (s t)
           (cond ((eqv? s t) 'equal)
                 ((trie-empty? s) 'less)
                 ((trie-empty? t) 'greater)  ; disjoint
                 ((and (leaf? s) (leaf? t))
                  (if (and (fx=? (leaf-key s) (leaf-key t))
                           (=? comp (leaf-value s) (leaf-value t)))
                      'equal
                      'greater))
                 ((leaf? s)             ; leaf / branch
                  (tmatch t
                    ((branch ,p ,m ,l ,r)
                     (let ((k (leaf-key s)))
                       (if (match-prefix? k p m)
                           (case (compare s (if (zero-bit? k m) l r))
                             ((greater) 'greater)
                             (else 'less)))))))
                 ((leaf? t) 'greater)   ; branch / leaf
                 (else (compare-branches s t)))))
        (compare-branches
         (lambda (s t)
           (tmatch s
             ((branch ,p ,m ,sl ,sr)
              (tmatch t
                ((branch ,q ,n ,tl ,tr)
                 (cond ((branching-bit-higher? m n) 'greater)
                       ((branching-bit-higher? n m)
                        (if (match-prefix? p q n)
                            (let ((res (if (zero-bit? p n)
                                           (compare s tl)
                                           (compare s tr))))
                              (if (eqv? res 'greater) res 'less))
                            'greater))
                       ((fx=? p q)  ; same prefix, compare subtrees
                        (let ((cl (compare sl tl)) (cr (compare sr tr)))
                          (cond ((or (eqv? cl 'greater) (eqv? cr 'greater))
                                 'greater)
                                ((and (eqv? cl 'equal) (eqv? cr 'equal))
                                 'equal)
                                (else 'less))))
                       (else 'greater)))))))))  ; disjoint
        (compare trie1 trie2)))
    
    (define (trie-proper-subset? comp trie1 trie2)
      (eqv? (trie-subset-compare comp trie1 trie2) 'less))
    
    ;; Two tries are disjoint if they have no keys in common.
    (define (trie-disjoint? trie1 trie2)
      (letrec
       ((disjoint?
         (lambda (s t)
           (or (trie-empty? s)
               (trie-empty? t)
               (cond ((leaf? s)
                      (let ((k (leaf-key s)))
                        (if (leaf? t)
                            (not (fx=? k (leaf-key t)))
                            (not (trie-contains? t k)))))
                     ((leaf? t) (not (trie-contains? s (leaf-key t))))
                     (else (branches-disjoint? s t))))))
        (branches-disjoint?
         (lambda (s t)
           (tmatch s
             ((branch ,p ,m ,sl ,sr)
              (tmatch t
                ((branch ,q ,n ,tl ,tr)
                 (cond ((and (fx=? m n) (fx=? p q))
                        (and (disjoint? sl tl) (disjoint? sr tr)))
                       ((and (branching-bit-higher? m n)
                             (match-prefix? q p m))
                        (if (zero-bit? q m)
                            (disjoint? sl t)
                            (disjoint? sr t)))
                       ((and (branching-bit-higher? n m)
                             (match-prefix? p q n))
                        (if (zero-bit? p n)
                            (disjoint? s tl)
                            (disjoint? s tr)))
                       (else #t)))))))))      ; the prefixes disagree
        (disjoint? trie1 trie2)))
    
    (define (trie-delete trie key)
      (letrec
       ((update
         (lambda (t)
           (tmatch t
             (empty the-empty-trie)
             ((leaf ,k ?) (if (fx=? k key) the-empty-trie t))
             ((branch ,p ,m ,l ,r) (guard (match-prefix? key p m))
              (if (zero-bit? key m)
                   (branch p m (update l) r)
                   (branch p m l (update r))))
             (else t)))))  ; key doesn't occur in t
        (update trie)))
    
    (define (trie-intersection combine trie1 trie2)
      (letrec
       ((intersect
         (lambda (s t)
           (cond ((or (trie-empty? s) (trie-empty? t)) the-empty-trie)
                 ((and (leaf? s) (leaf? t))
                  (tmatch s
                    ((leaf ,sk ,sv)
                     (tmatch t
                       ((leaf ,tk ,tv) (guard (fx=? sk tk))
                        (leaf sk (combine sk sv tv)))
                       (else the-empty-trie)))))
                 ((leaf? s) (insert-leaf combine s t))
                 ((leaf? t) (insert-leaf (swap-last-args combine) t s))
                 (else (intersect-branches s t)))))
        (insert-leaf
         (lambda (comb lf t)
           (tmatch lf
             ((leaf ,k ,v)
              (let lp ((t t))
                (tmatch t
                  ((leaf ,tk ,tv) (guard (fx=? k tk))
                   (leaf k (comb k v tv)))
                  ((leaf ? ?) the-empty-trie)
                  ((branch ,p ,m ,l ,r)
                   (and (match-prefix? k p m)
                        (if (zero-bit? k m) (lp l) (lp r))))
                  (else the-empty-trie)))))))
        (intersect-branches
         (lambda (s t)
           (tmatch s
             ((branch ,p ,m ,sl ,sr)
              (tmatch t
                ((branch ,q ,n ,tl ,tr)
                 (cond ((branching-bit-higher? m n)
                        (and (match-prefix? q p m)
                             (if (zero-bit? q m)
                                 (intersect sl t)
                                 (intersect sr t))))
                       ((branching-bit-higher? n m)
                        (and (match-prefix? p q n)
                             (if (zero-bit? p n)
                                 (intersect s tl)
                                 (intersect s tr))))
                       ((fx=? p q)
                        (branch p m (intersect sl tl) (intersect sr tr)))
                       (else the-empty-trie)))))))))
        (intersect trie1 trie2)))
    
    (define (trie-difference trie1 trie2)
      (letrec
       ((difference
         (lambda (s t)
           (cond ((trie-empty? s) the-empty-trie)
                 ((trie-empty? t) s)
                 ((leaf? s)
                  (trie-assoc t
                              (leaf-key s)
                              (lambda () s)
                              (lambda (_) the-empty-trie)))
                 ((leaf? t) (trie-delete s (leaf-key t)))
                 (else (branch-difference s t)))))
        (branch-difference
         (lambda (s t)
           (tmatch s
             ((branch ,p ,m ,sl ,sr)
              (tmatch t
                ((branch ,q ,n ,tl ,tr)
                 (cond ((and (fx=? m n) (fx=? p q))
                        (branch p m (difference sl tl) (difference sr tr)))
                       ((and (branching-bit-higher? m n)
                             (match-prefix? q p m))
                        (if (zero-bit? q m)
                            (branch p m (difference sl t) sr)
                            (branch p m sl (difference sr t))))
                       ((and (branching-bit-higher? n m)
                             (match-prefix? p q n))
                        (if (zero-bit? p n)
                            (difference s tl)
                            (difference s tr)))
                       (else s)))))))))
        (difference trie1 trie2)))
    
    ;; Remove the assoc for key if it exists in trie; otherwise, add the
    ;; assoc (key, value).
    (define (%trie-insert-xor trie key value)
      (trie-alter trie
                  key
                  (lambda (insert _ig) (insert value))
                  (lambda (_k _v _rep delete) (delete))
                  values))
    
    (define (trie-xor trie1 trie2)
      (letrec
        ((merge
          (lambda (s t)
            (cond ((trie-empty? s) t)
                  ((trie-empty? t) s)
                  ((leaf? s)
                   (%trie-insert-xor t (leaf-key s) (leaf-value s)))
                  ((leaf? t)
                   (%trie-insert-xor s (leaf-key t) (leaf-value t)))
                  (else (merge-branches s t)))))
         (merge-branches
          (lambda (s t)
            (tmatch s
              ((branch ,p ,m ,s1 ,s2)
               (tmatch t
                 ((branch ,q ,n ,t1 ,t2)
                  (cond ((and (fx=? m n) (fx=? p q))
                         (branch p m (merge s1 t1) (merge s2 t2)))
                        ((and (branching-bit-higher? m n) (match-prefix? q p m))
                         (if (zero-bit? q m)
                             (branch p m (merge s1 t) s2)
                             (branch p m s1 (merge s2 t))))
                        ((and (branching-bit-higher? n m) (match-prefix? p q n))
                         (if (zero-bit? p n)
                             (branch q n (merge s t1) t2)
                             (branch q n t1 (merge s t2))))
                        (else
                         (trie-join p m s q n t))))))))))
        (merge trie1 trie2)))
    
    ;; Return a trie containing all the elements of `trie' which are
    ;; less than k, if `inclusive' is false, or less than or equal to
    ;; k if `inclusive' is true.
    (define (subtrie< trie k inclusive)
      (letrec
        ((split
          (lambda (t)
            (tmatch t
              (empty the-empty-trie)
              ((leaf ,tk ?)
               (cond ((fx<? tk k) t)
                     ((and (fx=? tk k) inclusive) t)
                     (else the-empty-trie)))
              ((branch ,p ,m ,l ,r)
               (if (match-prefix? k p m)
                   (if (zero-bit? k m)
                       (split l)
                       (trie-union l (split r)))
                   (and (fx<? p k) t)))))))
        (tmatch trie
          ((branch ? ,m ,l ,r) (guard (fxnegative? m))
           (if (fxnegative? k) (split r) (trie-union (split l) r)))
          (else (split trie)))))
    
    ;; Return a trie containing all the elements of `trie' which are
    ;; greater than k, if `inclusive' is false, or greater than or equal
    ;; to k if `inclusive' is true.
    (define (subtrie> trie k inclusive)
      (letrec
       ((split
         (lambda (t)
           (tmatch t
             (empty the-empty-trie)
             ((leaf ,tk ?)
              (cond ((fx>? tk k) t)
                    ((and (fx=? tk k) inclusive) t)
                    (else the-empty-trie)))
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? k p m)
                  (if (zero-bit? k m)
                      (trie-union (split l) r)
                      (split r))
                  (and (fx>? p k) t)))))))
        (tmatch trie
          ((branch ? ,m ,l ,r) (guard (fxnegative? m))
           (if (fxnegative? k) (trie-union (split r) l) (split l)))
          (else (split trie)))))
    
    ;; Return a trie containing all the elements of `trie' which are
    ;; greater than/greater than or equal to a and less than/less than
    ;; or equal to b, depending on the truth values of
    ;; low-/high-inclusive.
    (define (subtrie-interval trie a b low-inclusive high-inclusive)
      (letrec
       ((interval
         (lambda (t)
           (tmatch t
             (empty the-empty-trie)
             ((leaf ,tk ?)
              (and ((if low-inclusive fx>=? fx>?) tk a)
                   ((if high-inclusive fx<=? fx<?) tk b)
                   t))
             (else (branch-interval t)))))
        (branch-interval
         (lambda (t)
           (tmatch t
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? a p m)
                  (if (zero-bit? a m)
                      (if (match-prefix? b p m)
                          (if (zero-bit? b m)
                              (interval l)  ; all x < b is in l
                              (trie-union (subtrie> l a low-inclusive)
                                          (subtrie< r b high-inclusive)))
                          ;; everything or nothing is less than b
                          (and (fx<? b p)
                               (trie-union (subtrie> l a low-inclusive) r)))
                      (interval r)) ; all x > b is in r
                  ;; everything or nothing is greater than a
                  (and (fx>? p a) (subtrie< t b high-inclusive))))))))
        (tmatch trie
          ((branch ? ,m ,l ,r) (guard (fxnegative? m))
           (cond ((and (fxnegative? a) (fxnegative? b)) (interval r))
                 ((and (fxpositive? a) (fxpositive? b)) (interval l))
                  ;; (a, 0) U (0, b)
                  (else (trie-union (subtrie> r a low-inclusive)
                                    (subtrie< l b high-inclusive)))))
          (else (interval trie)))))
    
    (define (trie-split trie pivot)
      (letrec
       ((split
         (lambda (t)
           (tmatch t
             ((leaf ,k ,v)
              (if (fx<=? k pivot)
                  (values t the-empty-trie)
                  (values the-empty-trie t)))
             ((branch ,p ,m ,l ,r)
              (if (match-prefix? pivot p m)
                  (if (zero-bit? pivot m)
                      (let-values (((ta tb) (split l)))
                        (values ta (trie-union tb r)))
                      (let-values (((ta tb) (split r)))
                        (values (trie-union l ta) tb)))
                  (if (fx<=? p pivot)
                      (values t the-empty-trie)
                      (values the-empty-trie t))))))))
    
        (tmatch trie
          (empty (values the-empty-trie the-empty-trie))
          ((branch ? ,m ,l ,r) (guard (fxnegative? m))
           (if (fxnegative? pivot)
               (let-values (((ta tb) (split r)))
                 (values ta (trie-union tb l)))
               (let-values (((ta tb) (split l)))
                 (values (trie-union r ta) tb))))
          (else (split trie)))))
    
    ;;;; Tries as (Integer, *) relations
    
    (define (trie-relation-map proc trie)
      (trie-fold-left (lambda (k v t)
                        (let-values (((k* v*) (proc k v)))
                          (assume (valid-integer? k*))
                          (trie-insert t k* v*)))
                      the-empty-trie
                      trie))    
  )
  
  (begin
    ;;;; Utility
    
    (define (plist-fold proc nil ps)
      (let loop ((b nil) (ps ps))
        (pmatch ps
          (() b)
          ((,k ,v . ,ps*)
           (loop (proc k v b) ps*))
          (else (error "plist-fold: invalid plist")))))
    
    (define (first-arg _k x _y) x)
    (define (second-arg _k _x y) y)
    
    (define (constantly x)
      (lambda (_) x))
    
    ;;;; Type
    
    (define-record-type <fxmapping>
      (raw-fxmapping trie)
      fxmapping?
      (trie fxmapping-trie))
    
    ;;;; Constructors
    
    (define (fxmapping . args)
      (raw-fxmapping
        (plist-fold (lambda (k v trie) (trie-adjoin trie k v))
                    the-empty-trie
                    args)))
    
    (define (pair-or-null? x)
      (or (pair? x) (null? x)))
    
    (define (alist->fxmapping/combinator comb as)
      (assume (procedure? comb))
      (assume (pair-or-null? as))
      (raw-fxmapping
        (fold (lambda (p trie)
                (assume (pair? p) "alist->fxmapping/combinator: not a pair")
                (trie-insert/combine trie (car p) (cdr p) comb))
              the-empty-trie
              as)))
    
    (define (alist->fxmapping as)
      (alist->fxmapping/combinator second-arg as))
    
    (define fxmapping-unfold
      (case-lambda
        ((stop? mapper successor seed)                ; fast path
         (assume (procedure? stop?))
         (assume (procedure? mapper))
         (assume (procedure? successor))
         (let lp ((trie the-empty-trie) (seed seed))
           (if (stop? seed)
               (raw-fxmapping trie)
               (let-values (((k v) (mapper seed)))
                 (assume (valid-integer? k))
                 (lp (trie-adjoin trie k v) (successor seed))))))
        ((stop? mapper successor . seeds)             ; variadic path
         (assume (procedure? stop?))
         (assume (procedure? mapper))
         (assume (procedure? successor))
         (assume (pair? seeds))
         (let lp ((trie the-empty-trie) (seeds seeds))
           (if (apply stop? seeds)
               (raw-fxmapping trie)
               (let-values (((k v) (apply mapper seeds))
                            (seeds* (apply successor seeds)))
                 (assume (valid-integer? k))
                 (lp (trie-adjoin trie k v) seeds*)))))))
    
    (define fxmapping-accumulate
      (case-lambda
        ((proc seed)                                ; fast path
         (assume (procedure? proc))
         (call-with-current-continuation
          (lambda (k)
            (let lp ((trie the-empty-trie) (seed seed))
              (let-values (((k v seed*)
                            (proc (lambda xs (apply k (raw-fxmapping trie) xs))
                                  seed)))
                (lp (trie-adjoin trie k v) seed*))))))
        ((proc . seeds)                             ; variadic path
         (assume (procedure? proc))
         (assume (pair? seeds))
         (call-with-current-continuation
          (lambda (k)
            (let lp ((trie the-empty-trie) (seeds seeds))
              (let-values (((k v . seeds*)
                            (apply proc
                                   (lambda xs (apply k (raw-fxmapping trie) xs))
                                   seeds)))
                (lp (trie-adjoin trie k v) seeds*))))))))
    
    ;;;; Predicates
    
    (define (fxmapping-contains? fxmap n)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? n))
      (trie-contains? (fxmapping-trie fxmap) n))
    
    (define (fxmapping-empty? fxmap)
      (assume (fxmapping? fxmap))
      (eqv? (fxmapping-trie fxmap) the-empty-trie))
    
    (define (fxmapping-disjoint? fxmap1 fxmap2)
      (assume (fxmapping? fxmap1))
      (assume (fxmapping? fxmap2))
      (trie-disjoint? (fxmapping-trie fxmap1) (fxmapping-trie fxmap2)))
    
    ;;;; Accessors
    
    (define fxmapping-ref
      (case-lambda
        ((fxmap key)
         (fxmapping-ref fxmap
                        key
                        (lambda () (error "fxmapping-ref: key not found"
                                          key
                                          fxmap))
                        values))
        ((fxmap key failure)
         (fxmapping-ref fxmap key failure values))
        ((fxmap key failure success)
         (assume (fxmapping? fxmap))
         (assume (valid-integer? key))
         (assume (procedure? failure))
         (assume (procedure? success))
         (trie-assoc (fxmapping-trie fxmap) key failure success))))
    
    (define (fxmapping-ref/default fxmap key default)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (trie-assoc/default (fxmapping-trie fxmap) key default))
    
    (define (fxmapping-min fxmap)
      (assume (not (fxmapping-empty? fxmap)))
      (trie-min (fxmapping-trie fxmap)))
    
    (define (fxmapping-max fxmap)
      (assume (not (fxmapping-empty? fxmap)))
      (trie-max (fxmapping-trie fxmap)))
    
    ;;;; Updaters
    
    (define fxmapping-adjoin/combinator
      (case-lambda
        ((fxmap combine key value)      ; one-assoc fast path
         (raw-fxmapping
          (trie-insert/combine (fxmapping-trie fxmap) key value combine)))
        ((fxmap combine . ps)
         (raw-fxmapping
          (plist-fold (lambda (k v t)
                        (trie-insert/combine t k v combine))
                      (fxmapping-trie fxmap)
                      ps)))))
    
    ;; Preserve existing associations for keys.
    (define fxmapping-adjoin
      (case-lambda
        ((fxmap key value)              ; one-assoc fast path
         (raw-fxmapping
          (trie-adjoin (fxmapping-trie fxmap) key value)))
        ((fxmap . ps)
         (raw-fxmapping
          (plist-fold (lambda (k v t) (trie-adjoin t k v))
                      (fxmapping-trie fxmap)
                      ps)))))
    
    ;; Replace existing associations for keys.
    (define fxmapping-set
      (case-lambda
        ((fxmap key value)      ; one-assoc fast path
         (raw-fxmapping
          (trie-insert (fxmapping-trie fxmap) key value)))
        ((fxmap . ps)
         (raw-fxmapping
          (plist-fold (lambda (k v t) (trie-insert t k v))
                      (fxmapping-trie fxmap)
                      ps)))))
    
    (define (fxmapping-adjust fxmap key proc)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (assume (procedure? proc))
      (raw-fxmapping (trie-adjust (fxmapping-trie fxmap) key proc)))
    
    (define fxmapping-delete
      (case-lambda
        ((fxmap key)      ; fast path
         (assume (fxmapping? fxmap))
         (assume (valid-integer? key))
         (raw-fxmapping (trie-delete (fxmapping-trie fxmap) key)))
        ((fxmap . keys)
         (fxmapping-delete-all fxmap keys))))
    
    (define (fxmapping-delete-all fxmap keys)
      (assume (or (pair? keys) (null? keys)))
      (let ((key-map (fxmapping-trie
                      (fxmapping-unfold null?
                                        (lambda (ks) (values (car ks) #t))
                                        cdr
                                        keys))))
        (fxmapping-remove (lambda (k _) (trie-contains? key-map k))
                          fxmap)))
    
    (define fxmapping-update
      (case-lambda
        ((fxmap key success)
         (fxmapping-update fxmap
                           key
                           success
                           (lambda ()
                             (error "fxmapping-update: key not found" key fxmap))))
        ((fxmap key success failure)
         (assume (fxmapping? fxmap))
         (assume (valid-integer? key))
         (assume (procedure? success))
         (assume (procedure? failure))
         (trie-update (fxmapping-trie fxmap) key success failure raw-fxmapping))))
    
    (define (fxmapping-alter fxmap key failure success)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (assume (procedure? failure))
      (assume (procedure? success))
      (trie-alter (fxmapping-trie fxmap) key failure success raw-fxmapping))
    
    (define (fxmapping-delete-min fxmap)
      (fxmapping-update-min fxmap
                            (lambda (_k _v _rep delete)
                              (delete))))
    
    (define (fxmapping-update-min fxmap success)
      (assume (fxmapping? fxmap))
      (assume (not (fxmapping-empty? fxmap)))
      (assume (procedure? success))
      (trie-update-min (fxmapping-trie fxmap) success raw-fxmapping))
    
    (define (fxmapping-pop-min fxmap)
      (assume (fxmapping? fxmap))
      (assume (not (fxmapping-empty? fxmap)))
      (let-values (((k v trie) (trie-pop-min (fxmapping-trie fxmap))))
        (values k v (raw-fxmapping trie))))
    
    (define (fxmapping-delete-max fxmap)
      (fxmapping-update-max fxmap
                            (lambda (_k _v _rep delete)
                              (delete))))
    
    (define (fxmapping-update-max fxmap success)
      (assume (fxmapping? fxmap))
      (assume (not (fxmapping-empty? fxmap)))
      (assume (procedure? success))
      (trie-update-max (fxmapping-trie fxmap) success raw-fxmapping))
    
    (define (fxmapping-pop-max fxmap)
      (assume (fxmapping? fxmap))
      (assume (not (fxmapping-empty? fxmap)))
      (let-values (((k v trie) (trie-pop-max (fxmapping-trie fxmap))))
        (values k v (raw-fxmapping trie))))
    
    ;;;; The whole fxmapping
    
    (define (fxmapping-size fxmap)
      (assume (fxmapping? fxmap))
      (trie-size (fxmapping-trie fxmap)))
    
    (define fxmapping-find
      (case-lambda
        ((pred fxmap failure)
         (fxmapping-find pred fxmap failure values))
        ((pred fxmap failure success)
         (assume (procedure? pred))
         (assume (fxmapping? fxmap))
         (assume (procedure? failure))
         (assume (procedure? success))
         (trie-find pred (fxmapping-trie fxmap) failure success))))
    
    (define (fxmapping-count pred fxmap)
      (assume (procedure? pred))
      (fxmapping-fold (lambda (k v acc)
                        (if (pred k v) (+ 1 acc) acc))
                      0
                      fxmap))
    
    (define (fxmapping-any? pred fxmap)
      (assume (procedure? pred))
      (call-with-current-continuation
       (lambda (return)
         (fxmapping-fold (lambda (k v _)
                           (and (pred k v) (return #t)))
                         #f
                         fxmap))))
    
    (define (fxmapping-every? pred fxmap)
      (assume (procedure? pred))
      (call-with-current-continuation
       (lambda (return)
         (fxmapping-fold (lambda (k v _)
                           (or (pred k v) (return #f)))
                         #t
                         fxmap))))
    
    ;;;; Mapping and folding
    
    ;; Map proc over the assocs. of fxmap, inserting result values under
    ;; the same key.
    ;; This is *not* the same as SRFI 146's mapping-map.
    (define (fxmapping-map proc fxmap)
      (assume (procedure? proc))
      (assume (fxmapping? fxmap))
      (raw-fxmapping (trie-map proc (fxmapping-trie fxmap))))
    
    (define (unspecified)
      (if #f #f))
    
    (define (fxmapping-for-each proc fxmap)
      (assume (procedure? proc))
      (fxmapping-fold (lambda (k v _)
                        (proc k v)
                        (unspecified))
                      (unspecified)
                      fxmap))
    
    (define (fxmapping-fold proc nil fxmap)
      (assume (procedure? proc))
      (assume (fxmapping? fxmap))
      (let ((trie (fxmapping-trie fxmap)))
        (tmatch trie
          ((branch ? ,m ,l ,r) (guard (negative? m))
           (trie-fold-left proc (trie-fold-left proc nil r) l))
          ((branch ? ? ,l ,r)
           (trie-fold-left proc (trie-fold-left proc nil l) r))
          (else (trie-fold-left proc nil trie)))))
    
    (define (fxmapping-fold-right proc nil fxmap)
      (assume (procedure? proc))
      (assume (fxmapping? fxmap))
      (let ((trie (fxmapping-trie fxmap)))
        (tmatch trie
          ((branch ? ,m ,l ,r) (guard (negative? m))
           (trie-fold-right proc (trie-fold-right proc nil l) r))
          ((branch ? ? ,l ,r)
           (trie-fold-right proc (trie-fold-right proc nil r) l))
          (else (trie-fold-right proc nil trie)))))
    
    (define (fxmapping-map->list proc fxmap)
      (assume (procedure? proc))
      (fxmapping-fold-right (lambda (k v us)
                              (cons (proc k v) us))
                            '()
                            fxmap))
    
    (define (fxmapping-filter pred fxmap)
      (assume (procedure? pred))
      (assume (fxmapping? fxmap))
      (raw-fxmapping (trie-filter pred (fxmapping-trie fxmap))))
    
    (define (fxmapping-remove pred fxmap)
      (fxmapping-filter (lambda (k v) (not (pred k v))) fxmap))
    
    (define (fxmapping-partition pred fxmap)
      (assume (procedure? pred))
      (assume (fxmapping? fxmap))
      (let-values (((tin tout)
                    (trie-partition pred (fxmapping-trie fxmap))))
        (values (raw-fxmapping tin) (raw-fxmapping tout))))
    
    ;;;; Conversion
    
    (define (fxmapping->alist fxmap)
      (fxmapping-fold-right (lambda (k v as) (cons (cons k v) as))
                            '()
                            fxmap))
    
    (define (fxmapping->decreasing-alist fxmap)
      (fxmapping-fold (lambda (k v as) (cons (cons k v) as))
                      '()
                      fxmap))
    
    (define (fxmapping-keys fxmap)
      (fxmapping-fold-right (lambda (k _ ks) (cons k ks)) '() fxmap))
    
    (define (fxmapping-values fxmap)
      (fxmapping-fold-right (lambda (_ v vs) (cons v vs)) '() fxmap))
    
    (define (fxmapping->generator fxmap)
      (assume (fxmapping? fxmap))
      (make-coroutine-generator
       (lambda (yield)
         (fxmapping-fold (lambda (k v _) (yield (cons k v)))
                         #f
                         fxmap))))
    
    (define (fxmapping->decreasing-generator fxmap)
      (assume (fxmapping? fxmap))
      (make-coroutine-generator
       (lambda (yield)
         (fxmapping-fold-right (lambda (k v _) (yield (cons k v)))
                               #f
                               fxmap))))
    
    ;;;; Comparison
    
    (define (fxmapping=? comp fxmap1 fxmap2 . imaps)
      (assume (comparator? comp))
      (assume (fxmapping? fxmap1))
      (let ((fxmap-eq1 (lambda (fxmap)
                         (assume (fxmapping? fxmap))
                         (or (eqv? fxmap1 fxmap)
                             (trie=? comp
                                     (fxmapping-trie fxmap1)
                                     (fxmapping-trie fxmap))))))
        (and (fxmap-eq1 fxmap2)
             (or (null? imaps)
                 (every fxmap-eq1 imaps)))))
    
    (define (fxmapping<? comp fxmap1 fxmap2 . imaps)
      (assume (comparator? comp))
      (assume (fxmapping? fxmap1))
      (assume (fxmapping? fxmap2))
      (let lp ((t1 (fxmapping-trie fxmap1))
               (t2 (fxmapping-trie fxmap2))
               (imaps imaps))
        (and (trie-proper-subset? comp t1 t2)
             (pmatch imaps
               (() #t)
               ((,m . ,imaps*) (lp t2 (fxmapping-trie m) imaps*))))))
    
    (define (fxmapping>? comp fxmap1 fxmap2 . imaps)
      (assume (comparator? comp))
      (assume (fxmapping? fxmap1))
      (assume (fxmapping? fxmap2))
      (let lp ((t1 (fxmapping-trie fxmap1))
               (t2 (fxmapping-trie fxmap2))
               (imaps imaps))
        (and (trie-proper-subset? comp t2 t1)
             (pmatch imaps
               (() #t)
               ((,m . ,imaps*) (lp t2 (fxmapping-trie m) imaps*))))))
    
    (define (fxmapping<=? comp fxmap1 fxmap2 . imaps)
      (assume (comparator? comp))
      (assume (fxmapping? fxmap1))
      (assume (fxmapping? fxmap2))
      (let lp ((t1 (fxmapping-trie fxmap1))
               (t2 (fxmapping-trie fxmap2))
               (imaps imaps))
        (and (memv (trie-subset-compare comp t1 t2) '(less equal))
             (pmatch imaps
               (() #t)
               ((,m . ,imaps*) (lp t2 (fxmapping-trie m) imaps*))))))
    
    (define (fxmapping>=? comp fxmap1 fxmap2 . imaps)
      (assume (comparator? comp))
      (assume (fxmapping? fxmap1))
      (assume (fxmapping? fxmap2))
      (let lp ((t1 (fxmapping-trie fxmap1))
               (t2 (fxmapping-trie fxmap2))
               (imaps imaps))
        (and (memv (trie-subset-compare comp t2 t1) '(less equal))
             (pmatch imaps
               (() #t)
               ((,m . ,imaps*) (lp t2 (fxmapping-trie m) imaps*))))))
    
    ;;;; Set theory operations
    
    (define (fxmapping-union . args)
      (apply fxmapping-union/combinator first-arg args))
    
    (define (fxmapping-intersection . args)
      (apply fxmapping-intersection/combinator first-arg args))
    
    (define fxmapping-difference
      (case-lambda
        ((fxmap1 fxmap2)
         (assume (fxmapping? fxmap1))
         (assume (fxmapping? fxmap2))
         (raw-fxmapping
          (trie-difference (fxmapping-trie fxmap1)
                           (fxmapping-trie fxmap2))))
        ((fxmap . rest)
         (assume (fxmapping? fxmap))
         (assume (pair? rest))
         (raw-fxmapping
          (trie-difference (fxmapping-trie fxmap)
                           (fxmapping-trie
                            (apply fxmapping-union rest)))))))
    
    (define (fxmapping-xor fxmap1 fxmap2)
      (assume (fxmapping? fxmap1))
      (assume (fxmapping? fxmap2))
      (raw-fxmapping
       (trie-xor (fxmapping-trie fxmap1) (fxmapping-trie fxmap2))))
    
    (define (fxmapping-union/combinator proc fxmap . rest)
      (assume (procedure? proc))
      (assume (fxmapping? fxmap))
      (assume (pair? rest))
      (raw-fxmapping
       (fold (lambda (im t)
               (assume (fxmapping? im))
               (trie-merge proc t (fxmapping-trie im)))
             (fxmapping-trie fxmap)
             rest)))
    
    (define (fxmapping-intersection/combinator proc fxmap . rest)
      (assume (procedure? proc))
      (assume (fxmapping? fxmap))
      (assume (pair? rest))
      (raw-fxmapping
       (fold (lambda (im t)
               (assume (fxmapping? im))
               (trie-intersection proc t (fxmapping-trie im)))
             (fxmapping-trie fxmap)
             rest)))
    
    ;;;; Subsets
    
    (define (fxsubmapping= fxmap key)
      (fxmapping-ref fxmap
                     key
                     fxmapping
                     (lambda (v) (fxmapping key v))))
    
    (define (fxmapping-open-interval fxmap low high)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-fxmapping
       (subtrie-interval (fxmapping-trie fxmap) low high #f #f)))
    
    (define (fxmapping-closed-interval fxmap low high)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-fxmapping
       (subtrie-interval (fxmapping-trie fxmap) low high #t #t)))
    
    (define (fxmapping-open-closed-interval fxmap low high)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-fxmapping
       (subtrie-interval (fxmapping-trie fxmap) low high #f #t)))
    
    (define (fxmapping-closed-open-interval fxmap low high)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? low))
      (assume (valid-integer? high))
      (assume (fx>=? high low))
      (raw-fxmapping
       (subtrie-interval (fxmapping-trie fxmap) low high #t #f)))
    
    (define (fxsubmapping< fxmap key)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (raw-fxmapping (subtrie< (fxmapping-trie fxmap) key #f)))
    
    (define (fxsubmapping<= fxmap key)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (raw-fxmapping (subtrie< (fxmapping-trie fxmap) key #t)))
    
    (define (fxsubmapping> fxmap key)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (raw-fxmapping (subtrie> (fxmapping-trie fxmap) key #f)))
    
    (define (fxsubmapping>= fxmap key)
      (assume (fxmapping? fxmap))
      (assume (valid-integer? key))
      (raw-fxmapping (subtrie> (fxmapping-trie fxmap) key #t)))
    
    (define (fxmapping-split fxmap k)
      (assume (fxmapping? fxmap))
      (assume (integer? k))
      (let-values (((trie-low trie-high)
                    (trie-split (fxmapping-trie fxmap) k)))
        (values (raw-fxmapping trie-low) (raw-fxmapping trie-high))))
    
    ;;;; fxmappings as relations
    
    (define (fxmapping-relation-map proc fxmap)
      (assume (procedure? proc))
      (assume (fxmapping? fxmap))
      (raw-fxmapping (trie-relation-map proc (fxmapping-trie fxmap))))
  )
)
;;; SRFI 227
;;; Optional Arguments
;;;
;;; This SRFI specifies the `opt-lambda` syntax, which generalizes `lambda`. An
;;; `opt-lambda` expression evaluates to a procedure that takes a number of
;;; required and a number of optional (positional) arguments whose default values
;;; are determined by evaluating corresponding expressions when the procedure is
;;; called. This SRFI also specifies a variation `opt*-lambda`, which is to
;;; `opt-lambda` as `let*` is to `let` and the related binding constructs
;;; `let-optionals` and `let-optionals*`. Finally, for those who prefer less explicit
;;; procedure definitions, `define-optionals` and `define-optionals*` are provided.
;;; 
;;; Author of spec: Marc Nieper-Wißkirchen
;;; 
;;; Copyright © 2021 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use
;;; this file except in compliance with the License. You may obtain a copy of the
;;; License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed
;;; under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
;;; CONDITIONS OF ANY KIND, either express or implied. See the License for the
;;; specific language governing permissions and limitations under the License.

(define-library (srfi 227)

  (export (rename let*-optionals let-optionals*)
          let-optionals
          opt-lambda
          opt*-lambda
          define-optionals
          define-optionals*)
  
  (import (lispkit base))
)
;;; SRFI 229
;;; Tagged Procedures
;;;
;;; This SRFI defines tagged procedures, which are procedures that are tagged with
;;; a Scheme value when created through the syntax `lambda/tag` and `case-lambda/tag`.
;;; The value of the tag of a procedure can be retrieved with `procedure-tag`, and
;;; the predicate `procedure/tag?` discerns whether a procedure is tagged.
;;;
;;; Author of spec: Marc Nieper-Wißkirchen
;;; 
;;; Copyright © 2021 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 229)

  (export case-lambda/tag
          lambda/tag
          procedure/tag?
          procedure-tag)
  
  (import (lispkit base))
)
;;; SRFI 23
;;; Error reporting mechanism
;;;
;;; The SRFI introduces a mechanism which allows Scheme code to report errors and abort
;;; the execution.
;;;
;;; Author of spec: Stephan Houben
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 23)

  (export error)

  (import (lispkit dynamic))

  ;; `error` is implemented natively in library `(lispkit dynamic)`
)
;; Copyright (C) Marc Nieper-Wißkirchen (2021).  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-library (srfi 230)
  
  (export memory-order
          memory-order?
          make-atomic-flag
          atomic-flag?
          atomic-flag-test-and-set!
          atomic-flag-clear!
          make-atomic-box
          atomic-box?
          atomic-box-ref
          atomic-box-set!
          atomic-box-swap!
          atomic-box-compare-and-swap!
          make-atomic-fxbox
          atomic-fxbox?
          atomic-fxbox-ref
          atomic-fxbox-set!
          atomic-fxbox-swap!
          atomic-fxbox-compare-and-swap!
          atomic-fxbox+/fetch!
          atomic-fxbox-/fetch!
          atomic-fxbox-and/fetch!
          atomic-fxbox-ior/fetch!
          atomic-fxbox-xor/fetch!
          make-atomic-pair
          atomic-pair?
          atomic-pair-ref
          atomic-pair-set!
          atomic-pair-swap!
          atomic-pair-compare-and-swap!
          atomic-fence)
  
  (import (lispkit base)
          (lispkit thread))
  
  (begin
    
    ;; Internals
    
    (define lock (make-mutex))
    
    (define-syntax lock-guard
      (syntax-rules ()
        ((lock-guard . body)
          (dynamic-wind
            (lambda ()
              (guard
                (c ((abandoned-mutex-exception? c) #f))
                (mutex-lock! lock)))
            (lambda () . body)
            (lambda () (mutex-unlock! lock))))))
    
    ;; Memory orders
    
    (define-syntax memory-order
      (syntax-rules ()
        ((memory-order symbol) 'symbol)))
    
    (define (memory-order? obj)
      (and (memq obj '(relaxed
                       acquire
                       release
                       acquire-release
                       sequentially-consistent)) #t))
    
    ;; Atomic flags
    
    (define-record-type atomic-flag
      (%make-atomic-flag content)
      atomic-flag?
      (content atomic-flag-content atomic-flag-set-content!))
    
    (define (make-atomic-flag)
      (%make-atomic-flag #f))
    
    (define (atomic-flag-test-and-set! flag . o)
      (lock-guard
        (let ((prev (atomic-flag-content flag)))
          (atomic-flag-set-content! flag #t)
          prev)))
    
    (define (atomic-flag-clear! flag . o)
      (lock-guard
        (atomic-flag-set-content! flag #f)))
    
    ;; Atomic boxes
    
    (define-record-type atomic-box
      (make-atomic-box content)
      atomic-box?
      (content atomic-box-content atomic-box-set-content!))
    
    (define (atomic-box-ref box . o)
      (lock-guard
        (atomic-box-content box)))
    
    (define (atomic-box-set! box obj . o)
      (lock-guard
        (atomic-box-set-content! box obj)))
    
    (define (atomic-box-swap! box obj . o)
      (lock-guard
        (let ((prev (atomic-box-content box)))
          (atomic-box-set-content! box obj)
          prev)))
    
    (define (atomic-box-compare-and-swap! box expected desired . o)
      (lock-guard
        (let ((actual (atomic-box-content box)))
          (when (eq? expected actual)
            (atomic-box-set-content! box desired))
          actual)))
    
    ;; Atomic fixnum boxes
    
    (define-record-type atomic-fxbox
      (make-atomic-fxbox content)
      atomic-fxbox?
      (content atomic-fxbox-content atomic-fxbox-set-content!))
    
    (define (atomic-fxbox-ref box . o)
      (lock-guard
        (atomic-fxbox-content box)))
    
    (define (atomic-fxbox-set! box obj . o)
      (lock-guard
        (atomic-fxbox-set-content! box obj)))
    
    (define (atomic-fxbox-swap! box obj . o)
      (lock-guard
        (let ((prev (atomic-fxbox-content box)))
          (atomic-fxbox-set-content! box obj)
          prev)))
    
    (define (atomic-fxbox-compare-and-swap! box expected desired . o)
      (lock-guard
        (let ((actual (atomic-fxbox-content box)))
          (when (fx= expected actual)
            (atomic-fxbox-set-content! box desired))
          actual)))
    
    (define (atomic-fxbox+/fetch! box n . o)
      (lock-guard
        (let ((prev (atomic-fxbox-content box)))
          (atomic-fxbox-set-content! box (fx+ n prev))
          prev)))
    
    (define (atomic-fxbox-/fetch! box n . o)
      (lock-guard
        (let ((prev (atomic-fxbox-content box)))
          (atomic-fxbox-set-content! box (fx- n prev))
          prev)))
    
    (define (atomic-fxbox-and/fetch! box n . o)
      (lock-guard
        (let ((prev (atomic-fxbox-content box)))
          (atomic-fxbox-set-content! box (fxand n prev))
          prev)))
    
    (define (atomic-fxbox-ior/fetch! box n . o)
      (lock-guard
        (let ((prev (atomic-fxbox-content box)))
          (atomic-fxbox-set-content! box (fxior n prev))
          prev)))
    
    (define (atomic-fxbox-xor/fetch! box n . o)
      (lock-guard
        (let ((prev (atomic-fxbox-content box)))
          (atomic-fxbox-set-content! box (fxxor n prev))
          prev)))
    
    ;; Atomic pairs
    
    (define-record-type atomic-pair
      (make-atomic-pair car cdr)
      atomic-pair?
      (car atomic-pair-car atomic-pair-set-car!)
      (cdr atomic-pair-cdr atomic-pair-set-cdr!))
    
    (define (atomic-pair-ref pair . o)
      (lock-guard
        (values
          (atomic-pair-car pair)
          (atomic-pair-cdr pair))))
    
    (define (atomic-pair-set! pair car cdr . o)
      (lock-guard
        (atomic-pair-set-car! pair car)
        (atomic-pair-set-cdr! pair cdr)))
    
    (define (atomic-pair-swap! pair car cdr . o)
      (lock-guard
        (let ((prev-car (atomic-pair-car pair))
              (prev-cdr (atomic-pair-cdr pair)))
          (atomic-pair-set-car! pair car)
          (atomic-pair-set-cdr! pair cdr)
          (values prev-car prev-cdr))))
    
    (define (atomic-pair-compare-and-swap! pair
                                           expected-car expected-cdr
                                           desired-car desired-cdr . o)
      (lock-guard
        (let ((actual-car (atomic-pair-car pair))
              (actual-cdr (atomic-pair-cdr pair)))
          (when (and (eq? expected-car actual-car)
                     (eq? expected-cdr actual-cdr))
            (atomic-pair-set-car! pair desired-car)
            (atomic-pair-set-cdr! pair desired-cdr))
          (values actual-car actual-cdr))))
    
    ;; Memory synchronization
    
    (define (atomic-fence . o)
      (lock-guard (if #f #f)))
  )
)
;;; SRFI 232
;;; Flexible curried procedures
;;;
;;; Scheme lacks a flexible way to create and apply curried procedures. This
;;; SRFI describes `curried`, a variant of lambda that creates true curried
;;; procedures which also behave just like ordinary Scheme procedures. They
;;; can be applied to their arguments one by one, all at once, or anywhere
;;; in between, without any novel syntax. `curried` also supports nullary and
;;; variadic procedures, and procedures created with it have predictable
;;; behavior when applied to surplus arguments.
;;; 
;;; Copyright © 2022 Wolfgang Corcoran-Mathe. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;; 
;;; The above copyright notice and this permission notice shall be included in all
;;; copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;;; FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
;;; COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
;;; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;;; 
;;; Adaptation to LispKit
;;;   Copyright © 2022 Matthias Zenger. All rights reserved.

(define-library (srfi 232)
  
  (export curried
          define-curried)
  
  (import (lispkit base))
  
  (begin
    
    (define (more-args f current)
      (lambda args (apply f (append current args))))
    
    (define-syntax one-or-more
      (syntax-rules ()
        ((one-or-more (arg0 arg1 ...) exp)
          (letrec
            ((f (case-lambda
                  (() f)
                  ((arg0 arg1 ...) exp)
                  ((arg0 arg1 ... . rest) (apply (f arg0 arg1 ...) rest))
                  (args (more-args f args)))))
            f))))
    
    (define-syntax rest-args
      (syntax-rules ()
        ((rest-args (arg0 arg1 ... . rest) exp)
          (letrec ((f (case-lambda
                        (() f)
                        ((arg0 arg1 ... . rest) exp)
                        (args (more-args f args)))))
            f))))
    
    (define-syntax curried-1
      (syntax-rules ()
        ((curried-1 () exp) exp)
        ((curried-1 (arg0 arg1 ...) exp)
          (one-or-more (arg0 arg1 ...) exp))
        ((curried-1 (arg0 arg1 ... . rest) exp)
          (rest-args (arg0 arg1 ... . rest) exp))
        ((curried-1 args exp)
          (lambda args exp))))
    
    (define-syntax curried
      (syntax-rules ()
        ((curried formals exp ...)
          (curried-1 formals (begin exp ...)))))
    
    (define-syntax define-curried
      (syntax-rules ()
        ((define-curried (var . formals) exp ...)
          (define var
            (curried formals exp ...)))))
  )
)
;;; SRFI 26
;;; Notation for Specializing Parameters without Currying
;;;
;;; When programming in functional style, it is frequently necessary to specialize some
;;; of the parameters of a multi-parameter procedure. For example, from the binary
;;; operation cons one might want to obtain the unary operation `(lambda (x) (cons 1 x))`.
;;; This specialization of parameters is also known as "partial application",
;;; "operator section" or "projection".
;;;
;;; The mechanism proposed here allows to write this sort of specialization in a simple
;;; and compact way. The mechanism is best explained by a few examples:
;;;
;;; ```
;;; (cut cons (+ a 1) <>)	is the same as	(lambda (x2) (cons (+ a 1) x2))
;;; (cut list 1 <> 3 <> 5)	is the same as	(lambda (x2 x4) (list 1 x2 3 x4 5))
;;; (cut list)	is the same as	(lambda () (list))
;;; (cut list 1 <> 3 <...>)	is the same as	(lambda (x2 . xs) (apply list 1 x2 3 xs))
;;; (cut <> a b)	is the same as	(lambda (f) (f a b))
;;; ```
;;;
;;; As you see, the macro cut specializes some of the parameters of its first argument.
;;; The parameters that are to show up as formal variables of the result are indicated by
;;; the symbol `<>`, pronouced as "slot". In addition, the symbol `<...>`, pronounced as
;;; "rest-slot", matches all residual arguments of a variable argument procedure. As you
;;; can see from the last example above, the first argument can also be a slot, as one
;;; should expect in Scheme.
;;;
;;; In addition to `cut`, there is a variant called `cute` (a mnemonic for "cut with
;;; evaluated non-slots") which evaluates the non-slot expressions at the time the procedure
;;; is specialized, not at the time the specialized procedure is called. For example,
;;; `(cute cons (+ a 1) <>)`	is the same as	`(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))`.
;;;
;;; As you see from comparing this example with the first example above, the cute-variant
;;; will evaluate `(+ a 1)` once, while the cut-variant will evaluate it during every
;;; invokation of the resulting procedure.
;;;
;;; The mechanism proposed in this SRFI allows specializing any subset of the variables of
;;; a procedure. The result can be of fixed arity or of variable arity. The mechanism does
;;; not allow permutation, omission, duplication or any other processing of the arguments;
;;; for this it is necessary to write to use a different mechanism such as lambda.
;;;
;;; Portions of this code: SRFI 26 reference implementation
;;;   Copyright © 2002 by Sebastian Egner (Sebastian.Egner@philips.com)
;;;   Adapted from a posting by Al Petrofsky <al@petrofsky.org>
;;;   Placed in the public domain
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2019 Matthias Zenger. All rights reserved.

(define-library (srfi 26)

  (export cut
          cute)

  (import (lispkit base))

  (begin

    ;; implements both internal %cut and %cute (based on first argument)
    (define-syntax %cut
      (syntax-rules (<> <...>)
        ((_ e? params args)
          (lambda params args))
        ((_ e? (params ...) (args ...) <> . rest)
          (%cut e? (params ... tmp) (args ... tmp) . rest))
        ((_ e? (params ...) (args ...) <...>)
          (%cut e? (params ... . tmp) (apply args ... tmp)))
        ((_ e? (params ...) (args ...) <...> . rest)
          (error "non-terminal <...> in cut"))
        ((_ #t (params ...) (args ...) x . rest)
          (let ((tmp x))
            (%cut #t (params ...) (args ... tmp) . rest)))
        ((_ #f (params ...) (args ...) x . rest)
          (%cut #f (params ...) (args ... x) . rest))))

    (define-syntax cut
      (syntax-rules ()
        ((_ args ...)
          (%cut #f () () args ...))))

    (define-syntax cute
      (syntax-rules ()
        ((_ args ...)
          (%cut #t () () args ...))))
  )
)

;;; SRFI 27
;;; Sources of random bits
;;;
;;; This SRFI defines an interface for sources of random bits computed by a pseudo random
;;; number generator. The interface provides range-limited integer and real numbers. It
;;; allows accessing the state of the underlying generator. Moreover, it is possible to
;;; obtain a large number of independent generators and to invoke a mild form of true
;;; randomization.
;;;
;;; The design aims at sufficient flexibility to cover the usage patterns of many applications
;;; as diverse as discrete structures, numerical simulations, and cryptographic protocols.
;;; At the same time, the interface aims at simplicity, which is important for occasional
;;; use. As there is no "one size fits all" random number generator, the design necessarily
;;; represents some form of compromise between the needs of the various applications.
;;; 
;;; Author: Sebastian.Egner@philips.com, Mar-2002, in Scheme 48 0.57
;;; Copyright © 2002 Sebastian Egner. All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 27)
  
  (export random-integer
          random-real
          default-random-source
          make-random-source
          random-source?
          random-source-state-ref
          random-source-state-set!
          random-source-randomize!
          random-source-pseudo-randomize!
          random-source-make-integers
          random-source-make-reals)
  
  (import (lispkit base))


  ; Record Data Type
  ; ==========================
  ;
  ; At this point in the code, the following procedures are assumed
  ; to be defined to create and access a new record data type:
  ;
  ;   (:random-source-make a0 a1 a2 a3 a4 a5) -> s
  ;     constructs a new random source object s consisting of the
  ;     objects a0 .. a5 in this order.
  ;
  ;   (:random-source? obj) -> bool
  ;     tests if a Scheme object is a :random-source.
  ;
  ;   (:random-source-state-ref         s) -> a0
  ;   (:random-source-state-set!        s) -> a1
  ;   (:random-source-randomize!        s) -> a2
  ;   (:random-source-pseudo-randomize! s) -> a3
  ;   (:random-source-make-integers     s) -> a4
  ;   (:random-source-make-reals        s) -> a5
  ;     retrieve the values in the fields of the object s.
  ;
  ; Current Time as an Integer
  ; ====================================
  ;
  ; At this point in the code, the following procedure is assumed
  ; to be defined to obtain a value that is likely to be different
  ; for each invokation of the Scheme system:
  ;
  ;   (:random-source-current-time) -> x
  ;     an integer that depends on the system clock. It is desired
  ;     that the integer changes as fast as possible.

  (begin
    (define-record-type <random-source>
      (:random-source-make state-ref
                           state-set!
                           randomize!
                           pseudo-randomize!
                           make-integers
                           make-reals)
      :random-source?
      (state-ref         :random-source-state-ref)
      (state-set!        :random-source-state-set!)
      (randomize!        :random-source-randomize!)
      (pseudo-randomize! :random-source-pseudo-randomize!)
      (make-integers     :random-source-make-integers)
      (make-reals        :random-source-make-reals))

    (define (:random-source-current-time)
      (exact (truncate (current-second)))))

  ; Backbone Generator
  ; ============================
  ;
  ; At this point in the code, the following procedures are assumed
  ; to be defined to execute the core generator:
  ;
  ;   (mrg32k3a-pack-state unpacked-state) -> packed-state
  ;   (mrg32k3a-unpack-state packed-state) -> unpacked-state
  ;      pack/unpack a state of the generator. The core generator works
  ;      on packed states, passed as an explicit argument, only. This
  ;      allows native code implementations to store their state in a
  ;      suitable form. Unpacked states are #(x10 x11 x12 x20 x21 x22)
  ;      with integer x_ij. Pack/unpack need not allocate new objects
  ;      in case packed and unpacked states are identical.
  ;
  ;   (mrg32k3a-random-range) -> m-max
  ;   (mrg32k3a-random-integer packed-state range) -> x in {0..range-1}
  ;      advance the state of the generator and return the next random
  ;      range-limited integer.
  ;        Note that the state is not necessarily advanced by just one
  ;      step because we use the rejection method to avoid any problems
  ;      with distribution anomalies.
  ;        The range argument must be an exact integer in {1..m-max}.
  ;      It can be assumed that range is a fixnum if the Scheme system
  ;      has such a number representation.
  ;
  ;   (mrg32k3a-random-real packed-state) -> x in (0,1)
  ;      advance the state of the generator and return the next random
  ;      real number between zero and one (both excluded). The type of
  ;      the result should be a flonum if possible.

  (begin
    ; 54-BIT INTEGER IMPLEMENTATION OF THE "MRG32K3A"-GENERATOR
    ; =========================================================
    ;
    ; Sebastian.Egner@philips.com, Mar-2002.
    ;
    ; This file is an implementation of Pierre L'Ecuyer's MRG32k3a
    ; pseudo random number generator. Please refer to 'mrg32k3a.scm'
    ; for more information.
    ; 
    ; compliance:
    ;   Scheme R5RS with integers covering at least {-2^53..2^53-1}.
    ;
    ; history of this file:
    ;   SE, 18-Mar-2002: initial version
    ;   SE, 22-Mar-2002: comments adjusted, range added
    ;   SE, 25-Mar-2002: pack/unpack just return their argument

    ; the actual generator

    (define (mrg32k3a-random-m1 state)
      (let ((x11 (vector-ref state 0))
            (x12 (vector-ref state 1))
            (x13 (vector-ref state 2))
            (x21 (vector-ref state 3))
            (x22 (vector-ref state 4))
            (x23 (vector-ref state 5)))
        (let ((x10 (modulo (- (* 1403580 x12) (* 810728 x13)) 4294967087))
              (x20 (modulo (- (* 527612 x21) (* 1370589 x23)) 4294944443)))
          (vector-set! state 0 x10)
          (vector-set! state 1 x11)
          (vector-set! state 2 x12)
          (vector-set! state 3 x20)
          (vector-set! state 4 x21)
          (vector-set! state 5 x22)
          (modulo (- x10 x20) 4294967087))))

    ; interface to the generic parts of the generator

    (define (mrg32k3a-pack-state unpacked-state) unpacked-state)

    (define (mrg32k3a-unpack-state state) state)

    (define (mrg32k3a-random-range) 4294967087)

    (define (mrg32k3a-random-integer state range) ; rejection method
      (let* ((q (quotient 4294967087 range))
             (qn (* q range)))
        (do ((x (mrg32k3a-random-m1 state) (mrg32k3a-random-m1 state)))
            ((< x qn) (quotient x q)))))

    (define (mrg32k3a-random-real state) ; normalization is 1/(m1+1)
      (* 0.0000000002328306549295728 (+ 1.0 (mrg32k3a-random-m1 state)))))
  
  (begin
    ; GENERIC PART OF MRG32k3a-GENERATOR FOR SRFI-27
    ; ==============================================
    ;
    ; Sebastian.Egner@philips.com, 2002.
    ;
    ; This is the generic R5RS-part of the implementation of the MRG32k3a
    ; generator to be used in SRFI-27. It is based on a separate implementation
    ; of the core generator (presumably in native code) and on code to
    ; provide essential functionality not available in R5RS (see below).
    ;
    ; compliance:
    ;   Scheme R5RS with integer covering at least {-2^53..2^53-1}.
    ;   In addition,
    ;     SRFI-23: error
    ;
    ; history of this file:
    ;   SE, 22-Mar-2002: refactored from earlier versions
    ;   SE, 25-Mar-2002: pack/unpack need not allocate
    ;   SE, 27-Mar-2002: changed interface to core generator
    ;   SE, 10-Apr-2002: updated spec of mrg32k3a-random-integer

    ; Generator
    ; =========
    ;
    ; Pierre L'Ecuyer's MRG32k3a generator is a Combined Multiple Recursive 
    ; Generator. It produces the sequence {(x[1,n] - x[2,n]) mod m1 : n} 
    ; defined by the two recursive generators
    ;
    ;   x[1,n] = (               a12 x[1,n-2] + a13 x[1,n-3]) mod m1,
    ;   x[2,n] = (a21 x[2,n-1] +                a23 x[2,n-3]) mod m2,
    ;
    ; where the constants are
    ;   m1       = 4294967087 = 2^32 - 209    modulus of 1st component
    ;   m2       = 4294944443 = 2^32 - 22853  modulus of 2nd component
    ;   a12      =  1403580                   recursion coefficients
    ;   a13      =  -810728
    ;   a21      =   527612
    ;   a23      = -1370589
    ;
    ; The generator passes all tests of G. Marsaglia's Diehard testsuite.
    ; Its period is (m1^3 - 1)(m2^3 - 1)/2 which is nearly 2^191.
    ; L'Ecuyer reports: "This generator is well-behaved in all dimensions
    ; up to at least 45: ..." [with respect to the spectral test, SE].
    ;
    ; The period is maximal for all values of the seed as long as the
    ; state of both recursive generators is not entirely zero.
    ;
    ; As the successor state is a linear combination of previous
    ; states, it is possible to advance the generator by more than one
    ; iteration by applying a linear transformation. The following
    ; publication provides detailed information on how to do that:
    ;
    ;    [1] P. L'Ecuyer, R. Simard, E. J. Chen, W. D. Kelton:
    ;        An Object-Oriented Random-Number Package With Many Long 
    ;        Streams and Substreams. 2001.
    ;        To appear in Operations Research.
    ;
    ; Arithmetics
    ; ===========
    ;
    ; The MRG32k3a generator produces values in {0..2^32-209-1}. All 
    ; subexpressions of the actual generator fit into {-2^53..2^53-1}. 
    ; The code below assumes that Scheme's "integer" covers this range.
    ; In addition, it is assumed that floating point literals can be
    ; read and there is some arithmetics with inexact numbers.
    ;
    ; However, for advancing the state of the generator by more than
    ; one step at a time, the full range {0..2^32-209-1} is needed.

    ; Accessing the State
    ; ===================

    (define (mrg32k3a-state-ref packed-state)
      (cons 'lecuyer-mrg32k3a 
            (vector->list (mrg32k3a-unpack-state packed-state))))

    (define (mrg32k3a-state-set external-state)

      (define (check-value x m)
        (if (and (integer? x)
                 (exact? x)
                 (<= 0 x (- m 1)))
            #t
            (error "illegal value" x)))

      (if (and (list? external-state)
               (= (length external-state) 7)
               (eq? (car external-state) 'lecuyer-mrg32k3a))
          (let ((s (cdr external-state)))
            (check-value (list-ref s 0) mrg32k3a-m1)
            (check-value (list-ref s 1) mrg32k3a-m1)
            (check-value (list-ref s 2) mrg32k3a-m1)
            (check-value (list-ref s 3) mrg32k3a-m2)
            (check-value (list-ref s 4) mrg32k3a-m2)
            (check-value (list-ref s 5) mrg32k3a-m2)
            (if (or (zero? (+ (list-ref s 0) (list-ref s 1) (list-ref s 2)))
                    (zero? (+ (list-ref s 3) (list-ref s 4) (list-ref s 5))))
                (error "illegal degenerate state" external-state))
            (mrg32k3a-pack-state (list->vector s)))
          (error "malformed state" external-state)))


    ; Pseudo-Randomization
    ; ====================
    ;
    ; Reference [1] above shows how to obtain many long streams and 
    ; substream from the backbone generator.
    ;
    ; The idea is that the generator is a linear operation on the state.
    ; Hence, we can express this operation as a 3x3-matrix acting on the
    ; three most recent states. Raising the matrix to the k-th power, we
    ; obtain the operation to advance the state by k steps at once. The
    ; virtual streams and substreams are now simply parts of the entire
    ; periodic sequence (which has period around 2^191).
    ;
    ; For the implementation it is necessary to compute with matrices in
    ; the ring (Z/(m1*m1)*Z)^(3x3). By the Chinese-Remainder Theorem, this
    ; is isomorphic to ((Z/m1*Z) x (Z/m2*Z))^(3x3). We represent such a pair
    ; of matrices 
    ;   [ [[x00 x01 x02],
    ;      [x10 x11 x12],
    ;      [x20 x21 x22]], mod m1
    ;     [[y00 y01 y02],
    ;      [y10 y11 y12],
    ;      [y20 y21 y22]]  mod m2]
    ; as a vector of length 18 of the integers as writen above:
    ;   #(x00 x01 x02 x10 x11 x12 x20 x21 x22
    ;     y00 y01 y02 y10 y11 y12 y20 y21 y22)
    ;
    ; As the implementation should only use the range {-2^53..2^53-1}, the
    ; fundamental operation (x*y) mod m, where x, y, m are nearly 2^32, 
    ; is computed by breaking up x and y as x = x1*w + x0 and y = y1*w + y0 
    ; where w = 2^16. In this case, all operations fit the range because 
    ; w^2 mod m is a small number. If proper multiprecision integers are
    ; available this is not necessary, but pseudo-randomize! is an expected
    ; to be called only occasionally so we do not provide this implementation.

    (define mrg32k3a-m1 4294967087) ; modulus of component 1
    (define mrg32k3a-m2 4294944443) ; modulus of component 2

    (define mrg32k3a-initial-state ; 0 3 6 9 12 15 of A^16, see below
      '#( 1062452522
          2961816100 
           342112271 
          2854655037 
          3321940838 
          3542344109))

    (define mrg32k3a-generators #f) ; computed when needed

    (define (mrg32k3a-pseudo-randomize-state i j)

      (define (product A B)     ; A*B in ((Z/m1*Z) x (Z/m2*Z))^(3x3)
        (let* ((w 65536)        ; wordsize to split {0..2^32-1}
               (w-sqr1 209)     ; w^2 mod m1
               (w-sqr2 22853)   ; w^2 mod m2
               (lc (lambda (i0 i1 i2 j0 j1 j2 m w-sqr) ; linear combination
                     (let ((a0h (quotient (vector-ref A i0) w))
                           (a0l (modulo   (vector-ref A i0) w))
                           (a1h (quotient (vector-ref A i1) w))
                           (a1l (modulo   (vector-ref A i1) w))
                           (a2h (quotient (vector-ref A i2) w))
                           (a2l (modulo   (vector-ref A i2) w))
                           (b0h (quotient (vector-ref B j0) w))
                           (b0l (modulo   (vector-ref B j0) w))
                           (b1h (quotient (vector-ref B j1) w))
                           (b1l (modulo   (vector-ref B j1) w))
                           (b2h (quotient (vector-ref B j2) w))
                           (b2l (modulo   (vector-ref B j2) w)))
                       (modulo
                         (+ (* (+ (* a0h b0h) (* a1h b1h) (* a2h b2h)) w-sqr)
                            (* (+ (* a0h b0l) (* a0l b0h) (* a1h b1l) (* a1l b1h)
                                  (* a2h b2l) (* a2l b2h)) w)
                            (* a0l b0l)
                            (* a1l b1l)
                            (* a2l b2l))
                         m)))))
          (vector
           (lc  0  1  2   0  3  6  mrg32k3a-m1 w-sqr1) ; (A*B)_00 mod m1
           (lc  0  1  2   1  4  7  mrg32k3a-m1 w-sqr1) ; (A*B)_01
           (lc  0  1  2   2  5  8  mrg32k3a-m1 w-sqr1)
           (lc  3  4  5   0  3  6  mrg32k3a-m1 w-sqr1) ; (A*B)_10
           (lc  3  4  5   1  4  7  mrg32k3a-m1 w-sqr1)
           (lc  3  4  5   2  5  8  mrg32k3a-m1 w-sqr1)
           (lc  6  7  8   0  3  6  mrg32k3a-m1 w-sqr1)
           (lc  6  7  8   1  4  7  mrg32k3a-m1 w-sqr1)
           (lc  6  7  8   2  5  8  mrg32k3a-m1 w-sqr1)
           (lc  9 10 11   9 12 15  mrg32k3a-m2 w-sqr2) ; (A*B)_00 mod m2
           (lc  9 10 11  10 13 16  mrg32k3a-m2 w-sqr2)
           (lc  9 10 11  11 14 17  mrg32k3a-m2 w-sqr2)
           (lc 12 13 14   9 12 15  mrg32k3a-m2 w-sqr2)
           (lc 12 13 14  10 13 16  mrg32k3a-m2 w-sqr2)
           (lc 12 13 14  11 14 17  mrg32k3a-m2 w-sqr2)
           (lc 15 16 17   9 12 15  mrg32k3a-m2 w-sqr2)
           (lc 15 16 17  10 13 16  mrg32k3a-m2 w-sqr2)
           (lc 15 16 17  11 14 17  mrg32k3a-m2 w-sqr2))))

      (define (power A e) ; A^e
        (cond ((zero? e) '#(1 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 1))
              ((= e 1)   A)
              ((even? e) (power (product A A) (quotient e 2)))
              (else      (product (power A (- e 1)) A))))

      (define (power-power A b) ; A^(2^b)
        (if (zero? b)
            A
            (power-power (product A A) (- b 1))))

      (define A                        ; the MRG32k3a recursion
        '#(     0 1403580 4294156359
                1       0          0
                0       1          0
           527612       0 4293573854
                1       0          0
                0       1          0))

      ; check arguments
      (if (not (and (integer? i) 
                    (exact? i)
                    (integer? j)
                    (exact? j)))
          (error "i j must be exact integer" i j))

      ; precompute A^(2^127) and A^(2^76) only once

      (if (not mrg32k3a-generators)
          (set! mrg32k3a-generators
                (list (power-power A 127) (power-power A 76) (power A 16))))

      ; compute M = A^(16 + i*2^127 + j*2^76)
      (let ((M (product (list-ref mrg32k3a-generators 2)
                        (product (power (list-ref mrg32k3a-generators 0) (modulo i (expt 2 28)))
                                 (power (list-ref mrg32k3a-generators 1) (modulo j (expt 2 28)))))))
        (mrg32k3a-pack-state
          (vector (vector-ref M 0)
                  (vector-ref M 3)
                  (vector-ref M 6)
                  (vector-ref M 9)
                  (vector-ref M 12)
                  (vector-ref M 15)))))

    ; True Randomization
    ; ==================
    ;
    ; The value obtained from the system time is feed into a very
    ; simple pseudo random number generator. This in turn is used
    ; to obtain numbers to randomize the state of the MRG32k3a
    ; generator, avoiding period degeneration.

    (define (mrg32k3a-randomize-state state)
      ;; G. Marsaglia's simple 16-bit generator with carry
      (let* ((m        65536)
             (x        (modulo (:random-source-current-time) m))
             (random-m (lambda () (let ((y (modulo x m)))
                                    (set! x (+ (* 30903 y) (quotient x m))) y)))
             (random   (lambda (n) (modulo (+ (* (random-m) m) (random-m)) n)))
             (m1       mrg32k3a-m1)
             (m2       mrg32k3a-m2)
             (s        (mrg32k3a-unpack-state state)))
        (mrg32k3a-pack-state
          (vector
            (+ 1 (modulo (+ (vector-ref s 0) (random (- m1 1))) (- m1 1)))
            (modulo (+ (vector-ref s 1) (random m1)) m1)
            (modulo (+ (vector-ref s 2) (random m1)) m1)
            (+ 1 (modulo (+ (vector-ref s 3) (random (- m2 1))) (- m2 1)))
            (modulo (+ (vector-ref s 4) (random m2)) m2)
            (modulo (+ (vector-ref s 5) (random m2)) m2)))))

    ; Large Integers
    ; ==============
    ;
    ; To produce large integer random deviates, for n > m-max, we first 
    ; construct large random numbers in the range {0..m-max^k-1} for some 
    ; k such that m-max^k >= n and then use the rejection method to choose
    ; uniformly from the range {0..n-1}.

    (define mrg32k3a-m-max
      (mrg32k3a-random-range))

    (define (mrg32k3a-random-power state k) ; n = m-max^k, k >= 1
      (if (= k 1)
          (mrg32k3a-random-integer state mrg32k3a-m-max)
          (+ (* (mrg32k3a-random-power state (- k 1)) mrg32k3a-m-max)
             (mrg32k3a-random-integer state mrg32k3a-m-max))))

    (define (mrg32k3a-random-large state n) ; n > m-max
      (do ((k 2 (+ k 1))
           (mk (* mrg32k3a-m-max mrg32k3a-m-max) (* mk mrg32k3a-m-max)))
          ((>= mk n) (let* ((mk-by-n (quotient mk n))
                            (a (* mk-by-n n)))
                       (do ((x (mrg32k3a-random-power state k)
                            (mrg32k3a-random-power state k)))
                           ((< x a) (quotient x mk-by-n)))))))


    ; Multiple Precision Reals
    ; ========================
    ;
    ; To produce multiple precision reals we produce a large integer value
    ; and convert it into a real value. This value is then normalized.
    ; The precision goal is unit <= 1/(m^k + 1), or 1/unit - 1 <= m^k.
    ; If you know more about the floating point number types of the
    ; Scheme system, this can be improved.

    (define (mrg32k3a-random-real-mp state unit)
      (do ((k 1 (+ k 1))
           (u (- (/ 1 unit) 1) (/ u mrg32k3a-m1)))
          ((<= u 1)
           (/ (exact->inexact (+ (mrg32k3a-random-power state k) 1))
              (exact->inexact (+ (expt mrg32k3a-m-max k) 1))))))


    ; Provide the Interface as Specified in the SRFI
    ; ==============================================
    ;
    ; An object of type random-source is a record containing the procedures
    ; as components. The actual state of the generator is stored in the
    ; binding-time environment of make-random-source.

    (define (make-random-source)
      (let ((state (mrg32k3a-pack-state ; make a new copy
                    (list->vector (vector->list mrg32k3a-initial-state)))))
        (:random-source-make
          (lambda () (mrg32k3a-state-ref state))
          (lambda (new-state) (set! state (mrg32k3a-state-set new-state)))
          (lambda () (set! state (mrg32k3a-randomize-state state)))
          (lambda (i j) (set! state (mrg32k3a-pseudo-randomize-state i j)))
          (lambda ()
            (lambda (n)
              (cond ((not (and (integer? n) (exact? n) (positive? n)))
                      (error "range must be exact positive integer" n))
                    ((<= n mrg32k3a-m-max)
                      (mrg32k3a-random-integer state n))
                    (else
                      (mrg32k3a-random-large state n)))))
          (lambda args
            (cond ((null? args)
                    (lambda () (mrg32k3a-random-real state)))
                  ((null? (cdr args))
                    (let ((unit (car args)))
                      (cond ((not (and (real? unit) (< 0 unit 1)))
                              (error "unit must be real in (0,1)" unit))
                            ((<= (- (/ 1 unit) 1) mrg32k3a-m1)
                              (lambda ()
                                (mrg32k3a-random-real state)))
                            (else
                              (lambda ()
                                (mrg32k3a-random-real-mp state unit))))))
                  (else
                    (error "illegal arguments" args)))))))

    (define random-source? :random-source?)

    (define (random-source-state-ref s) ((:random-source-state-ref s)))

    (define (random-source-state-set! s state) ((:random-source-state-set! s) state))

    (define (random-source-randomize! s) ((:random-source-randomize! s)))

    (define (random-source-pseudo-randomize! s i j) ((:random-source-pseudo-randomize! s) i j))

    (define (random-source-make-integers s) ((:random-source-make-integers s)))

    (define (random-source-make-reals s . unit) (apply (:random-source-make-reals s) unit))

    (define default-random-source (make-random-source))

    (define random-integer (random-source-make-integers default-random-source))

    (define random-real (random-source-make-reals default-random-source))))
;;; SRFI 28
;;; Basic format strings
;;;
;;; Many Scheme systems provide access to a function called format. This function takes as
;;; arguments a format string, an ordinary Scheme string containing zero or more escape
;;; sequences, followed zero or more Scheme values. The procedure processes the format
;;; string and performs string replacement on the escape sequences according to the rules
;;; for each code. This SRFI defines a basic version of format which should allow portable
;;; code to be written using the function without much (if any) effort on the part of
;;; Scheme implementors.
;;;
;;; Copyright © 2002 Scott G. Miller. All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 28)

  (export format)
  
  (import (lispkit base))

  (begin
    (define (format formatstr . objects)
      (let ((buffer (open-output-string)))
        (let loop ((formatlst (string->list formatstr))
                   (objects objects))
          (cond ((null? formatlst)
                  (get-output-string buffer))
                ((char=? (car formatlst) #\~)
                  (if (null? (cdr formatlst))
                      (error "format: incomplete escape sequence")
                      (case (cadr formatlst)
                        ((#\a)
                          (if (null? objects)
                              (error "format: no value for escape sequence")
                              (begin (display (car objects) buffer)
                                     (loop (cddr formatlst) (cdr objects)))))
                        ((#\s)
                          (if (null? objects)
                              (error "format: no value for escape sequence")
                              (begin (write (car objects) buffer)
                                     (loop (cddr formatlst) (cdr objects)))))
                        ((#\%)
                          (newline buffer)
                          (loop (cddr formatlst) objects))
                        ((#\~)
                          (write-char #\~ buffer)
                          (loop (cddr formatlst) objects))
                        (else
                          (error "format: unrecognized escape sequence" (cadr formatlst))))))
                (else
                  (write-char (car formatlst) buffer)
                  (loop (cdr formatlst) objects))))))))
;;; SRFI 31
;;; A special form rec for recursive evaluation.
;;;
;;; This SRFI implements a special form called `rec`. This form is a generalization and
;;; combination of the forms `rec` and `named-lambda` of [Clinger1985]. It allows the
;;; simple and non-imperative construction of self-referential expressions. As an important
;;; special case, it extends the A. Church form lambda such that it allows the direct
;;; definition of recursive procedures without using further special forms like `let` or
;;; `letrec`, without using advanced constructions like the H. B. Curry combinator and,
;;; unlike `define`, without introducing variable bindings into the external environment.
;;; 
;;; Author of spec: Mirko Luedde (mirko.luedde@sap.com)
;;; 
;;; Copyright © 2017 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 31)
  (export rec)
  (import (lispkit base))
  
  (begin
    (define-syntax rec
      (syntax-rules ()
        ((rec (name . args) body ...)
          (letrec ((name (lambda args body ...))) name))
        ((rec name expr)
          (letrec ((name expr)) name)))))
)
;;; SRFI 33
;;; Integer Bitwise-operation Library
;;;
;;; R5RS Scheme has no utilities for performing bitwise logical operations on integers
;;; or bitstrings, which is a problem for authors of portable code. This SRFI proposes
;;; a coherent and comprehensive set of these functions. The precise semantics of these
;;; operators is almost never an issue. A consistent, portable set of *names* and
;;; parameter conventions, however, is. Hence this SRFI.
;;;
;;; Author of spec: Olin Shivers
;;;
;;; Copyright © 2019 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 33)

  (export bitwise-not
          bitwise-and
          bitwise-ior
          bitwise-xor
          bitwise-eqv
          bitwise-nand
          bitwise-nor
          bitwise-andc1
          bitwise-andc2
          bitwise-orc1
          bitwise-orc2
          arithmetic-shift
          bit-count
          integer-length
          bitwise-merge
          bit-set?
          any-bits-set?
          all-bits-set?
          first-set-bit
          extract-bit-field
          test-bit-field?
          clear-bit-field
          replace-bit-field
          copy-bit-field)

  (import (except (lispkit base) integer-length
                                 bit-set?
                                 bitwise-not
                                 bitwise-and
                                 bitwise-ior
                                 bitwise-xor
                                 copy-bit
                                 bit-count
                                 arithmetic-shift)

          (rename (srfi 142) (bitwise-if bitwise-merge)
                             (any-bit-set? any-bits-set?)
                             (every-bit-set? all-bits-set?)
                             (bit-field-any? test-bit-field?)
                             (bit-field-clear clear-bit-field)))

  (begin

    (define (mask len)
      (- (arithmetic-shift 1 len) 1))

    (define (extract-bit-field size position n)
      (bitwise-and (arithmetic-shift n (- position)) (mask size)))

    (define (replace-bit-field size position newfield n)
      (bitwise-ior (bitwise-and n (bitwise-not (arithmetic-shift (mask size) position)))
                   (arithmetic-shift newfield position)))

    (define (copy-bit-field size position from to)
      (bitwise-merge (arithmetic-shift (mask size) position) to from))
  )
)

;;; SRFI 34
;;; Exception Handling for Programs
;;;
;;; This SRFI defines exception-handling and exception-raising constructs for Scheme, including
;;;    - a `with-exception-handler` procedure and a `guard` form for installing
;;;      exception-handling procedures,
;;;    - a `raise` procedure for invoking the current exception handler.
;;;
;;; Author of spec: Richard Kelsey, Michael Sperber
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 34)

  (export with-exception-handler
          guard
          raise)

  (import (lispkit dynamic))

  ;; `with-exception-handler`, `guard`, and `raise` are implemented natively in
  ;; library `(lispkit dynamic)`
)

;;; SRFI 35
;;; Conditions
;;;
;;; The SRFI defines constructs for creating and inspecting condition types and values.
;;; A condition value encapsulates information about an exceptional situation, or exception.
;;; This SRFI also defines a few basic condition types.
;;;
;;; Conditions are values that communicate information about exceptional situations between
;;; parts of a program. Code that detects an exception may be in a different part of the program
;;; than the code that handles it. In fact, the former may have been written independently from
;;; the latter. Consequently, to facilitate effective handling of exceptions, conditions must
;;; communicate as much information as possible as accurately as possible, and still allow
;;; effective handling by code that did not precisely anticipate the nature of the exception
;;; that occurred.
;;;
;;; This SRFI provides two mechanisms to enable this kind of communication:
;;;   1. subtyping among condition types allows handling code to determine the general nature
;;;      of an exception even though it does not anticipate its exact nature,
;;;   2. compound conditions allow an exceptional situation to be described in multiple ways.
;;;
;;; Copyright (C) Richard Kelsey, Michael Sperber (2002). All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;;; SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 35)
  
  (export make-condition-type
          condition-type?
          make-condition
          condition?
          condition-has-type?
          condition-ref
          make-compound-condition
          extract-condition
          define-condition-type
          condition
          condition-types ;REMOVE
          condition-subtype? ;REMOVE
          condition-type-supertype ;REMOVE
          &condition
          &message
          &serious
          &error)
  
  (import (lispkit base)
          (srfi 1))
  
  (begin
    
    (define-record-type <condition-type>
      (really-make-condition-type name supertype fields all-fields)
      condition-type?
      (name condition-type-name)
      (supertype condition-type-supertype)
      (fields condition-type-fields)
      (all-fields condition-type-all-fields))
    
    (define (make-condition-type name supertype fields)
      (if (not (symbol? name))
          (error "make-condition-type: name is not a symbol" name))
      (if (not (condition-type? supertype))
          (error "make-condition-type: supertype is not a condition type" supertype))
      (if (not (null? (lset-intersection eq?
                                         (condition-type-all-fields supertype)
                                         fields)))
          (error "duplicate field name" ))
      (really-make-condition-type name
                                  supertype
                                  fields
                                  (append (condition-type-all-fields supertype) fields)))
    
    (define-syntax define-condition-type
      (syntax-rules ()
        ((define-condition-type ?name ?supertype ?predicate (?field1 ?accessor1) ...)
         (begin
           (define ?name (make-condition-type '?name ?supertype '(?field1 ...)))
           (define (?predicate thing) (and (condition? thing) (condition-has-type? thing ?name)))
           (define (?accessor1 condition)
             (condition-ref (extract-condition condition ?name) '?field1))
           ...))))
    
    (define (condition-subtype? subtype supertype)
      (let recur ((subtype subtype))
        (cond ((not subtype)           #f)
              ((eq? subtype supertype) #t)
              (else                    (recur (condition-type-supertype subtype))))))
    
    (define (condition-type-field-supertype condition-type field)
      (let loop ((condition-type condition-type))
        (cond ((not condition-type)
                #f)
              ((memq field (condition-type-fields condition-type))
                condition-type)
              (else
                (loop (condition-type-supertype condition-type))))))
    
    ; The type-field-alist is of the form: ((<type> (<field-name> . <value>) ...) ...)
    (define-record-type <condition>
      (really-make-condition type-field-alist)
      condition?
      (type-field-alist condition-type-field-alist))
    
    (define (make-condition type . field-plist)
      (let ((alist (let label ((plist field-plist))
                     (if (null? plist)
                         '()
                         (cons (cons (car plist) (cadr plist))
                               (label (cddr plist)))))))
        (if (not (lset= eq? (condition-type-all-fields type) (map car alist)))
          (error "condition fields don't match condition type"))
        (really-make-condition (list (cons type alist)))))
    
    (define (condition-has-type? condition type)
      (any (lambda (has-type) (condition-subtype? has-type type))
           (condition-types condition)))
    
    (define (condition-ref condition field)
      (type-field-alist-ref (condition-type-field-alist condition) field))
    
    (define (type-field-alist-ref type-field-alist field)
      (let loop ((type-field-alist type-field-alist))
        (cond ((null? type-field-alist)
                (error "type-field-alist-ref: field not found"
                       type-field-alist field))
              ((assq field (cdr (car type-field-alist))) => cdr)
              (else
                (loop (cdr type-field-alist))))))
    
    (define (make-compound-condition condition-1 . conditions)
      (really-make-condition
        (apply append (map condition-type-field-alist (cons condition-1 conditions)))))
    
    (define (extract-condition condition type)
      (let ((entry (find (lambda (entry)
                                  (condition-subtype? (car entry) type))
                                (condition-type-field-alist condition))))
        (if (not entry)
            (error "extract-condition: invalid condition type" condition type))
        (really-make-condition
          (list (cons type
                      (map (lambda (field)
                             (assq field (cdr entry)))
                           (condition-type-all-fields type)))))))
    
    (define-syntax condition
      (syntax-rules ()
        ((_ (?type1 (?field1 ?value1) ...) ...)
          (type-field-alist->condition
            (list (cons ?type1 (list (cons '?field1 ?value1) ...))
                  ...)))))
    
    (define (type-field-alist->condition type-field-alist)
      (really-make-condition
        (map (lambda (entry)
               (cons (car entry)
                     (map (lambda (field)
                            (or (assq field (cdr entry))
                                (cons field
                                      (type-field-alist-ref type-field-alist field))))
                          (condition-type-all-fields (car entry)))))
             type-field-alist)))
    
    (define (condition-types condition)
      (map car (condition-type-field-alist condition)))
    
    (define (check-condition-type-field-alist the-type-field-alist)
      (let loop ((type-field-alist the-type-field-alist))
        (if (not (null? type-field-alist))
            (let* ((entry (car type-field-alist))
                   (type (car entry))
                   (field-alist (cdr entry))
                   (fields (map car field-alist))
                   (all-fields (condition-type-all-fields type)))
              (for-each (lambda (missing-field)
                          (let ((supertype
                                 (condition-type-field-supertype type missing-field)))
                            (if (not
                                 (any (lambda (entry)
                                        (let ((type (car entry)))
                                          (condition-subtype? type supertype)))
                                      the-type-field-alist))
                                (error "missing field in condition construction"
                                       type
                                       missing-field))))
                        (lset-difference eq? all-fields fields))
              (loop (cdr type-field-alist))))))
    
    (define &condition (really-make-condition-type '&condition #f '() '()))
    
    (define-condition-type &message &condition message-condition? (message condition-message))
    
    (define-condition-type &serious &condition serious-condition?)
    
    (define-condition-type &error &serious error?)
  )
)

 
;;; SRFI 39
;;; Parameter objects
;;;
;;; This SRFI defines parameter objects, the procedure `make-parameter` to create parameter
;;; objects and the `parameterize` special form to dynamically bind parameter objects.
;;; In the dynamic environment, each parameter object is bound to a cell containing the
;;; value of the parameter. When a procedure is called, the called procedure inherits the
;;; dynamic environment from the caller. The `parameterize` special form allows the binding
;;; of a parameter object to be changed for the dynamic extent of its body.
;;;
;;; Author of spec: Marc Feeley
;;;
;;; Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 39)

  (export make-parameter
          parameterize)

  (import (lispkit dynamic))

  ;; `make-parameter` and `parameterize` are implemented natively in library
  ;; `(lispkit dynamic)`
)
;;; SRFI 41
;;; Streams
;;;
;;; Streams, sometimes called lazy lists, are a sequential data structure containing elements
;;; computed only on demand. A stream is either null or is a pair with a stream in its cdr.
;;; Since elements of a stream are computed only when accessed, streams can be infinite.
;;; Once computed, the value of a stream element is cached in case it is needed again.
;;;
;;; Streams without memoization were first described by Peter Landin in 1965. Memoization
;;; became accepted as an essential feature of streams about a decade later. Today, streams
;;; are the signature data type of functional programming languages such as Haskell.
;;;
;;; This Scheme Request for Implementation describes two libraries for operating on streams:
;;; a canonical set of stream primitives and a set of procedures and syntax derived from
;;; those primitives that permits convenient expression of stream operations.
;;;
;;; Copyright © 2007 Philip L. Bewig. All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 41)

  (export define-stream
          list->stream
          port->stream
          stream
          stream?
          stream->list
          stream-append
          stream-car  
          stream-cdr
          stream-concat
          stream-cons
          stream-constant
          stream-drop
          stream-drop-while
          stream-filter
          stream-fold
          stream-for-each
          stream-from
          stream-iterate
          stream-lambda
          stream-length
          stream-let
          stream-map
          stream-match
          stream-null
          stream-null?
          stream-of
          stream-pair?
          stream-range
          stream-ref
          stream-reverse
          stream-scan
          stream-take
          stream-take-while
          stream-unfold
          stream-unfolds
          stream-zip)
  
  (import (srfi 41 primitive)
          (srfi 41 derived)))
;;; SRFI 46
;;; Basic Syntax-rules Extensions
;;;
;;; This SRFI proposes two extensions to the R5RS1 syntax-rules pattern language:
;;; the first allows syntax-rules macros to generate macros, where the macro-generated
;;; macros use ellipsis that is not used by the macro-generating macros; the second allows
;;; for 'tail patterns.'
;;;
;;; Author of spec: Taylor Campbell
;;;
;;; Copyright © 2019 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 46)

  (export syntax-rules)

  (import (lispkit core))
)
;;; SRFI 48
;;; Intermediate Format Strings
;;;
;;; This SRFI implements "format strings", a method of interpreting a Scheme string which
;;; contains a number of format directives that are replaced with other string data according
;;; to the semantics of each directive. The SRFI extends SRFI 28 in being more generally useful,
;;; but is less general than advanced format strings in that it does not allow, aside from ~F,
;;; for controlled positioning of text within fields.
;;;
;;; Copyright © 2003 Kenneth A Dickey. All rights reserved.
;;; Made an R7RS library by Taylan Ulrich Bayırlı/Kammer, Copyright © 2014.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to
;;; deal in the Software without restriction, including without limitation the
;;; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;; 
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
;;; IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 48)

  (export format
          *pretty-print*)

  (import (lispkit base)
          (lispkit prettify))

  (begin

    (define ascii-tab #\tab)

    (define *pretty-print* (make-parameter pretty-print))
    
    (define (format . args)
      (cond
        ((null? args)
          (error "FORMAT: required format-string argument is missing"))
        ((string? (car args))
          (apply format (cons #f args)))
        ((< (length args) 2)
          (error (format #f "FORMAT: too few arguments ~s" (cons 'format args))))
        (else
          (let ((output-port   (car  args))
                (format-string (cadr args))
                (args          (cddr args)))
            (letrec ((port 
                       (cond ((output-port? output-port) output-port)
                             ((eq? output-port #t) (current-output-port)) 
                             ((eq? output-port #f) (open-output-string)) 
                             (else
                               (error (format #f "FORMAT: bad output-port argument: ~s"
                                              output-port)))))
                     (return-value 
                       (if (eq? output-port #f)                 ;; if format into a string 
                           (lambda () (get-output-string port)) ;; then return the string
                           (lambda () (void)))))                ;; else do something harmless
               (define (format-help format-strg arglist)
                (letrec (
                   (length-of-format-string (string-length format-strg))
                   (anychar-dispatch (lambda (pos arglist last-was-newline) 
                                       (if (>= pos length-of-format-string) 
                                         arglist ; return unused args
                                         (let ((char (string-ref format-strg pos))) 
                                           (cond
                                             ((eqv? char #\~)   
                                               (tilde-dispatch (fx1+ pos) arglist last-was-newline)) 
                                             (else                   
                                               (write-char char port)     
                                               (anychar-dispatch (fx1+ pos) arglist #f)))))))
                   (has-newl? (lambda (whatever last-was-newline)
                                (or (eqv? whatever #\newline)
                                    (and (string? whatever)
                                         (let ((len (string-length whatever)))
                                           (if (zero? len)
                                               last-was-newline
                                               (eqv? #\newline
                                                     (string-ref whatever (fx1- len)))))))))
                   (tilde-dispatch          
                    (lambda (pos arglist last-was-newline)     
                      (cond           
                       ((>= pos length-of-format-string)   
                         (write-char #\~ port) ; tilde at end of string is just output
                         arglist) ; return unused args    
                       (else
                        (case (char-upcase (string-ref format-strg pos)) 
                          ((#\A)       ; Any -- for humans
                           (require-an-arg arglist)
                           (let ((whatever (car arglist)))
                             (display whatever port)
                             (anychar-dispatch (+ pos 1) 
                                               (cdr arglist) 
                                               (has-newl? whatever last-was-newline))))
                          ((#\S)       ; Slashified -- for parsers
                           (require-an-arg arglist)
                           (let ((whatever (car arglist)))
                              (write whatever port)     
                              (anychar-dispatch (+ pos 1) 
                                                (cdr arglist) 
                                                (has-newl? whatever last-was-newline))))
                          ((#\W)
                           (require-an-arg arglist)
                           (let ((whatever (car arglist)))
                              (write-shared whatever port)
                              (anychar-dispatch (+ pos 1) 
                                                (cdr arglist) 
                                                (has-newl? whatever last-was-newline))))                           
                          ((#\D)       ; Decimal
                           (require-an-arg arglist)
                           (display (number->string (car arglist) 10) port)  
                           (anychar-dispatch (+ pos 1) (cdr arglist) #f))            
                          ((#\X)       ; HeXadecimal
                           (require-an-arg arglist)
                           (display (number->string (car arglist) 16) port)
                           (anychar-dispatch (+ pos 1) (cdr arglist) #f))             
                          ((#\O)       ; Octal
                           (require-an-arg arglist)
                           (display (number->string (car arglist)  8) port) 
                           (anychar-dispatch (+ pos 1) (cdr arglist) #f))       
                          ((#\B)       ; Binary
                           (require-an-arg arglist)
                           (display (number->string (car arglist)  2) port)
                           (anychar-dispatch (+ pos 1) (cdr arglist) #f))           
                          ((#\C)       ; Character
                           (require-an-arg arglist)
                           (write-char (car arglist) port) 
                           (anychar-dispatch (+ pos 1) (cdr arglist)
                                             (eqv? (car arglist) #\newline)))          
                          ((#\~)       ; Tilde  
                           (write-char #\~ port)   
                           (anychar-dispatch (+ pos 1) arglist #f))            
                          ((#\%)       ; Newline   
                           (newline port) 
                           (anychar-dispatch (+ pos 1) arglist #t))
                          ((#\&)      ; Freshline
                           (if (not last-was-newline) ;; (unless last-was-newline ..
                               (newline port))
                           (anychar-dispatch (+ pos 1) arglist #t))
                          ((#\_)       ; Space 
                           (write-char #\space port)   
                           (anychar-dispatch (+ pos 1) arglist #f))             
                          ((#\T)       ; Tab -- IMPLEMENTATION DEPENDENT ENCODING    
                           (write-char ascii-tab port)          
                           (anychar-dispatch (+ pos 1) arglist #f))             
                          ((#\Y)       ; Pretty-print
                           ((*pretty-print*) (car arglist) port)
                           (anychar-dispatch (+ pos 1) (cdr arglist) #f))              
                          ((#\F)
                           (require-an-arg arglist)
                           (display (format-fixed (car arglist) 0 #f) port)
                           (anychar-dispatch (+ pos 1) (cdr arglist) #f))
                          ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
                           (let loop ((index (+ pos 1))          ;; gather "~w[,d]F" w and d digits
                                      (w-digits (list (string-ref format-strg pos)))
                                      (d-digits '())
                                      (in-width? #t))
                             (if (>= index length-of-format-string)
                                 (error
                                  (format "FORMAT: improper numeric format directive in ~s"
                                          format-strg))
                                 (let ((next-char (string-ref format-strg index)))
                                   (cond
                                    ((char-numeric? next-char)
                                     (if in-width?
                                         (loop (+ index 1)
                                               (cons next-char w-digits)
                                               d-digits
                                               in-width?)
                                         (loop (+ index 1)
                                               w-digits
                                               (cons next-char d-digits)
                                               in-width?)))
                                    ((char=? next-char #\F)
                                     (let ((width  (string->number
                                                     (list->string (reverse w-digits))))
                                           (digits (if (zero? (length d-digits))
                                                        #f
                                                        (string->number (list->string
                                                                          (reverse d-digits))))))
                                       (display (format-fixed (car arglist) width digits) port)
                                       (anychar-dispatch (+ index 1) (cdr arglist) #f)))
                                    ((char=? next-char #\,)
                                     (if in-width?
                                         (loop (+ index 1) w-digits d-digits #f)
                                         (error
                                           (format "FORMAT: too many commas in directive ~s"
                                                   format-strg))))
                                    (else
                                     (error (format "FORMAT: ~~w.dF directive ill-formed in ~s"
                                                    format-strg))))))))
                          ((#\? #\K)       ; indirection -- take next arg as format string
                           (cond           ; and following arg as list of format args
                             ((< (length arglist) 2)
                               (error
                                 (format "FORMAT: less arguments than specified for ~~?: ~s"
                                         arglist)))
                             ((not (string? (car arglist)))
                               (error (format "FORMAT: ~~? requires a string: ~s" (car arglist))))
                             (else
                               (format-help (car arglist) (cadr arglist))
                               (anychar-dispatch (+ pos 1) (cddr arglist) #f))))
                          ((#\H)           ; Help
                            (display documentation-string port)
                            (anychar-dispatch (+ pos 1) arglist #t))
                          (else                
                            (error (format "FORMAT: unknown tilde escape: ~s"
                                           (string-ref format-strg pos)))))))
                      )) ; end tilde-dispatch
                   ) ; end letrec
                   ; format-help main
                   (anychar-dispatch 0 arglist #f))) ; end format-help
              ; format main
              (let ((unused-args (format-help format-string args)))
                (if (not (null? unused-args))
                    (error (format "FORMAT: unused arguments ~s" unused-args)))
                (return-value)))))))

    (define (string-index str c)
      (do ((len (string-length str))
           (i 0 (fx1+ i)))
          ((or (fx= i len) (eqv? c (string-ref str i))) (if (fx= i len) #f i))))
    
    (define (string-grow str len char)
      (let ((off (fx- len (string-length str))))
        (if (positive? off)
            (string-append (make-string off char) str)
            str)))
    
    (define (compose-with-digits digits prestr fracstr expstr)
      (let ((frac-len (string-length fracstr)))
        (cond ((< frac-len digits) ;; grow frac part, pad with zeros
                (string-append prestr "." fracstr (make-string (fx- digits frac-len) #\0) expstr))
              ((= frac-len digits) ;; frac-part is exactly the right size
                (string-append prestr "." fracstr expstr))
              (else                ;; must round fracstr to shrink it
                (let* ((first    (substring fracstr 0 digits))
                       (last     (substring fracstr digits frac-len))
                       (lstr     (number->string (round (string->number
                                                          (string-append first "." last)))))
                       (lpad     (- (string-length first) (string-length lstr) -2))
                       (temp-str (if (> lpad 0) (string-append (make-string lpad #\0) lstr) lstr))
                       (dot-pos  (string-index temp-str #\.))
                       (carry?   (and (> dot-pos digits)
                                      (> (round (string->number (string-append "0." fracstr))) 0)))
                       (new-frac (if (>= lpad 0)
                                     (substring temp-str 0 digits)
                                     (substring temp-str 1 (fx1+ digits)))))                                                                   
                  (string-append (if carry? (number->string (+ 1 (string->number prestr))) prestr)
                                 (if (> digits 0)
                                     (string-append "." new-frac expstr)
                                     "")))))))
    
    (define (format-fixed number-or-string width digits) ; returns a string
      (cond ((string? number-or-string)
              (string-grow number-or-string width #\space))
            ((number? number-or-string)
              (let ((real (real-part number-or-string))
                    (imag (imag-part number-or-string)))
                (cond ((not (zero? imag))
                        (string-grow (string-append (format-fixed real 0 digits)
                                                    (if (negative? imag) "" "+")
                                                    (format-fixed imag 0 digits)
                                                    "i")
                                     width
                                     #\space))
                      (digits
                        (let* ((num-str    (number->string (inexact real)))
                               (dot-index  (string-index  num-str #\.))
                               (exp-index  (string-index  num-str #\e))
                               (length     (string-length num-str))
                               (pre-string
                                 (cond (exp-index
                                         (if dot-index
                                             (substring num-str 0 dot-index)
                                             (substring num-str 0 (fx1+ exp-index))))
                                       (dot-index
                                         (substring num-str 0 dot-index))
                                       (else
                                         num-str)))
                               (exp-string
                                 (if exp-index (substring num-str exp-index length) ""))
                               (frac-string
                                 (if exp-index
                                     (substring num-str (+ dot-index 1) exp-index)
                                     (substring num-str (+ dot-index 1) length))))
                          (string-grow
                            (if dot-index
                                (compose-with-digits digits pre-string frac-string exp-string)
                                (string-append pre-string exp-string))
                            width
                            #\space)))
                      (else ;; no digits
                        (string-grow (number->string number-or-string) width #\space)))))
             (else
               (error
                 (format "FORMAT: ~F requires a number or a string, got ~s" number-or-string)))))    
    
    (define documentation-string
      (string-append
    "(format [<port>] <format-string> [<arg>...]) -- <port> is #t, #f or an output-port\n"
    " OPTION  [MNEMONIC]      DESCRIPTION         -- Implementation assumes ASCII text encoding\n"
    "  ~H     [Help]          output this text\n"
    "  ~A     [Any]           (display arg) for humans\n"
    "  ~S     [Slashified]    (write arg) for parsers\n"
    "  ~W     [WriteCircular] like ~s but outputs circular and recursive data structures\n"
    "  ~~     [tilde]         output a tilde\n"
    "  ~T     [Tab]           output a tab character\n"
    "  ~%     [Newline]       output a newline character\n"
    "  ~&     [Freshline]     output a newline character if the previous output was not a newline\n"
    "  ~D     [Decimal]       the arg is a number which is output in decimal radix\n"
    "  ~X     [heXadecimal]   the arg is a number which is output in hexdecimal radix\n"
    "  ~O     [Octal]         the arg is a number which is output in octal radix\n"
    "  ~B     [Binary]        the arg is a number which is output in binary radix\n"
    "  ~w,dF  [Fixed]         the arg is a string or number which has width w and d digits after\n"
    "                         the decimal\n"
    "  ~C     [Character]     charater arg is output by write-char\n"
    "  ~_     [Space]         a single space character is output\n"
    "  ~Y     [Yuppify]       the list arg is pretty-printed to the output\n"
    "  ~?     [Indirection]   recursive format: next 2 args are format-string and list of\n"
    "                         arguments\n"
    "  ~K     [Indirection]   same as ~?\n"))
    
    (define (require-an-arg args)
      (if (null? args)
          (error "FORMAT: too few arguments")))
  )
)
;;; SRFI 51
;;; Handling rest list
;;;
;;; This SRFI introduces the rest-values procedure which has three modes of operation:
;;;    1. it processes a rest list after checking its elements with default values
;;;       or predicate procedures,
;;;    2. it processes a rest list with default values without checking its elements,
;;;    3. it processes a default list whose elements are lists or pairs, after checking
;;;       their elements that are default values or predicate procedures with the elements
;;;       of a rest list,
;;; and eight macros which additionally check the rest arguments that are returned by
;;; `rest-values`.
;;; When defining a procedure with a variable number of arguments, `rest-values` with or without
;;; the checking macros reduces the clutter of various conditionals and error conditions.
;;; The procedure and macros proposed in this SRFI make a strong combination with `receive`
;;; (SRFI 8) and `let-values` (SRFI 11).
;;;
;;; Copyright © 2004 Joo ChurlSoo. All rights reserved.
;;; Made an R7RS library by Taylan Ulrich Bayırlı/Kammer, Copyright © 2014.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to
;;; deal in the Software without restriction, including without limitation the
;;; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
;;; IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 51)

  (export rest-values
          arg-and
          arg-ands
          err-and
          err-ands
          arg-or
          arg-ors
          err-or
          err-ors)

  (import (lispkit base)
          (srfi 1))

  (begin
    (define (rest-values rest . default)
      (let* ((caller (if (or (null? default)
           (boolean? (car default))
           (integer? (car default))
           (memq (car default) (list + -)))
             '()
             (if (string? rest) rest (list rest))))
       (rest-list (if (null? caller) rest (car default)))
       (rest-length (if (list? rest-list)
            (length rest-list)
            (if (string? caller)
                (error caller rest-list 'rest-list
                 '(list? rest-list))
                (apply error "bad rest list" rest-list 'rest-list
                 '(list? rest-list) caller))))
       (default (if (null? caller) default (cdr default)))
       (default-list (if (null? default) default (cdr default)))
       (default-length (length default-list))
       (number
        (and (not (null? default))
             (let ((option (car default)))
         (or (and (integer? option)
            (or (and (> rest-length (abs option))
               (if (string? caller)
                   (error caller rest-list 'rest-list
                    `(<= (length rest-list)
                   ,(abs option)))
                   (apply error "too many arguments"
                    rest-list 'rest-list
                    `(<= (length rest-list)
                   ,(abs option))
                    caller)))
                (and (> default-length (abs option))
               (if (string? caller)
                   (error caller default-list
                    'default-list
                    `(<= (length default-list)
                   ,(abs option)))
                   (apply error "too many defaults"
                    default-list 'default-list
                    `(<= (length default-list)
                   ,(abs option))
                    caller)))
                option))
             (eq? option #t)
             (and (not option) 'false)
             (and (eq? option +) +)
             (and (eq? option -) -)
             (if (string? caller)
           (error caller option 'option
            '(or (boolean? option)
                 (integer? option)
                 (memq option (list + -))))
           (apply error "bad optional argument" option 'option
            '(or (boolean? option)
                 (integer? option)
                 (memq option (list + -)))
            caller)))))))
        (cond
         ((or (eq? #t number) (eq? 'false number))
          (and (not (every pair? default-list))
         (if (string? caller)
             (error caller default-list 'default-list
              '(every pair? default-list))
             (apply error "bad default list" default-list 'default-list
              '(every pair? default-list) caller)))
          (let loop ((rest-list rest-list)
         (default-list default-list)
         (result '()))
      (if (null? default-list)
          (if (null? rest-list)
        (apply values (reverse result))
        (if (eq? #t number)
            (if (string? caller)
          (error caller rest-list 'rest-list '(null? rest-list))
          (apply error "bad argument" rest-list 'rest-list
                 '(null? rest-list) caller))
            (apply values (append-reverse result rest-list))))
          (if (null? rest-list)
        (apply values (append-reverse result (map car default-list)))
        (let ((default (car default-list)))
          (let lp ((rest rest-list)
             (head '()))
            (if (null? rest)
          (loop (reverse head)
                (cdr default-list)
                (cons (car default) result))
          (if (list? default)
              (if (member (car rest) default)
            (loop (append-reverse head (cdr rest))
                  (cdr default-list)
                  (cons (car rest) result))
            (lp (cdr rest) (cons (car rest) head)))
              (if ((cdr default) (car rest))
            (loop (append-reverse head (cdr rest))
                  (cdr default-list)
                  (cons (car rest) result))
            (lp (cdr rest) (cons (car rest) head)))))))))))
         ((or (and (integer? number) (> number 0))
        (eq? number +))
          (and (not (every pair? default-list))
         (if (string? caller)
             (error caller default-list 'default-list
              '(every pair? default-list))
             (apply error "bad default list" default-list 'default-list
              '(every pair? default-list) caller)))
          (let loop ((rest rest-list)
         (default default-list))
      (if (or (null? rest) (null? default))
          (apply values
           (if (> default-length rest-length)
               (append rest-list
                 (map car (list-tail default-list rest-length)))
               rest-list))
          (let ((arg (car rest))
          (par (car default)))
            (if (list? par)
          (if (member arg par)
              (loop (cdr rest) (cdr default))
              (if (string? caller)
            (error caller arg 'arg `(member arg ,par))
            (apply error "unmatched argument"
             arg 'arg `(member arg ,par) caller)))
          (if ((cdr par) arg)
              (loop (cdr rest) (cdr default))
              (if (string? caller)
            (error caller arg 'arg `(,(cdr par) arg))
            (apply error "incorrect argument"
             arg 'arg `(,(cdr par) arg) caller))))))))
         (else
          (apply values (if (> default-length rest-length)
          (append rest-list (list-tail default-list rest-length))
          rest-list))))))

    (define-syntax arg-and
      (syntax-rules()
        ((arg-and arg (a1 a2 ...) ...)
         (and (or (symbol? 'arg)
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(arg-and arg (a1 a2 ...) ...)))
        (or (a1 a2 ...)
            (error "incorrect argument" arg 'arg '(a1 a2 ...)))
        ...))
        ((arg-and caller arg (a1 a2 ...) ...)
         (and (or (symbol? 'arg)
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(arg-and caller arg (a1 a2 ...) ...)))
        (or (a1 a2 ...)
            (if (string? caller)
          (error caller arg 'arg '(a1 a2 ...))
          (error "incorrect argument" arg 'arg '(a1 a2 ...) caller)))
        ...))))

    ;; accessory macro for arg-ands
    (define-syntax caller-arg-and
      (syntax-rules()
        ((caller-arg-and caller arg (a1 a2 ...) ...)
         (and (or (symbol? 'arg)
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(caller-arg-and caller arg (a1 a2 ...) ...)))
        (or (a1 a2 ...)
            (if (string? caller)
          (error caller arg 'arg '(a1 a2 ...))
          (error "incorrect argument" arg 'arg '(a1 a2 ...) caller)))
        ...))
        ((caller-arg-and null caller arg (a1 a2 ...) ...)
         (and (or (symbol? 'arg)
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(caller-arg-and caller arg (a1 a2 ...) ...)))
        (or (a1 a2 ...)
            (if (string? caller)
          (error caller arg 'arg '(a1 a2 ...))
          (error "incorrect argument" arg 'arg '(a1 a2 ...) caller)))
        ...))))

    (define-syntax arg-ands
      (syntax-rules (common)
        ((arg-ands (a1 a2 ...) ...)
         (and (arg-and a1 a2 ...) ...))
        ((arg-ands common caller (a1 a2 ...) ...)
         (and (caller-arg-and caller a1 a2 ...) ...))))

    (define-syntax arg-or
      (syntax-rules()
        ((arg-or arg (a1 a2 ...) ...)
         (or (and (not (symbol? 'arg))
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(arg-or arg (a1 a2 ...) ...)))
       (and (a1 a2 ...)
            (error "incorrect argument" arg 'arg '(a1 a2 ...)))
       ...))
        ((arg-or caller arg (a1 a2 ...) ...)
         (or (and (not (symbol? 'arg))
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(arg-or caller arg (a1 a2 ...) ...)))
       (and (a1 a2 ...)
            (if (string? caller)
          (error caller arg 'arg '(a1 a2 ...))
          (error "incorrect argument" arg 'arg '(a1 a2 ...) caller)))
       ...))))

    ;; accessory macro for arg-ors
    (define-syntax caller-arg-or
      (syntax-rules()
        ((caller-arg-or caller arg (a1 a2 ...) ...)
         (or (and (not (symbol? 'arg))
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(caller-arg-or caller arg (a1 a2 ...) ...)))
       (and (a1 a2 ...)
            (if (string? caller)
          (error caller arg 'arg '(a1 a2 ...))
          (error "incorrect argument" arg 'arg '(a1 a2 ...) caller)))
       ...))
        ((caller-arg-or null caller arg (a1 a2 ...) ...)
         (or (and (not (symbol? 'arg))
            (error "bad syntax" 'arg '(symbol? 'arg)
             '(caller-arg-or caller arg (a1 a2 ...) ...)))
       (and (a1 a2 ...)
            (if (string? caller)
          (error caller arg 'arg '(a1 a2 ...))
          (error "incorrect argument" arg 'arg '(a1 a2 ...) caller)))
       ...))))

    (define-syntax arg-ors
      (syntax-rules (common)
        ((arg-ors (a1 a2 ...) ...)
         (or (arg-or a1 a2 ...) ...))
        ((arg-ors common caller (a1 a2 ...) ...)
         (or (caller-arg-or caller a1 a2 ...) ...))))

    (define-syntax err-and
      (syntax-rules ()
        ((err-and err expression ...)
         (and (or expression
            (if (string? err)
          (error err 'expression)
          (error "false expression" 'expression err)))
        ...))))

    (define-syntax err-ands
      (syntax-rules ()
        ((err-ands (err expression ...)  ...)
         (and (err-and err expression ...)
        ...))))

    (define-syntax err-or
      (syntax-rules ()
        ((err-or err expression ...)
         (or (and expression
            (if (string? err)
          (error err 'expression)
          (error "true expression" 'expression err)))
       ...))))

    (define-syntax err-ors
      (syntax-rules ()
        ((err-ors (err expression ...) ...)
         (or (err-or err expression ...)
       ...))))
  )
)

;;; SRFI 54
;;; Formatting
;;;
;;; This SRFI introduces the `cat` procedure that converts any object to a string. It takes
;;; one object as the first argument and accepts a variable number of optional arguments,
;;; unlike the procedure called `format`.
;;;
;;; Copyright © 2004 Joo ChurlSoo. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to
;;; deal in the Software without restriction, including without limitation the
;;; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
;;; IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 54)

  (export cat)

  (import (lispkit base))

  (begin
  
    (define-syntax alet-cat*        ; borrowed from SRFI-86
      (syntax-rules ()
        ((alet-cat* z (a . e) bd ...)
         (let ((y z))
           (%alet-cat* y (a . e) bd ...)))))

    (define-syntax %alet-cat*        ; borrowed from SRFI-86
      (syntax-rules ()
        ((%alet-cat* z ((n d t ...)) bd ...)
         (let ((n (if (null? z)
              d
              (if (null? (cdr z))
                  (wow-cat-end z n t ...)
                  (error "cat: too many arguments" (cdr z))))))
           bd ...))
        ((%alet-cat* z ((n d t ...) . e) bd ...)
         (let ((n (if (null? z)
              d
              (wow-cat! z n d t ...))))
           (%alet-cat* z e bd ...)))
        ((%alet-cat* z e bd ...)
         (let ((e z)) bd ...))))

    (define-syntax wow-cat!            ; borrowed from SRFI-86
      (syntax-rules ()
        ((wow-cat! z n d)
         (let ((n (car z)))
           (set! z (cdr z))
           n))
        ((wow-cat! z n d t)
         (let ((n (car z)))
           (if t
           (begin (set! z (cdr z)) n)
           (let lp ((head (list n)) (tail (cdr z)))
             (if (null? tail)
             d
             (let ((n (car tail)))
               (if t
                   (begin (set! z (append (reverse head) (cdr tail))) n)
                   (lp (cons n head) (cdr tail)))))))))
        ((wow-cat! z n d t ts)
         (let ((n (car z)))
           (if t
           (begin (set! z (cdr z)) ts)
           (let lp ((head (list n)) (tail (cdr z)))
             (if (null? tail)
             d
             (let ((n (car tail)))
               (if t
                   (begin (set! z (append (reverse head) (cdr tail))) ts)
                   (lp (cons n head) (cdr tail)))))))))
        ((wow-cat! z n d t ts fs)
         (let ((n (car z)))
           (if t
           (begin (set! z (cdr z)) ts)
           (begin (set! z (cdr z)) fs))))))

    (define-syntax wow-cat-end        ; borrowed from SRFI-86
      (syntax-rules ()
        ((wow-cat-end z n)
         (car z))
        ((wow-cat-end z n t)
         (let ((n (car z)))
           (if t n (error "cat: too many argument" z))))
        ((wow-cat-end z n t ts)
         (let ((n (car z)))
           (if t ts (error "cat: too many argument" z))))
        ((wow-cat-end z n t ts fs)
         (let ((n (car z)))
           (if t ts fs)))))

    (define (str-index str char)
      (let ((len (string-length str)))
        (let lp ((n 0))
          (and (< n len)
           (if (char=? char (string-ref str n))
               n
               (lp (+ n 1)))))))

    (define (part pred ls)
      (let lp ((ls ls) (true '()) (false '()))
        (cond
         ((null? ls) (cons (reverse true) (reverse false)))
         ((pred (car ls)) (lp (cdr ls) (cons (car ls) true) false))
         (else (lp (cdr ls) true (cons (car ls) false))))))

    (define (e-mold num pre)
      (let* ((str (number->string (inexact num)))
         (e-index (str-index str #\e)))
        (if e-index
        (string-append (mold (substring str 0 e-index) pre)
                   (substring str e-index (string-length str)))
        (mold str pre))))

    (define (mold str pre)
      (let ((ind (str-index str #\.)))
        (if ind
        (let ((d-len (- (string-length str) (+ ind 1))))
          (cond
           ((= d-len pre) str)
           ((< d-len pre) (string-append str (make-string (- pre d-len) #\0)))
           ;;((char<? #\4 (string-ref str (+ 1 ind pre)))
           ;;(let ((com (expt 10 pre)))
           ;;  (number->string (/ (round (* (string->number str) com)) com))))
           ((or (char<? #\5 (string-ref str (+ 1 ind pre)))
            (and (char=? #\5 (string-ref str (+ 1 ind pre)))
                 (or (< (+ 1 pre) d-len)
                 (memv (string-ref str (+ ind (if (= 0 pre) -1 pre)))
                       '(#\1 #\3 #\5 #\7 #\9)))))
            (apply
             string
             (let* ((minus (char=? #\- (string-ref str 0)))
                (str (substring str (if minus 1 0) (+ 1 ind pre)))
                (char-list
                 (reverse
                  (let lp ((index (- (string-length str) 1))
                       (raise #t))
                (if (= -1 index)
                    (if raise '(#\1) '())
                    (let ((chr (string-ref str index)))
                      (if (char=? #\. chr)
                      (cons chr (lp (- index 1) raise))
                      (if raise
                          (if (char=? #\9 chr)
                          (cons #\0 (lp (- index 1) raise))
                          (cons (integer->char
                             (+ 1 (char->integer chr)))
                            (lp (- index 1) #f)))
                          (cons chr (lp (- index 1) raise))))))))))
               (if minus (cons #\- char-list) char-list))))
           (else
            (substring str 0 (+ 1 ind pre)))))
        (string-append str "." (make-string pre #\0)))))

    (define (separate str sep num opt)
      (let* ((len (string-length str))
         (pos (if opt
              (let ((pos (remainder (if (eq? opt 'minus) (- len 1) len)
                        num)))
                (if (= 0 pos) num pos))
              num)))
        (apply string-append
           (let loop ((ini 0)
                  (pos (if (eq? opt 'minus) (+ pos 1) pos)))
             (if (< pos len)
             (cons (substring str ini pos)
                   (cons sep (loop pos (+ pos num))))
             (list (substring str ini len)))))))

    (define (cat object . rest)
      (let* ((str-rest (part string? rest))
         (str-list (car str-rest))
         (rest-list (cdr str-rest)))
        (if (null? rest-list)
        (apply string-append
               (cond
            ((number? object) (number->string object))
            ((string? object) object)
            ((char? object) (string object))
            ((boolean? object) (if object "#t" "#f"))
            ((symbol? object) (symbol->string object))
            (else
             (get-output-string
              (let ((str-port (open-output-string)))
                (write object str-port)
                str-port))))
               str-list)
        (alet-cat* rest-list
          ((width 0 (and (integer? width) (exact? width)))
           (port #f (or (boolean? port) (output-port? port))
             (if (eq? port #t) (current-output-port) port))
           (char #\space (char? char))
           (converter #f (and (pair? converter)
                      (procedure? (car converter))
                      (procedure? (cdr converter))))
           (precision #f (and (integer? precision)
                      (inexact? precision)))
           (sign #f (eq? 'sign sign))
           (radix 'decimal
              (memq radix '(decimal octal binary hexadecimal)))
           (exactness #f (memq exactness '(exact inexact)))
           (separator #f (and (list? separator)
                      (< 0 (length separator) 3)
                      (char? (car separator))
                      (or (null? (cdr separator))
                      (let ((n (cadr separator)))
                        (and (integer? n) (exact? n)
                         (< 0 n))))))
           (writer #f (procedure? writer))
           (pipe #f (and (list? pipe)
                 (not (null? pipe))
                 (every? procedure? pipe)))
           (take #f (and (list? take)
                 (< 0 (length take) 3)
                 (every? (lambda (x)
                       (and (integer? x) (exact? x)))
                     take))))
          (let* ((str
              (cond
               ((and converter
                 ((car converter) object))
                (let* ((str ((cdr converter) object))
                   (pad (- (abs width) (string-length str))))
                  (cond
                   ((<= pad 0) str)
                   ((< 0 width) (string-append (make-string pad char) str))
                   (else (string-append str (make-string pad char))))))
               ((number? object)
                (and (not (eq? radix 'decimal)) precision
                 (error "cat: non-decimal cannot have a decimal point"))
                (and precision (< precision 0) (eq? exactness 'exact)
                 (error "cat: exact number cannot have a decimal point without exact sign"))
                (let* ((exact-sign (and precision
                            (<= 0 precision)
                            (or (eq? exactness 'exact)
                            (and (exact? object)
                                 (not (eq? exactness
                                       'inexact))))
                            "#e"))
                   (inexact-sign (and (not (eq? radix 'decimal))
                              (or (and (inexact? object)
                                   (not (eq? exactness
                                     'exact)))
                              (eq? exactness 'inexact))
                              "#i"))
                   (radix-sign (cdr (assq radix
                              '((decimal . #f)
                                (octal . "#o")
                                (binary . "#b")
                                (hexadecimal . "#x")))))
                   (plus-sign (and sign (< 0 (real-part object)) "+"))
                   (exactness-sign (or exact-sign inexact-sign))
                   (str0
                    (if precision
                    (let ((precision (exact
                              (abs precision)))
                          (imag (imag-part object)))
                      (if (= 0 imag)
                          (e-mold object precision)
                          (string-append
                           (e-mold (real-part object) precision)
                           (if (< 0 imag) "+" "")
                           (e-mold imag precision)
                           "i")))
                    (number->string
                     (cond
                      (inexact-sign (exact object))
                      (exactness
                       (if (eq? exactness 'exact)
                           (exact object)
                           (inexact object)))
                      (else object))
                     (cdr (assq radix '((decimal . 10)
                                (octal . 8)
                                (binary . 2)
                                (hexadecimal . 16)))))))
                   (str
                    (if (and separator
                         (not (or (and (eq? radix 'decimal)
                               (str-index str0 #\e))
                              (str-index str0 #\i)
                              (str-index str0 #\/))))
                    (let ((sep (string (car separator)))
                          (num (if (null? (cdr separator))
                               3 (cadr separator)))
                          (dot-index (str-index str0 #\.)))
                      (if dot-index
                          (string-append
                           (separate (substring str0 0 dot-index)
                             sep num (if (< object 0)
                                     'minus #t))
                           "."
                           (separate (substring
                              str0 (+ 1 dot-index)
                              (string-length str0))
                             sep num #f))
                          (separate str0 sep num (if (< object 0)
                                    'minus #t))))
                    str0))
                   (pad0 (- (abs width)
                       (+ (string-length str)
                          (if exactness-sign 2 0)
                          (if radix-sign 2 0)
                          (if plus-sign 1 0))))
                   (pad (if (< 0 pad0) pad0 0)))
                  (if (< 0 width)
                  (if (char-numeric? char)
                      (if (< (real-part object) 0)
                      (string-append (or exactness-sign "")
                             (or radix-sign "")
                             "-"
                             (make-string pad char)
                             (substring str 1
                                    (string-length
                                     str)))
                      (string-append (or exactness-sign "")
                             (or radix-sign "")
                             (or plus-sign "")
                             (make-string pad char)
                             str))
                      (string-append (make-string pad char)
                             (or exactness-sign "")
                             (or radix-sign "")
                             (or plus-sign "")
                             str))
                  (string-append (or exactness-sign "")
                         (or radix-sign "")
                         (or plus-sign "")
                         str
                         (make-string pad char)))))
               (else
                (let* ((str0 (cond
                     (writer (get-output-string
                          (let ((str-port
                             (open-output-string)))
                            (writer object str-port)
                            str-port)))
                     ((string? object) object)
                     ((char? object) (string object))
                     ((boolean? object) (if object "#t" "#f"))
                     ((symbol? object) (symbol->string object))
                     (else (get-output-string
                        (let ((str-port (open-output-string)))
                          (write object str-port)
                          str-port)))))
                   (str1 (if pipe
                        (let loop ((str ((car pipe) str0))
                               (fns (cdr pipe)))
                          (if (null? fns)
                          str
                          (loop ((car fns) str)
                            (cdr fns))))
                        str0))
                   (str
                    (if take
                    (let ((left (car take))
                          (right (if (null? (cdr take))
                             0 (cadr take)))
                          (len (string-length str1)))
                      (define (substr str1 beg end)
                        (let ((end (cond
                            ((< end 0) 0)
                            ((< len end) len)
                            (else end)))
                          (beg (cond
                            ((< beg 0) 0)
                            ((< len beg) len)
                            (else beg))))
                          (if (and (= beg 0) (= end len))
                          str1
                          (substring str1 beg end))))
                      (string-append
                       (if (< left 0)
                           (substr str1 (abs left) len)
                           (substr str1 0 left))
                       (if (< right 0)
                           (substr str1 0 (+ len right))
                           (substr str1 (- len right) len))))
                    str1))
                   (pad (- (abs width) (string-length str))))
                  (cond
                   ((<= pad 0) str)
                   ((< 0 width) (string-append (make-string pad char) str))
                   (else (string-append str (make-string pad char))))))))
             (str3 (apply string-append str str-list)))
            (and port (display str3 port))
            str3)))))
  )
)
;;; SRFI 55
;;; require-extension
;;;
;;; This SRFI specifies an extremely simple facility for making an extension or library
;;; available to a Scheme toplevel environment.
;;;
;;; Authors of spec: Felix L. Winkelmann, D.C. Frost
;;;
;;; Copyright © 2019 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 55)

  (export require-extension)

  (import (lispkit base))

  (begin
    (define-syntax require-extension
      (syntax-rules ()
        ((require-extension (prefix mod ...))
          (begin (import (prefix mod) ...)))))
  )
)
;;; SRFI 6
;;; Basic string ports
;;;
;;; Scheme's I/O primitives are extended by adding three new procedures that create an input
;;; port from a string, create an output port whose contents are accumulated in Scheme's
;;; working memory instead of an external file, and extract the accumulated contents of an
;;; in-memory output port and return them in the form of a string.
;;;
;;; Copyright © 1999 William D Clinger. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 6)

  (export open-input-string
          open-output-string
          get-output-string)

  (import (lispkit port))

  ;; all exported procedures are implemented natively in library `(lispkit port)`
)
;;; SRFI 63
;;; Homogeneous and Heterogeneous Arrays
;;;
;;; This SRFI supersedes SRFI 47, "Array". It has the following objectives:
;;;   - Synthesizes array concepts from Common-Lisp and Alan Bawden's "array.scm",
;;;   - Incorporates all the uniform vector types from SFRI-4 "Homogeneous numeric
;;;     vector datatypes",
;;;   - Adds a boolean uniform array type,
;;;   - Adds 16.bit and 128.bit floating-point uniform-array types,
;;;   - Adds decimal floating-point uniform-array types, and
;;;   - Adds array types of (dual) floating-point complex numbers.
;;;
;;; Multi-dimensional arrays subsume homogeneous vectors as the one-dimensional case,
;;; obviating the need for SRFI 4.
;;;
;;; "array.scm" Arrays for Scheme
;;; Copyright © 2001, 2003 Aubrey Jaffer
;;;
;;; Permission to copy this software, to modify it, to redistribute it,
;;; to distribute modified versions, and to use it for any purpose is
;;; granted, subject to the following restrictions and understandings.
;;;
;;; 1. Any copy made of this software must include this copyright notice in full.
;;;
;;; 2. I have made no warranty or representation that the operation of this software
;;;    will be error-free, and I am under no obligation to provide any services, by
;;;    way of maintenance, update, or otherwise.
;;;
;;; 3.  In conjunction with products arising from the use of this material, there
;;;     shall be no use of my name in any advertising, promotional, or sales literature
;;;     without prior written consent in each case.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 63)
  (export array?
          equal?
          array-rank
          array-dimensions
          make-array
          make-shared-array
          list->array
          array->list
          vector->array
          array->vector
          array-in-bounds?
          array-ref
          array-set!
          a:floc128b
          a:floc64b
          a:floc32b
          a:floc16b
          a:flor128b
          a:flor64b
          a:flor32b
          a:flor16b
          a:fixz64b
          a:fixz32b
          a:fixz16b
          a:fixz8b
          a:fixn64b
          a:fixn32b
          a:fixn16b
          a:fixn8b
          a:bool)

  (import (except (lispkit base) equal?))

  (begin

    (define-record-type <array>
      (array:construct dimensions scales offset store)
      array:array?
      (dimensions dimensions)
      (scales scales)
      (offset offset)
      (store store))

    ;; Returns a list of dimensions for the given array.
    ;;
    ;; Example:
    ;;   (array-dimensions (make-array '#() 3 5))
    ;;   ==> (3 5)
    (define (array-dimensions array)
      (cond ((vector? array) (list (vector-length array)))
            ((string? array) (list (string-length array)))
            (else            (dimensions array))))

    (define (array:scales array)
      (cond ((vector? array) (list 1))
            ((string? array) (list 1))
            (else            (scales array))))

    (define (array:store array)
      (cond ((vector? array) array)
            ((string? array) array)
            (else            (store array))))

    (define (array:offset array)
      (cond ((vector? array) 0)
            ((string? array) 0)
            (else            (offset array))))

    ;; Returns #t if `obj` is an array, and #f otherwise.
    (define (array? obj)
      (or (vector? obj) (string? obj) (array:array? obj)))

    ;; Returns #t if `obj1` and `obj2` have the same rank and dimensions and the
    ;; corresponding elements of `obj1` and `obj2` are `equal?`.
    ;; This function recursively compares the contents of pairs, vectors, strings, and
    ;; arrays, applying `eqv?` on other objects such as numbers and symbols. A rule of
    ;; thumb is that objects are generally `eual?` if they print the same. `equal?` may
    ;; fail to terminate if its arguments are circular data structures.
    ;;
    ;; Note: Arrays are not disjoint from other Scheme types. Vectors and possibly strings
    ;; also satisfy `array?`. A disjoint array predicate can be written:
    ;;
    ;; (define (strict-array? obj)
    ;;   (and (array? obj) (not (string? obj)) (not (vector? obj))))
    ;;
    ;; Examples:
    ;;   (equal? 'a 'a)                                   ==> #t
    ;;   (equal? '(a) '(a))                               ==> #t
    ;;   (equal? '(a (b) c) '(a (b) c))                   ==> #t
    ;;   (equal? "abc" "abc")                             ==> #t
    ;;   (equal? 2 2)                                     ==> #t
    ;;   (equal? (make-vector 5 'a) (make-vector 5 'a))   ==> #t
    ;;   (equal? (make-array (a:fixN32b 4) 5 3)
    ;;           (make-array (a:fixN32b 4) 5 3))          ==> #t
    ;;   (equal? (make-array '#(foo) 3 3)
    ;;           (make-array '#(foo) 3 3))                ==> #t
    ;;   (equal? (lambda (x) x) (lambda (y) y)).          ==> ? (undefined)
    (define (equal? obj1 obj2)
      (cond ((eqv? obj1 obj2)
              #t)
            ((or (pair? obj1) (pair? obj2))
              (and (pair? obj1) (pair? obj2)
                   (equal? (car obj1) (car obj2))
                   (equal? (cdr obj1) (cdr obj2))))
            ((or (string? obj1) (string? obj2))
              (and (string? obj1) (string? obj2)
                   (string=? obj1 obj2)))
            ((or (vector? obj1) (vector? obj2))
              (and (vector? obj1) (vector? obj2)
                   (equal? (vector-length obj1) (vector-length obj2))
                   (do ((idx (+ -1 (vector-length obj1)) (+ -1 idx)))
                       ((or (negative? idx)
                            (not (equal? (vector-ref obj1 idx)
                                         (vector-ref obj2 idx))))
                        (negative? idx)))))
            ((or (array? obj1) (array? obj2))
              (and (array? obj1) (array? obj2)
                   (equal? (array-dimensions obj1) (array-dimensions obj2))
                   (equal? (array:store obj1) (array:store obj2))))
            (else
              #f)))

    ;; Returns the number of dimensions of `obj`.  If `obj` is not an array, 0 is
    ;; returned.
    (define (array-rank obj)
      (if (array? obj) (length (array-dimensions obj)) 0))

    ;; Creates and returns an array of type `prototype` with dimensions `dimensions`
    ;; and filled with elements from `prototype`. `prototype` must be an array, vector,
    ;; or string. The implementation-dependent type of the returned array will be the
    ;; same as the type of `prototype`, except if that would be a vector or string with
    ;; rank not equal to one, in which case some variety of array will be returned.
    ;;
    ;; If argument `prototype` has no elements, then the initial contents of the returned
    ;; array are unspecified. Otherwise, the returned array will be filled with the
    ;; element at the origin of `prototype`.
    (define (make-array prototype . dimensions)
      (let* ((tcnt (apply * dimensions))
             (store (if (string? prototype)
                        (case (string-length prototype)
                          ((0)  (make-string tcnt))
                          (else (make-string tcnt (string-ref prototype 0))))
                        (let ((pdims (array-dimensions prototype)))
                          (case (apply * pdims)
                            ((0)  (make-vector tcnt))
                            (else (make-vector tcnt
                                               (apply array-ref prototype
                                                      (map (lambda (x) 0) pdims)))))))))
        (define (loop dims scales)
          (if (null? dims)
              (array:construct dimensions (cdr scales) 0 store)
              (loop (cdr dims) (cons (* (car dims) (car scales)) scales))))
        (loop (reverse dimensions) (list 1))))

    ;; `make-shared-array` can be used to create shared subarrays of other
    ;; arrays. `mapper` is a function that translates coordinates in the new array into
    ;; coordinates in the old array.  A `mapper` must be linear, and its range must stay
    ;; within the bounds of the old array, but it can be otherwise arbitrary.
    ;;
    ;; Examples:
    ;;   (define fred (make-array '#(#f) 8 8))
    ;;   (define freds-diagonal (make-shared-array fred (lambda (i) (list i i)) 8))
    ;;   (array-set! freds-diagonal 'foo 3)
    ;;   (array-ref fred 3 3)                    ==> foo
    ;;   (define freds-center
    ;;     (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
    ;;   (array-ref freds-center 0 0).           ==> foo
    (define (make-shared-array array mapper . dimensions)
      (let ((odl   (array:scales array))
            (rank  (length dimensions))
            (shape (map (lambda (dim) (if (list? dim) dim (list 0 (- dim 1)))) dimensions)))
        (do ((idx (+ -1 rank) (+ -1 idx))
             (uvt (append (cdr (vector->list (make-vector rank 0))) (list 1))
                  (append (cdr uvt) '(0)))
             (uvts '() (cons uvt uvts)))
            ((negative? idx)
             (let ((ker0 (apply + (map * odl (apply mapper uvt)))))
               (array:construct
                 (map (lambda (dim) (+ 1 (- (cadr dim) (car dim)))) shape)
                 (map (lambda (uvt) (- (apply + (map * odl (apply mapper uvt))) ker0)) uvts)
                 (apply + (array:offset array) (map * odl (apply mapper (map car shape))))
                 (array:store array)))))))

    ;; `list->array` returns an array of rank `rank` and type `proto` consisting of all
    ;; the elements, in row-major order, of `lst`. When `rank` is 0, `lst` is the lone
    ;; array element; not necessarily a list.
    ;; `lst` must be a rank-nested list consisting of all the elements, in
    ;; row-major order, of the array to be created.
    ;;
    ;; Examples:
    ;;   (list->array 2 '#() '((1 2) (3 4)))        ==> #2A((1 2) (3 4))
    ;;   (list->array 0 '#() 3)                     ==> #0A 3
    (define (list->array rank proto lst)
      (let* ((dimensions (do ((shp '() (cons (length row) shp))
                              (row lst (car lst))
                              (rnk (+ -1 rank) (+ -1 rnk)))
                             ((negative? rnk) (reverse shp))))
             (nra (apply make-array proto dimensions)))
        (define (l2ra dims idxs row)
          (cond ((null? dims)
                 (apply array-set! nra row (reverse idxs)))
                (else
                 (if (not (eqv? (car dims) (length row)))
                     (error "Array not rectangular:" dims dimensions))
                 (do ((idx 0 (+ 1 idx))
                      (row row (cdr row)))
                     ((>= idx (car dims)))
                   (l2ra (cdr dims) (cons idx idxs) (car row))))))
        (l2ra dimensions '() lst)
        nra))

    ;; Returns a rank-nested list consisting of all the elements, in row-major order,
    ;; of `ra`. In the case of a rank-0 array, `array->list` returns the single element.
    ;;
    ;; Examples:
    ;;   (array->list #2A((ho ho ho) (ho oh oh)))    ==> ((ho ho ho) (ho oh oh))
    ;;   (array->list #0A ho)                        ==> ho
    (define (array->list ra)
      (define (ra2l dims idxs)
        (if (null? dims)
            (apply array-ref ra (reverse idxs))
            (do ((lst '() (cons (ra2l (cdr dims) (cons idx idxs)) lst))
                 (idx (+ -1 (car dims)) (+ -1 idx)))
                ((negative? idx) lst))))
      (ra2l (array-dimensions ra) '()))

    ;; `vector->array` returns an array of type @2 consisting of all the elements, in
    ;; row-major order, of @1.  In the case of a rank-0 array, @1 has a single element.
    ;; `vect` must be a vector of length equal to the product of exact nonnegative
    ;; integers `dimensions`.
    ;;
    ;; Examples:
    ;;   (vector->array #(1 2 3 4) #() 2 2)     ==> #2A((1 2) (3 4))
    ;;   (vector->array '#(3) '#())             ==> #0A 3
    (define (vector->array vect prototype . dimensions)
      (let ((vdx (vector-length vect)))
        (if (not (eqv? vdx (apply * dimensions)))
            (error "Vector length does not equal product of dimensions:"
                   vdx dimensions))
        (let ((ra (apply make-array prototype dimensions)))
          (define (v2ra dims idxs)
            (cond ((null? dims)
                   (set! vdx (+ -1 vdx))
                   (apply array-set! ra (vector-ref vect vdx) (reverse idxs)))
                  (else
                   (do ((idx (+ -1 (car dims)) (+ -1 idx)))
                       ((negative? idx) vect)
                     (v2ra (cdr dims) (cons idx idxs))))))
          (v2ra dimensions '())
          ra)))

    ;; Returns a new vector consisting of all the elements of `ra` in row-major order.
    ;;
    ;; Examples:
    ;;   (array->vector #2A ((1 2)( 3 4)))      ==> #(1 2 3 4)
    ;;   (array->vector #0A ho)                 ==> #(ho)
    (define (array->vector ra)
      (let* ((dims (array-dimensions ra))
             (vdx  (apply * dims))
             (vect (make-vector vdx)))
        (define (ra2v dims idxs)
          (if (null? dims)
              (let ((val (apply array-ref ra (reverse idxs))))
                (set! vdx (+ -1 vdx))
                (vector-set! vect vdx val)
                vect)
              (do ((idx (+ -1 (car dims)) (+ -1 idx)))
                  ((negative? idx) vect)
                (ra2v (cdr dims) (cons idx idxs)))))
        (ra2v dims '())))

    (define (array:in-bounds? array indices)
      (do ((bnds (array-dimensions array) (cdr bnds))
           (idxs indices (cdr idxs)))
          ((or (null? bnds)
               (null? idxs)
               (not (integer? (car idxs)))
               (not (< -1 (car idxs) (car bnds))))
           (and (null? bnds) (null? idxs)))))

    ;; Returns #t if its arguments would be acceptable to `array-ref`.
    (define (array-in-bounds? array . indices)
      (array:in-bounds? array indices))

    ;; Returns the (`indices`, ...) element of `array`.
    (define (array-ref array . indices)
      (let ((store (array:store array)))
        (or (array:in-bounds? array indices)
            (error "Bad indices:" indices))
        ((if (string? store) string-ref vector-ref)
         store (apply + (array:offset array) (map * (array:scales array) indices)))))

    ;; Stores `obj` in the (`indices`, ...) element of `array`. The value returned
    ;; by `array-set!` is unspecified.
    (define (array-set! array obj . indices)
      (let ((store (array:store array)))
        (or (array:in-bounds? array indices)
            (error "Bad indices:" indices))
        ((if (string? store) string-set! vector-set!)
         store (apply + (array:offset array) (map * (array:scales array) indices))
         obj)))

    ;; These functions return a prototypical uniform-array enclosing the
    ;; optional argument (which must be of the correct type). If the
    ;; uniform-array type is supported by the implementation, then it is
    ;; returned; defaulting to the next larger precision type; resorting
    ;; finally to vector.

    (define (make-prototype-checker name pred? creator)
      (lambda args
        (case (length args)
          ((1)  (if (pred? (car args))
                    (creator (car args))
                    (error "Incompatible type:" name (car args))))
          ((0)  (creator))
          (else (error "Wrong number of arguments:" name args)))))

    (define (integer-bytes?? n)
      (lambda (obj)
        (and (integer? obj)
             (exact? obj)
             (or (negative? n) (not (negative? obj)))
             (do ((num obj (quotient num 256))
                  (n (+ -1 (abs n)) (+ -1 n)))
                 ((or (zero? num) (negative? n)) (zero? num))))))

    ;; Returns an inexact 128.bit flonum complex uniform-array prototype.
    (define a:floc128b (make-prototype-checker 'a:floc128b complex? vector))

    ;; Returns an inexact 64.bit flonum complex uniform-array prototype.
    (define a:floc64b (make-prototype-checker 'a:floc64b complex? vector))

    ;; Returns an inexact 32.bit flonum complex uniform-array prototype.
    (define a:floc32b (make-prototype-checker 'a:floc32b complex? vector))

    ;; Returns an inexact 16.bit flonum complex uniform-array prototype.
    (define a:floc16b (make-prototype-checker 'a:floc16b complex? vector))

    ;; Returns an inexact 128.bit flonum real uniform-array prototype.
    (define a:flor128b (make-prototype-checker 'a:flor128b real? vector))

    ;; Returns an inexact 64.bit flonum real uniform-array prototype.
    (define a:flor64b (make-prototype-checker 'a:flor64b real? vector))

    ;; Returns an inexact 32.bit flonum real uniform-array prototype.
    (define a:flor32b (make-prototype-checker 'a:flor32b real? vector))

    ;; Returns an inexact 16.bit flonum real uniform-array prototype.
    (define a:flor16b (make-prototype-checker 'a:flor16b real? vector))

    ;; Returns an exact 128.bit decimal flonum rational uniform-array prototype.
    (define a:flor128b (make-prototype-checker 'a:flor128b real? vector))

    ;; Returns an exact 64.bit decimal flonum rational uniform-array prototype.
    (define a:flor64b (make-prototype-checker 'a:flor64b real? vector))

    ;; Returns an exact 32.bit decimal flonum rational uniform-array prototype.
    (define a:flor32b (make-prototype-checker 'a:flor32b real? vector))

    ;; Returns an exact binary fixnum uniform-array prototype with at least
    ;; 64 bits of precision.
    (define a:fixz64b (make-prototype-checker 'a:fixz64b (integer-bytes?? -8) vector))

    ;; Returns an exact binary fixnum uniform-array prototype with at least
    ;; 32 bits of precision.
    (define a:fixz32b (make-prototype-checker 'a:fixz32b (integer-bytes?? -4) vector))

    ;; Returns an exact binary fixnum uniform-array prototype with at least
    ;; 16 bits of precision.
    (define a:fixz16b (make-prototype-checker 'a:fixz16b (integer-bytes?? -2) vector))

    ;; Returns an exact binary fixnum uniform-array prototype with at least
    ;; 8 bits of precision.
    (define a:fixz8b (make-prototype-checker 'a:fixz8b (integer-bytes?? -1) vector))

    ;; Returns an exact non-negative binary fixnum uniform-array prototype with at
    ;; least 64 bits of precision.
    (define a:fixn64b (make-prototype-checker 'a:fixn64b (integer-bytes?? 8) vector))

    ;; Returns an exact non-negative binary fixnum uniform-array prototype with at
    ;; least 32 bits of precision.
    (define a:fixn32b (make-prototype-checker 'a:fixn32b (integer-bytes?? 4) vector))

    ;; Returns an exact non-negative binary fixnum uniform-array prototype with at
    ;; least 16 bits of precision.
    (define a:fixn16b (make-prototype-checker 'a:fixn16b (integer-bytes?? 2) vector))

    ;; Returns an exact non-negative binary fixnum uniform-array prototype with at
    ;; least 8 bits of precision.
    (define a:fixn8b (make-prototype-checker 'a:fixn8b (integer-bytes?? 1) vector))

    ;;Returns a boolean uniform-array prototype.
    (define a:bool (make-prototype-checker 'a:bool boolean? vector))
  )
)

;;; SRFI 64
;;; A Scheme API for test suites
;;;
;;; This SRFI defines an API for writing test suites, to make it easy to portably test
;;; Scheme APIs, libraries, applications, and implementations. A test suite is a collection
;;; of test cases that execute in the context of a test-runner. This specifications also
;;; supports writing new test-runners, to allow customization of reporting and processing
;;; the result of running test suites.
;;;
;;; Here is a simple example explaining how test suites look like:
;;;   (test-begin "my tests")
;;;   (test-equal "equal 1" (list 1 2 3) '(1 2 3))
;;;   (test-equal "equal 2" (vector 1 2 3) #(1 2 3))
;;;   (test-group "General"
;;;     (test-equal "g1 eq 1" 0.0 0.0)
;;;     (test-equal "g1 eq 2" "hello" "hello"))
;;;   (test-end)
;;;
;;; Copyright (c) 2005, 2006, 2007, 2012, 2013 Per Bothner
;;; Added "full" support for Chicken, Gauche, Guile and SISC.
;;;   Alex Shinn, Copyright (c) 2005.
;;; Modified for Scheme Spheres by Álvaro Castro-Castilla, Copyright (c) 2012.
;;; Support for Guile 2 by Mark H Weaver <mhw@netris.org>, Copyright (c) 2014.
;;;
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use, copy,
;;; modify, merge, publish, distribute, sublicense, and/or sell copies
;;; of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;;; SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 64)

  (export test-begin
          test-end
          test-assert
          test-eqv
          test-eq
          test-equal
          test-approximate
          test-error
          test-apply
          test-with-runner
          test-match-nth
          test-match-all
          test-match-any
          test-match-name
          test-skip
          test-expect-fail
          test-read-eval-string
          test-runner-group-path
          test-group
          test-group-with-cleanup
          test-result-ref
          test-result-set!
          test-result-clear
          test-result-remove
          test-result-kind
          test-passed?
          test-log-to-file
          test-runner?
          test-runner-reset
          test-runner-null
          test-runner-simple
          test-runner-current
          test-runner-factory
          test-runner-get
          test-runner-create
          test-runner-test-name
          test-runner-pass-count
          test-runner-pass-count!
          test-runner-fail-count
          test-runner-fail-count!
          test-runner-xpass-count
          test-runner-xpass-count!
          test-runner-xfail-count
          test-runner-xfail-count!
          test-runner-skip-count
          test-runner-skip-count!
          test-runner-group-stack
          test-runner-group-stack!
          test-runner-on-test-begin
          test-runner-on-test-begin!
          test-runner-on-test-end
          test-runner-on-test-end!
          test-runner-on-group-begin
          test-runner-on-group-begin!
          test-runner-on-group-end
          test-runner-on-group-end!
          test-runner-on-final
          test-runner-on-final!
          test-runner-on-bad-count
          test-runner-on-bad-count!
          test-runner-on-bad-end-name
          test-runner-on-bad-end-name!
          test-result-alist
          test-result-alist!
          test-runner-aux-value
          test-runner-aux-value!
          test-on-group-begin-simple
          test-on-group-end-simple
          test-on-bad-count-simple
          test-on-bad-end-name-simple
          test-on-final-simple
          test-on-test-end-simple)

  (import (lispkit base))

  (begin

    (define-record-type test-runner
     (%test-runner-alloc)
     test-runner?
     ;; Cumulate count of all tests that have passed and were expected to.
     (pass-count test-runner-pass-count test-runner-pass-count!)
     (fail-count test-runner-fail-count test-runner-fail-count!)
     (xpass-count test-runner-xpass-count test-runner-xpass-count!)
     (xfail-count test-runner-xfail-count test-runner-xfail-count!)
     (skip-count test-runner-skip-count test-runner-skip-count!)
     (skip-list %test-runner-skip-list %test-runner-skip-list!)
     (fail-list %test-runner-fail-list %test-runner-fail-list!)
     ;; Normally #t, except when in a test-apply.
     (run-list %test-runner-run-list %test-runner-run-list!)
     (skip-save %test-runner-skip-save %test-runner-skip-save!)
     (fail-save %test-runner-fail-save %test-runner-fail-save!)
     (group-stack test-runner-group-stack test-runner-group-stack!)
     (on-test-begin test-runner-on-test-begin test-runner-on-test-begin!)
     (on-test-end test-runner-on-test-end test-runner-on-test-end!)
     ;; Call-back when entering a group. Takes (runner suite-name count).
     (on-group-begin test-runner-on-group-begin test-runner-on-group-begin!)
     ;; Call-back when leaving a group.
     (on-group-end test-runner-on-group-end test-runner-on-group-end!)
     ;; Call-back when leaving the outermost group.
     (on-final test-runner-on-final test-runner-on-final!)
     ;; Call-back when expected number of tests was wrong.
     (on-bad-count test-runner-on-bad-count test-runner-on-bad-count!)
     ;; Call-back when name in test=end doesn't match test-begin.
     (on-bad-end-name test-runner-on-bad-end-name test-runner-on-bad-end-name!)
     ;; Cumulate count of all tests that have been done.
     (total-count %test-runner-total-count %test-runner-total-count!)
     ;; Stack (list) of (count-at-start . expected-count):
     (count-list %test-runner-count-list %test-runner-count-list!)
     (result-alist test-result-alist test-result-alist!)
     ;; Field can be used by test-runner for any purpose.
     ;; test-runner-simple uses it for a log file.
     (aux-value test-runner-aux-value test-runner-aux-value!))

    (define (test-runner-reset runner)
     (test-result-alist! runner '())
     (test-runner-pass-count! runner 0)
     (test-runner-fail-count! runner 0)
     (test-runner-xpass-count! runner 0)
     (test-runner-xfail-count! runner 0)
     (test-runner-skip-count! runner 0)
     (%test-runner-total-count! runner 0)
     (%test-runner-count-list! runner '())
     (%test-runner-run-list! runner #t)
     (%test-runner-skip-list! runner '())
     (%test-runner-fail-list! runner '())
     (%test-runner-skip-save! runner '())
     (%test-runner-fail-save! runner '())
     (test-runner-group-stack! runner '()))

    (define (test-runner-group-path runner)
     (reverse (test-runner-group-stack runner)))

    (define (%test-null-callback runner) #f)

    (define (test-runner-null)
     (let ((runner (%test-runner-alloc)))
       (test-runner-reset runner)
       (test-runner-on-group-begin! runner (lambda (runner name count) #f))
       (test-runner-on-group-end! runner %test-null-callback)
       (test-runner-on-final! runner %test-null-callback)
       (test-runner-on-test-begin! runner %test-null-callback)
       (test-runner-on-test-end! runner %test-null-callback)
       (test-runner-on-bad-count! runner (lambda (runner count expected) #f))
       (test-runner-on-bad-end-name! runner (lambda (runner begin end) #f))
       runner))

    ;; Not part of the specification.  FIXME
    ;; Controls whether a log file is generated.
    (define test-log-to-file #f)

    (define (test-runner-simple)
     (let ((runner (%test-runner-alloc)))
       (test-runner-reset runner)
       (test-runner-on-group-begin! runner test-on-group-begin-simple)
       (test-runner-on-group-end! runner test-on-group-end-simple)
       (test-runner-on-final! runner test-on-final-simple)
       (test-runner-on-test-begin! runner test-on-test-begin-simple)
       (test-runner-on-test-end! runner test-on-test-end-simple)
       (test-runner-on-bad-count! runner test-on-bad-count-simple)
       (test-runner-on-bad-end-name! runner test-on-bad-end-name-simple)
       runner))

    (define test-runner-current (make-parameter #f))
    (define test-runner-factory (make-parameter test-runner-simple))

    ;; A safer wrapper to test-runner-current.
    (define (test-runner-get)
     (let ((r (test-runner-current)))
       (if (not r)
           (error "test-runner not initialized - test-begin missing?"))
           r))

    (define (%test-specifier-matches spec runner)
     (spec runner))

    (define (test-runner-create)
     ((test-runner-factory)))

    (define (%test-any-specifier-matches list runner)
     (let ((result #f))
       (let loop ((l list))
         (cond ((null? l) result)
               (else      (if (%test-specifier-matches (car l) runner)
                              (set! result #t))
                              (loop (cdr l)))))))

    ;; Returns #f, #t, or 'xfail.
    (define (%test-should-execute runner)
     (let ((run (%test-runner-run-list runner)))
       (cond ((or
                (not (or (eqv? run #t)
                         (%test-any-specifier-matches run runner)))
                (%test-any-specifier-matches
                  (%test-runner-skip-list runner)
                  runner))
              (test-result-set! runner 'result-kind 'skip)
              #f)
             ((%test-any-specifier-matches
                (%test-runner-fail-list runner)
                runner)
              (test-result-set! runner 'result-kind 'xfail)
              'xfail)
             (else #t))))

    (define (%test-begin suite-name count)
     (if (not (test-runner-current))
         (test-runner-current (test-runner-create)))
         (let ((runner (test-runner-current)))
           ((test-runner-on-group-begin runner) runner suite-name count)
           (%test-runner-skip-save! runner
                                    (cons (%test-runner-skip-list runner)
                                          (%test-runner-skip-save runner)))
           (%test-runner-fail-save! runner
                                    (cons (%test-runner-fail-list runner)
                                          (%test-runner-fail-save runner)))
           (%test-runner-count-list! runner
                                     (cons (cons (%test-runner-total-count runner) count)
                                           (%test-runner-count-list runner)))
           (test-runner-group-stack! runner (cons suite-name
                                                  (test-runner-group-stack runner)))))

    (define-syntax test-begin
     (syntax-rules ()
       ((test-begin suite-name)
         (%test-begin suite-name #f))
       ((test-begin suite-name count)
         (%test-begin suite-name count))))

    (define (test-on-group-begin-simple runner suite-name count)
     (if (null? (test-runner-group-stack runner))
       (begin
         (display "%%%% Starting test ")
         (display suite-name)
         (if test-log-to-file
           (let* ((log-file-name
                    (if (string? test-log-to-file) test-log-to-file
                      (string-append suite-name ".log")))
                  (log-file (open-output-file log-file-name)))
             (display "%%%% Starting test " log-file)
             (display suite-name log-file)
             (newline log-file)
             (test-runner-aux-value! runner log-file)
             (display "  (Writing full log to \"")
             (display log-file-name)
             (display "\")")))
         (newline)))
     (let ((log (test-runner-aux-value runner)))
       (if (output-port? log)
         (begin
           (display "Group begin: " log)
           (display suite-name log)
           (newline log))))
     #f)

    (define (test-on-group-end-simple runner)
     (let ((log (test-runner-aux-value runner)))
       (if (output-port? log)
         (begin
           (display "Group end: " log)
           (display (car (test-runner-group-stack runner)) log)
           (newline log))))
     #f)

    (define (%test-on-bad-count-write runner count expected-count port)
     (display "*** Total number of tests was " port)
     (display count port)
     (display " but should be " port)
     (display expected-count port)
     (display ". ***" port)
     (newline port)
     (display "*** Discrepancy indicates testsuite error or exceptions. ***" port)
     (newline port))

    (define (test-on-bad-count-simple runner count expected-count)
     (%test-on-bad-count-write runner count expected-count (current-output-port))
     (let ((log (test-runner-aux-value runner)))
       (if (output-port? log)
         (%test-on-bad-count-write runner count expected-count log))))

    (define (test-on-bad-end-name-simple runner begin-name end-name)
     (let ((msg (string-append (%test-format-line runner) "test-end " begin-name
                               " does not match test-begin " end-name)))
       (error msg)))


    (define (%test-final-report1 value label port)
     (if (> value 0)
       (begin
         (display label port)
         (display value port)
         (newline port))))

    (define (%test-final-report-simple runner port)
     (%test-final-report1 (test-runner-pass-count runner)
                          "# of expected passes      " port)
     (%test-final-report1 (test-runner-xfail-count runner)
                          "# of expected failures    " port)
     (%test-final-report1 (test-runner-xpass-count runner)
                          "# of unexpected successes " port)
     (%test-final-report1 (test-runner-fail-count runner)
                          "# of unexpected failures  " port)
     (%test-final-report1 (test-runner-skip-count runner)
                          "# of skipped tests        " port))

    (define (test-on-final-simple runner)
     (%test-final-report-simple runner (current-output-port))
     (let ((log (test-runner-aux-value runner)))
       (if (output-port? log)
         (begin
           (%test-final-report-simple runner log)
           (display "%%%% Closing log file\n")
           (close-output-port log)))))

    (define (%test-format-line runner)
     (let* ((line-info (test-result-alist runner))
            (source-file (assq 'source-file line-info))
            (source-line (assq 'source-line line-info))
            (file (if source-file (cdr source-file) "")))
       (if source-line
         (string-append file ":"
                        (number->string (cdr source-line)) ": ")
         "")))

    (define (%test-end suite-name line-info)
     (let* ((r (test-runner-get))
            (groups (test-runner-group-stack r))
            (line (%test-format-line r)))
       (test-result-alist! r line-info)
       (if (null? groups)
         (let ((msg (string-append line "test-end not in a group")))
           (error msg)))
       (if (and suite-name (not (equal? suite-name (car groups))))
         ((test-runner-on-bad-end-name r) r suite-name (car groups)))
       (let* ((count-list (%test-runner-count-list r))
              (expected-count (cdar count-list))
              (saved-count (caar count-list))
              (group-count (- (%test-runner-total-count r) saved-count)))
         (if (and expected-count
                  (not (= expected-count group-count)))
           ((test-runner-on-bad-count r) r group-count expected-count))
         ((test-runner-on-group-end r) r)
         (test-runner-group-stack! r (cdr (test-runner-group-stack r)))
         (%test-runner-skip-list! r (car (%test-runner-skip-save r)))
         (%test-runner-skip-save! r (cdr (%test-runner-skip-save r)))
         (%test-runner-fail-list! r (car (%test-runner-fail-save r)))
         (%test-runner-fail-save! r (cdr (%test-runner-fail-save r)))
         (%test-runner-count-list! r (cdr count-list))
         (if (null? (test-runner-group-stack r))
           ((test-runner-on-final r) r)))))

    (define-syntax test-group
     (syntax-rules ()
                   ((test-group suite-name . body)
                    (let ((r (test-runner-current)))
                      ;; Ideally should also set line-number, if available.
                      (test-result-alist! r (list (cons 'test-name suite-name)))
                      (if (%test-should-execute r)
                        (dynamic-wind
                          (lambda () (test-begin suite-name))
                          (lambda () . body)
                          (lambda () (test-end  suite-name))))))))

    (define-syntax test-group-with-cleanup
     (syntax-rules ()
                   ((test-group-with-cleanup suite-name form cleanup-form)
                    (test-group suite-name
                                (dynamic-wind
                                  (lambda () #f)
                                  (lambda () form)
                                  (lambda () cleanup-form))))
                   ((test-group-with-cleanup suite-name cleanup-form)
                    (test-group-with-cleanup suite-name #f cleanup-form))
                   ((test-group-with-cleanup suite-name form1 form2 form3 . rest)
                    (test-group-with-cleanup suite-name (begin form1 form2) form3 . rest))))

    (define (test-on-test-begin-simple runner)
     (let ((log (test-runner-aux-value runner)))
       (if (output-port? log)
         (let* ((results (test-result-alist runner))
                (source-file (assq 'source-file results))
                (source-line (assq 'source-line results))
                (source-form (assq 'source-form results))
                (test-name (assq 'test-name results)))
           (display "Test begin:" log)
           (newline log)
           (if test-name (%test-write-result1 test-name log))
           (if source-file (%test-write-result1 source-file log))
           (if source-line (%test-write-result1 source-line log))
           (if source-form (%test-write-result1 source-form log))))))

    (define-syntax test-result-ref
     (syntax-rules ()
                   ((test-result-ref runner pname)
                    (test-result-ref runner pname #f))
                   ((test-result-ref runner pname default)
                    (let ((p (assq pname (test-result-alist runner))))
                      (if p (cdr p) default)))))

    (define (test-on-test-end-simple runner)
     (let ((log (test-runner-aux-value runner))
           (kind (test-result-ref runner 'result-kind)))
       (if (memq kind '(fail xpass))
         (let* ((results (test-result-alist runner))
                (source-file (assq 'source-file results))
                (source-line (assq 'source-line results))
                (test-name (assq 'test-name results)))
           (if (or source-file source-line)
             (begin
               (if source-file (display (cdr source-file)))
               (display ":")
               (if source-line (display (cdr source-line)))
               (display ": ")))
           (display (if (eq? kind 'xpass) "XPASS" "FAIL"))
           (if test-name
             (begin
               (display " ")
               (display (cdr test-name))))
           (newline)))
       (if (output-port? log)
         (begin
           (display "Test end:" log)
           (newline log)
           (let loop ((list (test-result-alist runner)))
             (if (pair? list)
               (let ((pair (car list)))
                 ;; Write out properties not written out by on-test-begin.
                 (if (not (memq (car pair)
                                '(test-name source-file source-line source-form)))
                   (%test-write-result1 pair log))
                 (loop (cdr list)))))))))

    (define (%test-write-result1 pair port)
     (display "  " port)
     (display (car pair) port)
     (display ": " port)
     (write (cdr pair) port)
     (newline port))

    (define (test-result-set! runner pname value)
     (let* ((alist (test-result-alist runner))
            (p (assq pname alist)))
       (if p
         (set-cdr! p value)
         (test-result-alist! runner (cons (cons pname value) alist)))))

    (define (test-result-clear runner)
     (test-result-alist! runner '()))

    (define (test-result-remove runner pname)
     (let* ((alist (test-result-alist runner))
            (p (assq pname alist)))
       (if p
         (test-result-alist! runner
                             (let loop ((r alist))
                               (if (eq? r p) (cdr r)
                                 (cons (car r) (loop (cdr r)))))))))

    (define (test-result-kind . rest)
     (let ((runner (if (pair? rest) (car rest) (test-runner-current))))
       (test-result-ref runner 'result-kind)))

    (define (test-passed? . rest)
     (let ((runner (if (pair? rest) (car rest) (test-runner-get))))
       (memq (test-result-ref runner 'result-kind) '(pass xpass))))

    (define (%test-report-result)
     (let* ((r (test-runner-get))
            (result-kind (test-result-kind r)))
       (case result-kind
         ((pass)
           (test-runner-pass-count! r (+ 1 (test-runner-pass-count r))))
         ((fail)
           (test-runner-fail-count! r (+ 1 (test-runner-fail-count r))))
         ((xpass)
           (test-runner-xpass-count! r (+ 1 (test-runner-xpass-count r))))
         ((xfail)
           (test-runner-xfail-count! r (+ 1 (test-runner-xfail-count r))))
         (else
           (test-runner-skip-count! r (+ 1 (test-runner-skip-count r)))))
       (%test-runner-total-count! r (+ 1 (%test-runner-total-count r)))
       ((test-runner-on-test-end r) r)))

    (define-syntax %test-evaluate-with-catch
     (syntax-rules ()
                   ((%test-evaluate-with-catch test-expression)
                    (guard (err (#t #f)) test-expression))))

    (define (%test-on-test-begin r)
     (%test-should-execute r)
     ((test-runner-on-test-begin r) r)
     (not (eq? 'skip (test-result-ref r 'result-kind))))

    (define (%test-on-test-end r result)
     (test-result-set! r 'result-kind
                       (if (eq? (test-result-ref r 'result-kind) 'xfail)
                         (if result 'xpass 'xfail)
                         (if result 'pass 'fail))))

    (define (test-runner-test-name runner)
     (test-result-ref runner 'test-name ""))

    (define-syntax %test-comp2body
     (syntax-rules ()
       ((%test-comp2body r comp expected expr)
         (let ()
           (if (%test-on-test-begin r)
             (let ((exp expected))
               (test-result-set! r 'expected-value exp)
               (let ((res (%test-evaluate-with-catch expr)))
                 (test-result-set! r 'actual-value res)
                 (%test-on-test-end r (comp exp res)))))
           (%test-report-result)))))

    (define (%test-approximate= error)
     (lambda (value expected)
       (let ((rval (real-part value))
             (ival (imag-part value))
             (rexp (real-part expected))
             (iexp (imag-part expected)))
         (and (>= rval (- rexp error))
              (>= ival (- iexp error))
              (<= rval (+ rexp error))
              (<= ival (+ iexp error))))))

    (define-syntax %test-comp1body
     (syntax-rules ()
       ((%test-comp1body r expr)
        (let ()
          (if (%test-on-test-begin r)
            (let ()
              (let ((res (%test-evaluate-with-catch expr)))
                (test-result-set! r 'actual-value res)
                (%test-on-test-end r res))))
          (%test-report-result)))))

    (define-syntax test-end
     (syntax-rules ()
       ((test-end)
         (%test-end #f '()))
       ((test-end suite-name)
         (%test-end suite-name '()))))

    (define-syntax test-assert
     (syntax-rules ()
       ((test-assert tname test-expression)
         (let* ((r (test-runner-get))
                (name tname))
           (test-result-alist! r '((test-name . tname)))
           (%test-comp1body r test-expression)))
        ((test-assert test-expression)
          (let* ((r (test-runner-get)))
            (test-result-alist! r '())
            (%test-comp1body r test-expression)))))

    (define-syntax %test-comp2
     (syntax-rules ()
       ((%test-comp2 comp tname expected expr)
         (let* ((r (test-runner-get))
                (name tname))
           (test-result-alist! r (list (cons 'test-name tname)))
           (%test-comp2body r comp expected expr)))
        ((%test-comp2 comp expected expr)
          (let* ((r (test-runner-get)))
            (test-result-alist! r '())
            (%test-comp2body r comp expected expr)))))

    (define-syntax test-equal
     (syntax-rules ()
       ((test-equal . rest)
        (%test-comp2 equal? . rest))))

    (define-syntax test-eqv
     (syntax-rules ()
       ((test-eqv . rest)
        (%test-comp2 eqv? . rest))))

    (define-syntax test-eq
     (syntax-rules ()
       ((test-eq . rest)
         (%test-comp2 eq? . rest))))

    (define-syntax test-approximate
     (syntax-rules ()
       ((test-approximate tname expected expr error)
         (%test-comp2 (%test-approximate= error) tname expected expr))
       ((test-approximate expected expr error)
         (%test-comp2 (%test-approximate= error) expected expr))))

    (define-syntax %test-error
     (syntax-rules ()
                   ((%test-error r etype expr)
                    (%test-comp1body r (guard (ex (#t #t)) expr #f)))))

    (define-syntax test-error
     (syntax-rules ()
       ((test-error name etype expr)
         (let ((r (test-runner-get)))
           (test-result-alist! r `((test-name . ,name)))
           (%test-error r etype expr)))
       ((test-error etype expr)
         (let ((r (test-runner-get)))
           (test-result-alist! r '())
           (%test-error r etype expr)))
       ((test-error expr)
         (let ((r (test-runner-get)))
           (test-result-alist! r '())
           (%test-error r #t expr)))))

    (define-syntax test-with-runner
     (syntax-rules ()
       ((test-with-runner runner form ...)
        (let ((saved-runner (test-runner-current)))
          (dynamic-wind
            (lambda () (test-runner-current runner))
            (lambda () form ...)
            (lambda () (test-runner-current saved-runner)))))))

    (define (test-apply first . rest)
     (if (test-runner? first)
       (test-with-runner first (apply test-apply rest))
       (let ((r (test-runner-current)))
         (if r
           (let ((run-list (%test-runner-run-list r)))
             (cond ((null? rest)
                    (%test-runner-run-list! r (reverse run-list))
                    (first)) ;; actually apply procedure thunk
                   (else
                     (%test-runner-run-list!
                       r
                       (if (eq? run-list #t)
                         (list first)
                         (cons first run-list)))
                     (apply test-apply rest)
                     (%test-runner-run-list! r run-list))))
           (let ((r (test-runner-create)))
             (test-with-runner r (apply test-apply first rest))
             ((test-runner-on-final r) r))))))

    ;;; Predicates

    (define (%test-match-nth n count)
     (let ((i 0))
       (lambda (runner)
         (set! i (+ i 1))
         (and (>= i n) (< i (+ n count))))))

    (define-syntax test-match-nth
     (syntax-rules ()
                   ((test-match-nth n)
                    (test-match-nth n 1))
                   ((test-match-nth n count)
                    (%test-match-nth n count))))

    (define (%test-match-all . pred-list)
     (lambda (runner)
       (let ((result #t))
         (let loop ((l pred-list))
           (if (null? l)
             result
             (begin
               (if (not ((car l) runner))
                   (set! result #f))
               (loop (cdr l))))))))

    (define-syntax test-match-all
     (syntax-rules ()
                   ((test-match-all pred ...)
                    (%test-match-all (%test-as-specifier pred) ...))))

    (define (%test-match-any . pred-list)
     (lambda (runner)
       (let ((result #f))
         (let loop ((l pred-list))
           (if (null? l)
             result
             (begin
               (if ((car l) runner)
                   (set! result #t))
               (loop (cdr l))))))))

    (define-syntax test-match-any
     (syntax-rules ()
                   ((test-match-any pred ...)
                    (%test-match-any (%test-as-specifier pred) ...))))

    ;; Coerce to a predicate function
    (define (%test-as-specifier specifier)
     (cond ((procedure? specifier) specifier)
           ((integer? specifier)   (test-match-nth 1 specifier))
           ((string? specifier)    (test-match-name specifier))
           (else                   (error "not a valid test specifier"))))

    (define-syntax test-skip
     (syntax-rules ()
       ((test-skip pred ...)
         (let ((runner (test-runner-get)))
           (%test-runner-skip-list! runner
                                    (cons (test-match-all (%test-as-specifier pred)
                                                          ...)
                                          (%test-runner-skip-list runner)))))))

    (define-syntax test-expect-fail
     (syntax-rules ()
       ((test-expect-fail pred ...)
         (let ((runner (test-runner-get)))
           (%test-runner-fail-list! runner
                                    (cons (test-match-all (%test-as-specifier pred) ...)
                                          (%test-runner-fail-list runner)))))))

    (define (test-match-name name)
     (lambda (runner)
       (equal? name (test-runner-test-name runner))))

    (define (test-read-eval-string string)
     (let* ((port (open-input-string string))
            (form (read port)))
       (if (eof-object? (read-char port))
           (eval form)
           (error "(not at eof)"))))
  )
)
;;; SRFI 69
;;; Basic hash tables
;;;
;;; This SRFI defines basic hash tables. Hash tables are widely recognised as a
;;; fundamental data structure for a wide variety of applications. A hash table
;;; is a data structure that:
;;;
;;;   1. provides a mapping from some set of keys to some set of values
;;;      associated to those keys
;;;   2. has no intrinsic order for the (key, value) associations it contains
;;;   3. supports in-place modification as the primary means of setting the
;;;      contents of a hash table
;;;   4. provides key lookup and destructive update in amortised constant time,
;;;      provided that a good hash function is used.
;;;
;;; This SRFI aims to accomplish these goals:
;;;
;;;   1. to provide a consistent, generic and widely applicable API for hash tables
;;;   2. to improve code portability by providing a standard hash table facility
;;;      with guaranteed behaviour
;;;   3. to help the programmer by defining utility routines that account for the
;;;      most common situations of using hash tables.
;;;
;;; Specification:
;;;   Copyright © 2005 Panu Kalliokoski. All rights reserved.
;;;
;;; Implementation:
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 69)

  (export make-hash-table
          hash-table?
          alist->hash-table
          hash-table-equivalence-function
          hash-table-hash-function
          hash-table-ref
          hash-table-ref/default
          hash-table-set!
          hash-table-delete!
          hash-table-exists?
          hash-table-update!
          hash-table-update!/default
          hash-table-size
          hash-table-keys
          hash-table-values
          hash-table-walk
          hash-table-fold
          hash-table->alist
          hash-table-copy
          hash-table-merge!
          hash
          string-hash
          string-ci-hash
          symbol-hash
          hash-by-identity)

  (import (lispkit core)
          (lispkit control)
          (lispkit dynamic)
          (lispkit list)
          (lispkit math)
          (lispkit string)
          (except (lispkit hashtable) string-hash string-ci-hash symbol-hash equal-hash eq-hash)
          (srfi 69 internal))

  (begin

    ;; (make-hash-table [ equal? [ hash [ args … ]]]) -> hash-table
    ;;
    ;; Create a new hash table with no associations. equal? is a predicate that should accept
    ;; two keys and return a boolean telling whether they denote the same key value; it
    ;; defaults to equal?.
    ;;
    ;; hash is a hash function, and defaults to an appropriate hash function for the given
    ;; equal? predicate (see section Hashing). However, an acceptable default is not guaranteed
    ;; to be given for any equivalence predicate coarser than equal?, except for string-ci=?.
    ;; The function hash must be acceptable for equal?, so if you use coarser equivalence
    ;; than equal? other than string-ci=?, you must always provide the function hash yourself.
    ;;
    ;; Implementations are allowed to use the rest args for implementation-specific extensions.
    ;; Be warned, though, that using these extensions will make your program less portable.
    (define (make-hash-table . args)
      (let*-optionals args ((comparison equal?)
                            (hash (appropriate-hash-function-for comparison))
                            (size default-table-size))
        (new-hash-table (make-hashtable hash comparison size))))

    ;; (alist->hash-table alist [ equal? [ hash [ args … ]]]) -> hash-table
    ;;
    ;; Takes an association list alist and creates a hash table hash-table which maps
    ;; the car of every element in alist to the cdr of corresponding elements in alist.
    ;; equal?, hash, and args are interpreted as in make-hash-table. If some key occurs
    ;; multiple times in alist, the value in the first association will take precedence
    ;; over later ones.
    ;;
    ;; The rest args are passed to make-hash-table and can thus be used for
    ;; implementation-specific extensions.
    (define (alist->hash-table alist . args)
      (let*-optionals args ((comparison equal?)
                            (hash (appropriate-hash-function-for comparison))
                            (size default-table-size))
        (let ((hashtable (make-hashtable hash comparison size)))
          (for-each (lambda (elem) (hashtable-update! hashtable (car elem) identity (cdr elem)))
                    alist)
          (new-hash-table hashtable))))

    ;; (hash-table-equivalence-function hash-table) -> procedure
    ;;
    ;; Returns the equivalence predicate used for keys of hash-table.
    (define (hash-table-equivalence-function ht)
      (hashtable-equivalence-function (get-hashtable ht)))

    ;; (hash-table-hash-function hash-table) -> procedure
    ;;
    ;; Returns the hash function used for keys of hash-table.
    (define (hash-table-hash-function ht)
      (hashtable-hash-function (get-hashtable ht)))

    ;; (hash-table-ref hash-table key [ thunk ]) -> value
    ;;
    ;; This procedure returns the value associated to key in hash-table. If no value is
    ;; associated to key and thunk is given, it is called with no arguments and its value
    ;; is returned; if thunk is not given, an error is signalled. Given a good hash
    ;; function, this operation should have an (amortised) complexity of O(1) with respect
    ;; to the number of associations in hash-table.
    (define (hash-table-ref ht key . maybe-default)
      (let ((value (hashtable-ref (get-hashtable ht) key missing-key)))
        (if (eq? value missing-key)
            (if (null? maybe-default)
                (error "hash-table-ref: no value associated with" key)
                ((car maybe-default)))
            value)))

    ;; (hash-table-ref/default hash-table key default) -> value
    ;;
    ;; Evaluates to the same value as (hash-table-ref hash-table key (lambda () default)).
    ;; Given a good hash function, this operation should have an (amortised) complexity
    ;; of O(1) with respect to the number of associations in hash-table.
    (define (hash-table-ref/default ht key default)
      (hashtable-ref (get-hashtable ht) key default))

    ;; (hash-table-set! hash-table key value)
    ;;
    ;; This procedure sets the value associated to key in hash-table. The previous
    ;; association (if any) is removed. Given a good hash function, this operation
    ;; should have an (amortised) complexity of O(1) with respect to the number of
    ;; associations in hash-table.
    (define (hash-table-set! ht key value)
      (hashtable-set! (get-hashtable ht) key value))

    ;; (hash-table-delete! hash-table key)
    ;;
    ;; This procedure removes any association to key in hash-table. It is not an error
    ;; if no association for that key exists; in this case, nothing is done. Given a
    ;; good hash function, this operation should have an (amortised) complexity of O(1)
    ;; with respect to the number of associations in hash-table.
    (define (hash-table-delete! ht key)
      (hashtable-delete! (get-hashtable ht) key))

    ;; (hash-table-exists? hash-table key) -> boolean
    ;;
    ;; This predicate tells whether there is any association to key in hash-table.
    ;; Given a good hash function, this operation should have an (amortised) complexity
    ;; of O(1) with respect to the number of associations in hash-table.
    (define (hash-table-exists? ht key)
      (hashtable-contains? (get-hashtable ht) key))

    ;; (hash-table-update! hash-table key function [ thunk ])
    ;;
    ;; Semantically equivalent to, but may be implemented more efficiently than,
    ;; the following code:
    ;; `(hash-table-set! hash-table key (function (hash-table-ref hash-table key thunk)))`
    (define (hash-table-update! ht key function . maybe-default)
      (hashtable-update! (get-hashtable ht)
                         key
                         (lambda (x)
                           (if (eq? x missing-key)
                               (if (null? maybe-default)
                                   (error "hash-table-update!: no value exists for key" key)
                                   (function ((car maybe-default))))
                               (function x)))
                         missing-key))

    ;; (hash-table-update!/default hash-table key function default)
    ;;
    ;; Behaves as if it evaluates to
    ;; `(hash-table-update! hash-table key function (lambda () default))`.
    (define (hash-table-update!/default ht key function default)
      (hashtable-update! (get-hashtable ht) key function default))

    ;; (hash-table-size hash-table) -> integer
    ;;
    ;; Returns the number of associations in hash-table. This operation must have a
    ;; complexity of O(1) with respect to the number of associations in hash-table.
    (define (hash-table-size ht)
      (hashtable-size (get-hashtable ht)))

    ;; (hash-table-keys hash-table) -> list
    ;;
    ;; Returns a list of keys in hash-table. The order of the keys is unspecified.
    (define (hash-table-keys ht)
      (hashtable-key-list (get-hashtable ht)))

    ;; (hash-table-values hash-table) -> list
    ;;
    ;; Returns a list of values in hash-table. The order of the values is unspecified,
    ;; and is not guaranteed to match the order of keys in the result of hash-table-keys.
    (define (hash-table-values ht)
      (hashtable-value-list (get-hashtable ht)))

    ;; (hash-table-walk hash-table proc)
    ;;
    ;; proc should be a function taking two arguments, a key and a value. This procedure
    ;; calls proc for each association in hash-table, giving the key of the association
    ;; as key and the value of the association as value. The results of proc are discarded.
    ;; The order in which proc is called for the different associations is unspecified.
    (define (hash-table-walk ht proc)
      (hashtable-for-each proc (get-hashtable ht)))

    ;; (hash-table-fold hash-table f init-value) -> final-value
    ;;
    ;; This procedure calls f for every association in hash-table with three arguments:
    ;; the key of the association key, the value of the association value, and an
    ;; accumulated value, val. val is init-value for the first invocation of f, and
    ;; for subsequent invocations of f, the return value of the previous invocation
    ;; of f. The value final-value returned by hash-table-fold is the return value of
    ;; the last invocation of f. The order in which f is called for different associations
    ;; is unspecified.
    (define (hash-table-fold ht f acc)
      (hashtable-for-each (lambda (key value) (set! acc (f key value acc))) (get-hashtable ht))
      acc)

    ;; (hash-table->alist hash-table) -> alist
    ;;
    ;; Returns an association list such that the car of each element in alist is a key in
    ;; hash-table and the corresponding cdr of each element in alist is the value associated
    ;; to the key in hash-table. The order of the elements is unspecified.
    (define (hash-table->alist ht)
      (hashtable->alist (get-hashtable ht)))

    ;; (hash-table-copy hash-table) -> hash-table
    ;;
    ;; Returns a new hash table with the same equivalence predicate, hash function and
    ;; mappings as in hash-table.
    (define (hash-table-copy ht)
      (new-hash-table (hashtable-copy (get-hashtable ht) #t)))

    ;; (hash-table-merge! hash-table1 hash-table2) -> hash-table
    ;;
    ;; Adds all mappings in hash-table2 into hash-table1 and returns the resulting hash
    ;; table. This function may modify hash-table1 destructively.
    (define (hash-table-merge! ht1 ht2)
      (hashtable-union! (get-hashtable ht1) (get-hashtable ht2)))
  )
)
;;; SRFI 8
;;; Binding to multiple values
;;;
;;; The only mechanism that R5RS provides for binding identifiers to the values of a
;;; multiple-valued expression is the primitive call-with-values. This SRFI proposes
;;; a more concise, more readable syntax for creating such bindings.
;;;
;;; Copyright © 1999 John David Stone. All rights reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2017 Matthias Zenger. All rights reserved.

(define-library (srfi 8)

  (export receive)

  (import (lispkit base))

  (begin
    (define-syntax receive
      (syntax-rules ()
        ((receive formals expression body ...)
          (call-with-values (lambda () expression)
                            (lambda formals body ...)))))
  )
)
;;; SRFI 87
;;; `=>` in case clauses
;;;
;;; This SRFI proposes an extension to the `case` syntax to allow `=>` clauses as in `cond`.
;;;
;;; Author of spec: Chongkai Zhu
;;;
;;; Copyright © 2020 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 87)

  (export case)

  (import (lispkit control))

  ;; The form is implemented natively in library `(lispkit control)`
)
;;; SRFI 9
;;; Defining Record Types
;;;
;;; This SRFI describes syntax for creating new data types, called record types. A predicate,
;;; constructor, and field accessors and modifiers are defined for each record type. Each new
;;; record type is distinct from all existing types, including other record types and Scheme's
;;; predefined types.
;;;
;;; Copyright © 1999 Richard Kelsey. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2020 Matthias Zenger. All rights reserved.

(define-library (srfi 9)

  (export define-record-type)

  (import (lispkit record))

  ;; all exported procedures are implemented natively in library `(lispkit record)`
)
;;; SRFI 95
;;; Sorting and Merging
;;;
;;; Sorting and merging are useful operations deserving a common API. This SRFI
;;; defines simple functions supporting sorting and merging. The sort procedures
;;; operate on lists and arrays, which includes vectors. The merge procedures
;;; operate on lists.
;;;
;;; "sort.scm" Defines: sorted?, merge, merge!, sort, sort!
;;; Author : Richard A. O'Keefe (based on Prolog code by D.H.D.Warren)
;;;
;;; Made an R7RS library by Taylan Ulrich Bayırlı/Kammer, Copyright (C) 2014.
;;;
;;; Copyright © 2006 Aubrey Jaffer. All Rights Reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to
;;; deal in the Software without restriction, including without limitation the
;;; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
;;; IN THE SOFTWARE.
;;;
;;; Updated: 11 June 1991
;;; Modified for scheme library: Aubrey Jaffer 19 Sept. 1991
;;; Updated: 19 June 1995
;;; (sort, sort!, sorted?): Generalized to strings by jaffer: 2003-09-09
;;; (sort, sort!, sorted?): Generalized to arrays by jaffer: 2003-10-04
;;; jaffer: 2006-10-08:
;;; (sort, sort!, sorted?, merge, merge!): Added optional KEY argument.
;;; jaffer: 2006-11-05:
;;; (sorted?, merge, merge!, sort, sort!): Call KEY arg at most once
;;; per element.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2018 Matthias Zenger. All rights reserved.

(define-library (srfi 95)

  (export sorted?
          merge
          merge!
          sort
          sort!)

  (import (except (scheme base) equal?)
          (srfi 63))

  (begin

    ;; (sorted? sequence less?)
    ;; is true when sequence is a list (x0 x1 ... xm) or a vector #(x0 ... xm)
    ;; such that for all 1 <= i <= m,
    ;;     (not (less? (list-ref list i) (list-ref list (- i 1)))).
    (define (sorted? seq less? . opt-key)
      (define key (if (null? opt-key) values (car opt-key)))
      (cond ((null? seq) #t)
    	((array? seq)
    	 (let ((dimax (+ -1 (car (array-dimensions seq)))))
    	   (or (<= dimax 1)
    	       (let loop ((idx (+ -1 dimax))
    			  (last (key (array-ref seq dimax))))
    		 (or (negative? idx)
    		     (let ((nxt (key (array-ref seq idx))))
    		       (and (less? nxt last)
    			    (loop (+ -1 idx) nxt))))))))
    	((null? (cdr seq)) #t)
    	(else
    	 (let loop ((last (key (car seq)))
    		    (next (cdr seq)))
    	   (or (null? next)
    	       (let ((nxt (key (car next))))
    		 (and (not (less? nxt last))
    		      (loop nxt (cdr next)))))))))

    ;; (merge a b less?)
    ;; takes two lists a and b such that (sorted? a less?) and (sorted? b less?)
    ;; and returns a new list in which the elements of a and b have been stably
    ;; interleaved so that (sorted? (merge a b less?) less?).
    ;; Note:  this does _not_ accept arrays.  See below.
    (define (merge a b less? . opt-key)
      (define key (if (null? opt-key) values (car opt-key)))
      (cond ((null? a) b)
    	((null? b) a)
    	(else
    	 (let loop ((x (car a)) (kx (key (car a))) (a (cdr a))
    		    (y (car b)) (ky (key (car b))) (b (cdr b)))
    	   ;; The loop handles the merging of non-empty lists.  It has
    	   ;; been written this way to save testing and car/cdring.
    	   (if (less? ky kx)
    	       (if (null? b)
    		   (cons y (cons x a))
    		   (cons y (loop x kx a (car b) (key (car b)) (cdr b))))
    	       ;; x <= y
    	       (if (null? a)
    		   (cons x (cons y b))
    		   (cons x (loop (car a) (key (car a)) (cdr a) y ky b))))))))

    (define (sort:merge! a b less? key)
      (define (loop r a kcara b kcarb)
        (cond ((less? kcarb kcara)
    	   (set-cdr! r b)
    	   (if (null? (cdr b))
    	       (set-cdr! b a)
    	       (loop b a kcara (cdr b) (key (cadr b)))))
    	  (else				; (car a) <= (car b)
    	   (set-cdr! r a)
    	   (if (null? (cdr a))
    	       (set-cdr! a b)
    	       (loop a (cdr a) (key (cadr a)) b kcarb)))))
      (cond ((null? a) b)
    	((null? b) a)
    	(else
    	 (let ((kcara (key (car a)))
    	       (kcarb (key (car b))))
    	   (cond
    	    ((less? kcarb kcara)
    	     (if (null? (cdr b))
    		 (set-cdr! b a)
    		 (loop b a kcara (cdr b) (key (cadr b))))
    	     b)
    	    (else			; (car a) <= (car b)
    	     (if (null? (cdr a))
    		 (set-cdr! a b)
    		 (loop a (cdr a) (key (cadr a)) b kcarb))
    	     a))))))

    ;; takes two sorted lists a and b and smashes their cdr fields to form a
    ;; single sorted list including the elements of both.
    ;; Note:  this does _not_ accept arrays.
    (define (merge! a b less? . opt-key)
      (sort:merge! a b less? (if (null? opt-key) values (car opt-key))))

    (define (sort:sort-list! seq less? key)
      (define keyer (if key car values))
      (define (step n)
        (cond ((> n 2) (let* ((j (quotient n 2))
    			  (a (step j))
    			  (k (- n j))
    			  (b (step k)))
    		     (sort:merge! a b less? keyer)))
    	  ((= n 2) (let ((x (car seq))
    			 (y (cadr seq))
    			 (p seq))
    		     (set! seq (cddr seq))
    		     (cond ((less? (keyer y) (keyer x))
    			    (set-car! p y)
    			    (set-car! (cdr p) x)))
    		     (set-cdr! (cdr p) '())
    		     p))
    	  ((= n 1) (let ((p seq))
    		     (set! seq (cdr seq))
    		     (set-cdr! p '())
    		     p))
    	  (else '())))
      (define (key-wrap! lst)
        (cond ((null? lst))
    	  (else (set-car! lst (cons (key (car lst)) (car lst)))
    		(key-wrap! (cdr lst)))))
      (define (key-unwrap! lst)
        (cond ((null? lst))
    	  (else (set-car! lst (cdar lst))
    		(key-unwrap! (cdr lst)))))
      (cond (key
    	 (key-wrap! seq)
    	 (set! seq (step (length seq)))
    	 (key-unwrap! seq)
    	 seq)
    	(else
    	 (step (length seq)))))

    (define (rank-1-array->list array)
      (define dimensions (array-dimensions array))
      (do ((idx (+ -1 (car dimensions)) (+ -1 idx))
           (lst '() (cons (array-ref array idx) lst)))
          ((< idx 0) lst)))

    ;; (sort! sequence less?)
    ;; sorts the list, array, or string sequence destructively.  It uses
    ;; a version of merge-sort invented, to the best of my knowledge, by
    ;; David H. D.  Warren, and first used in the DEC-10 Prolog system.
    ;; R. A. O'Keefe adapted it to work destructively in Scheme.
    ;; A. Jaffer modified to always return the original list.
    (define (sort! seq less? . opt-key)
      (define key (if (null? opt-key) #f (car opt-key)))
      (cond ((array? seq)
    	 (let ((dims (array-dimensions seq)))
    	   (do ((sorted (sort:sort-list! (rank-1-array->list seq) less? key)
    			(cdr sorted))
    		(i 0 (+ i 1)))
    	       ((null? sorted) seq)
    	     (array-set! seq (car sorted) i))))
    	(else			      ; otherwise, assume it is a list
    	 (let ((ret (sort:sort-list! seq less? key)))
    	   (if (not (eq? ret seq))
    	       (do ((crt ret (cdr crt)))
    		   ((eq? (cdr crt) seq)
    		    (set-cdr! crt ret)
    		    (let ((scar (car seq)) (scdr (cdr seq)))
    		      (set-car! seq (car ret)) (set-cdr! seq (cdr ret))
    		      (set-car! ret scar) (set-cdr! ret scdr)))))
    	   seq))))

    ;; (sort sequence less?)
    ;; sorts a array, string, or list non-destructively.  It does this
    ;; by sorting a copy of the sequence.  My understanding is that the
    ;; Standard says that the result of append is always "newly
    ;; allocated" except for sharing structure with "the last argument",
    ;; so (append x '()) ought to be a standard way of copying a list x.
    (define (sort seq less? . opt-key)
      (define key (if (null? opt-key) #f (car opt-key)))
      (cond ((array? seq)
    	 (let ((dims (array-dimensions seq)))
    	   (define newra (apply make-array seq dims))
    	   (do ((sorted (sort:sort-list! (rank-1-array->list seq) less? key)
    			(cdr sorted))
    		(i 0 (+ i 1)))
    	       ((null? sorted) newra)
    	     (array-set! newra (car sorted) i))))
    	(else (sort:sort-list! (append seq '()) less? key))))
    )
)

;;; SRFI 98
;;; An interface to access environment variables
;;;
;;; This SRFI specifies the procedure `get-environment-variable`, which gets the value of the
;;; specified environment variable, and the procedure `get-environment-variables`, which gets
;;; an association list of all environment variables.
;;;
;;; Author of spec: Taro Minowa (Higepon)
;;;
;;; Copyright © 2020 Matthias Zenger. All rights reserved.
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
;;; except in compliance with the License. You may obtain a copy of the License at
;;;
;;;   http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software distributed under the
;;; License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;;; either express or implied. See the License for the specific language governing permissions
;;; and limitations under the License.

(define-library (srfi 98)

  (export get-environment-variable
          get-environment-variables)

  (import (lispkit system))

  ;; Both procedures are implemented natively in library `(lispkit system)`
)
;;; SRFI SICP (equivalent to SRFI 216)
;;; SICP Prerequisites
;;;
;;; This SRFI provides "out-of-the-box" support for hosting the exercises suggested by
;;; "Structure and Interpretation of Computer Programs". It primarily provides procedures
;;; for working with time data and streams, as well as SICP names for true and false.
;;; Support for multi-threading is omitted due to LispKit currently not supporting threads.
;;; None of the provided procedures are fit for production use. They are only designed for
;;; pedagogical purposes. Students are expected to be able to just write
;;;
;;;   (include (srfi sicp))
;;;
;;; and have the code from the book run without problems (apart from those intended by the
;;; book authors).
;;;
;;; Companion website of SICP: https://mitpress.mit.edu/sites/default/files/sicp/index.html
;;;
;;; Copyright © 2020 Vladimir Nikishkin. All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy of this
;;; software and associated documentation files (the "Software"), to deal in the Software
;;; without restriction, including without limitation the rights to use, copy, modify, merge,
;;; publish, distribute, sublicense, and/or sell copies of the Software, and to permit
;;; persons to whom the Software is furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all copies or
;;; substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
;;; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
;;; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.
;;;
;;; Adaptation to LispKit
;;;   Copyright © 2021 Matthias Zenger. All rights reserved.

(define-library (srfi sicp)

  (export runtime
          random
          parallel-execute
          test-and-set!
          cons-stream
          stream-null?
          the-empty-stream
          true
          false
          nil)

  (import (srfi 216)))
